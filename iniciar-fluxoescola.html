<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8"> 
    <meta name="viewport" contenta="width=device-width, initial-scale=1.0">
    <title>Iniciar Fluxo Escola - Sistema de Escala</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8"> 
    <meta name="viewport" contenta="width=device-width, initial-scale=1.0">
    <title>Iniciar Fluxo Escola - Sistema de Escala</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD1fkxq6USO5RX22TlsPQFEaVSZoTj_t2A",
            authDomain: "escalas-6e0f9.firebaseapp.com",
            projectId: "escalas-6e0f9",
            storageBucket: "escalas-6e0f9.firebasestorage.app",
            messagingSenderId: "19118998563",
            appId: "1:19118998563:web:5412be658ae34bd45add96"
        };

        // Initialize Firebase only if it's not already initialized
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
    </script>
    <style>

.lupa-icon {
    position: absolute;
    bottom: 10px;
    left: 70px; /* Ao lado do cadeado (que está em 40px) */
    cursor: pointer;
    color: #3498db; /* Azul */
    font-size: 16px;
    transition: all 0.3s ease;
}
.lupa-icon:hover {
    transform: scale(1.2) rotate(-10deg);
}

/* Estilos para o novo Popup de Análise de Par */
.analysis-popup .tabs {
    display: flex;
    border-bottom: 1px solid #ddd;
    margin-bottom: 15px;
}
.analysis-popup .tab-button {
    padding: 10px 15px;
    cursor: pointer;
    border: none;
    background-color: transparent;
    font-size: 16px;
    border-bottom: 3px solid transparent;
}
.analysis-popup .tab-button.active {
    border-bottom: 3px solid #3498db;
    font-weight: bold;
}
.analysis-popup .tab-content {
    display: none;
}
.analysis-popup .tab-content.active {
    display: block;
}

#validation-list {
    list-style: none;
    padding: 15px;
    margin: 0;
    max-height: 300px; /* Aumentado de 250px para 300px */
    overflow-y: auto;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            min-height: 100vh;
            background-color: #f5f6fa;
        }

        .sidebar {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 20px 0;
            height: 100vh;
            position: fixed;
        }

        .logo {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #34495e;
        }

        .nav-list {
            list-style: none;
            padding: 20px 0;
        }

        .nav-item {
            padding: 10px 20px;
        }

        .nav-item a {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
        }

        .nav-item:hover {
            background-color: #34495e;
        }

        .content {
            margin-left: 250px;
            padding: 30px;
            flex-grow: 1;
        }

        .card {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 600px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: bold;
        }

        .form-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            color: #2c3e50;
            background-color: white;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            padding: 4px 0;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .form-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52,152,219,0.3);
        }

        .btn-submit {
            background-color: #2ecc71;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            transition: all 0.3s ease;
        }

        .btn-submit:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        .designacoes-section {
            display: none;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        .designacoes-section.active {
            display: block;
        }

        .designacao-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 8px 16px;
            background-color: #f8f9fa;
            border-radius: 8px;
            min-height: 32px;
            position: relative;
            flex-direction: column;
            align-items: flex-start;
        }

        .filter-icon {
            position: absolute;
            bottom: 10px;
            left: 10px;
            cursor: pointer;
            color: #e67e22;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .filter-popup {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 200px;
        }

        .filter-popup.active {
            display: block;
        }

        .filter-popup h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .filter-popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            color: #2c3e50;
            margin-top: 8px;
        }

        .filter-icon:hover {
            color: #d35400;
            transform: rotate(15deg) scale(1.2);
        }

        .filter-popup {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 200px;
        }

        .filter-popup.active {
            display: block;
        }

        .designacao-item label {
            margin-bottom: 0;
            flex-grow: 1;
            font-size: 16px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .designacao-item label > span {
            flex-grow: 1;
            margin-left: 8px;
        }


        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            text-align: center;
        }

        /* Styles for order buttons */
        .order-button {
            background-color: #ddd;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            margin-right: 8px;
            color: #555;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .order-button.ordered {
            background-color: #2ecc71;
            color: white;
        }

        .order-button.ordered-level-2 {
            background-color: #3498db;
        }

        .order-button.ordered-level-3 {
            background-color: #f39c12;
        }

        .order-button.ordered-level-4 {
            background-color: #9b59b6;
        }

        .order-button.ordered-level-5 {
            background-color: #e74c3c;
        }

        .order-button.ordered-level-6 {
            background-color: #1abc9c;
        }

        .order-button.ordered-level-7 {
            background-color: #f1c40f;
        }

        .order-display {
            font-size: 14px;
            color: #777;
            margin-left: 4px;
        }

        /* Styles for quantity submenu */
        .quantity-submenu {
            position: relative;
            left: 0;
            top: auto;
            bottom: auto;
            transform: none;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            display: none;
            z-index: 10;
            margin-top: 5px;
        }


        .quantity-submenu.active {
            display: flex;
            gap: 5px;
        }

        .quantity-button {
            background-color: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background-color 0.3s ease;
        }

        .quantity-button.selected {
            background-color: #2ecc71;
            color: white;
        }

        .quantity-button:hover {
            background-color: #e0e0e0;
        }

        /* Styles for turbo button */
        .turbo-button-container {
        display: flex;
        justify-content: flex-end; /* Align to the right */
        margin-top: 10px;
        margin-bottom: 10px;
    }

    .turbo-button {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        transition: color 0.3s ease;
        margin-left: 10px; /* Add spacing between buttons */
    }

    .turbo-button:hover {
        color: #2980b9; /* Keep the hover effect */
    }

    .turbo-button[title*="Filtrar"] {
        transform-origin: center;
        transition: transform 0.3s ease, color, 0.3s ease;
    }

    .turbo-button[title*="Filtrar"]:hover {
        color: #e67e22;
        transform: rotate(15deg) scale(1.1);
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"] {
        transform-origin: center;
        transition: transform 0.3s ease, color, 0.3s ease;
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"]:hover {
        color: #27ae60;
        transform: translateY(-5px) scale(1.1);
        animation: rocket-shake 0.5s ease infinite;
    }

    @keyframes rocket-shake {
        0%, 100% { transform: translateY(-5px) rotate(0deg); }
        25% { transform: translateY(-5px) rotate(-2deg); }
        75% { transform: translateY(-5px) rotate(2deg); }
    }

    @keyframes rocket-loading {
        0% { transform: translateY(0) rotate(0deg); }
        15% { transform: translateY(0) rotate(-90deg); }
        30% { transform: translateY(0) rotate(-90deg); }
        50% { transform: translateY(-200px) rotate(-90deg); }
        70% { transform: translateY(-350px) rotate(-90deg); }
        90% { transform: translateY(-450px) rotate(-90deg); opacity: 0.3; }
        100% { transform: translateY(-500px) rotate(-90deg); opacity: 0; }
    }

    @keyframes rocket-return {
        0% { transform: translateY(-500px) rotate(180deg); opacity: 0; }
        20% { transform: translateY(-400px) rotate(180deg); opacity: 0.2; }
        40% { transform: translateY(-300px) rotate(180deg); opacity: 0.4; }
        60% { transform: translateY(-200px) rotate(180deg); opacity: 0.6; }
        80% { transform: translateY(-100px) rotate(180deg); opacity: 0.8; }
        90% { transform: translateY(-50px) rotate(180deg); opacity: 0.9; }
        100% { transform: translateY(0) rotate(180deg); opacity: 1; }
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"].loading {
        animation: rocket-loading 1s forwards;
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"].returning {
        animation: rocket-return 1s forwards;
    }

    /* Initially hide Leitura da Bíblia section */
    #leituraBibliaSection {
        display: none; /* Initially hidden */
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #ddd;
    }

    /* Initially hide Iniciar Fluxo button */
    #fluxoSemanalForm button[type="submit"].btn-submit {
        display: none; /* Initially hidden */
    }

    /* Styles for the popup */
    .popup-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
        z-index: 1000; /* Ensure it's on top */
        justify-content: center;
        align-items: center;
    }

    .popup-content {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        width: 80%;
        max-width: 700px;
        position: relative; /* For close button positioning */
    }

    .popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
    }

    .popup-title {
        color: #2c3e50;
        font-size: 24px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .popup-title .status-icon {
        display: none;
        font-size: 20px;
    }

    .popup-title .status-icon.thinking {
        display: none;
        color: #3498db;
        animation: spin 2s linear infinite;
    }

    .popup-title .status-icon.success {
        display: none;
        color: #2ecc71;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .popup-close-button {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #777;
        position: absolute;
        top: 10px;
        right: 10px;
    }

    .popup-designation-list {
        margin-bottom: 20px;
    }

    .popup-designation-item {
        margin-bottom: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
    }

    .popup-designation-name {
        font-weight: bold;
        margin-bottom: 5px;
        color: #34495e;
    }

    .popup-participant-list {
        list-style: none;
        padding-left: 20px;
    }

    .popup-participant-item {
        margin-bottom: 3px;
        color: #555;
    }

    .popup-actions {
        text-align: right;
    }


/* Estilo para o dropdown inválido */
.form-select.invalid-selection {
    border: 2px solid #e74c3c; /* Vermelho forte */
    background-color: #fbeae5;
}

/* Container principal do alerta, fixo no canto inferior direito */
#validation-alert-container {
    position: fixed;
    bottom: 25px;
    right: 25px;
    z-index: 2000;
}

/* Ícone de perigo */
#validation-alert-icon {
    font-size: 36px;
    color: #e74c3c; /* Vermelho por defeito para erros críticos */
    cursor: pointer;
    background-color: white;
    border-radius: 50%;
    padding: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    transition: transform 0.2s ease, color 0.3s ease; /* Adiciona transição de cor */
}

#validation-alert-icon.warning-only {
    color: #f39c12; /* Laranja/Amarelo para avisos */
}

#validation-alert-icon:hover {
    transform: scale(1.1);
}

/* Painel que mostra os detalhes dos erros */
#validation-panel {
    display: none; /* Escondido por padrão */
    position: absolute;
    bottom: 0;
    right: 0;
    width: 350px;
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    overflow: hidden;
}

#validation-panel.active {
    display: block; /* Mostra o painel quando tem a classe 'active' */
}

#validation-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background-color: #34495e;
    color: white;
}

#validation-panel-header h3 {
    margin: 0;
    font-size: 16px;
}

#validation-panel-close {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    line-height: 1;
}

/* Lista de erros dentro do painel */
#validation-list {
    list-style: none;
    padding: 15px;
    margin: 0;
    max-height: 250px;
    overflow-y: auto;
}

#validation-list li {
    padding: 8px 0;
    border-bottom: 1px solid #eee;
    color: #333;
    font-size: 14px;
}

#validation-list li:last-child {
    border-bottom: none;
}


.lock-icon {
    position: absolute;
    bottom: 10px;
    left: 40px; /* Posicionado ao lado do ícone de filtro */
    cursor: pointer;
    color: #7f8c8d; /* Cor neutra para "desbloqueado" */
    font-size: 16px;
    transition: all 0.3s ease;
}

.lock-icon:hover {
    color: #34495e;
    transform: scale(1.2);
}

/* Este estilo será aplicado quando o cadeado estiver "fechado" */
.lock-icon.locked {
    color: #e67e22; /* Uma cor de destaque (laranja) para "bloqueado" */
}



.lab-icon {
    position: absolute;
    bottom: 10px;
    left: 100px; /* Ao lado da lupa (que está em 70px) */
    cursor: pointer;
    color: #9b59b6; /* Roxo */
    font-size: 16px;
    transition: all 0.3s ease;
}
.lab-icon:hover {
    transform: scale(1.2) rotate(10deg);
}

/* Estilos para o popup do laboratório */
.lab-popup .lab-container {
    display: flex;
    gap: 30px;
}
.lab-popup .lab-current-selection {
    flex: 1;
}
.lab-popup .lab-suggestions {
    flex: 1;
    border-left: 1px solid #eee;
    padding-left: 30px;
}
.lab-popup .suggestion-group h4 {
    margin-bottom: 10px;
}
.lab-popup .suggestion-item {
    padding: 8px;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 5px;
}
.lab-popup .suggestion-item:hover {
    background-color: #f1f1f1;
}
.lab-popup .suggestion-justification {
    font-size: 0.8em;
    color: #777;
    margin-left: 10px;
}

/* =================================================================== */
/* = CSS CORRETIVO PARA O POPUP "LABORATÓRIO DE COMBINAÇÕES" = */
/* =================================================================== */

/* 1. Transforma o corpo do popup do laboratório num container flexível */
.lab-popup .popup-body {
    display: flex;
    flex-direction: column;
    /* Evita que o próprio corpo tenha uma barra de rolagem */
    overflow: hidden; 
    /* Garante que o corpo se estique para preencher o espaço vertical */
    flex-grow: 1; 
}

/* 2. Faz com que APENAS a área das duas colunas (o .lab-container) cresça e role */
.lab-popup .lab-container {
    flex-grow: 1; /* Diz para esta área ocupar todo o espaço vertical que sobrar */
    overflow-y: auto; /* Adiciona a barra de rolagem vertical APENAS SE necessário */
    padding-right: 15px; /* Adiciona espaço para a barra de rolagem não sobrepor o conteúdo */
}

/* 3. Garante que a área de ações (o botão) nunca encolha e permaneça visível */
.lab-popup .popup-actions {
    flex-shrink: 0;
}


/* Alvo: Apenas os filtros dentro do popup de estatísticas */
#estatisticasPopup .estatisticas-filtros-container {
    gap: 15px; /* Reduz o espaçamento entre os filtros */
}

/* Alvo: As etiquetas (labels) dos filtros */
#estatisticasPopup .estatisticas-filtros-container label {
    font-size: 13px; /* Reduz o tamanho do texto da etiqueta */
    margin-bottom: 5px; /* Reduz o espaço abaixo da etiqueta */
}

/* Alvo: Os dropdowns (selects) dos filtros */
#estatisticasPopup .estatisticas-filtros-container select {
    font-size: 13px;       /* Reduz o tamanho do texto dentro do dropdown */
    padding: 6px 10px;     /* Reduz a altura do dropdown (preenchimento interno) */
    width: 160px;          /* Reduz a largura do dropdown */
}

.form-select.warning-selection {
    border: 2px solid #f39c12; /* Laranja/Amarelo */
    background-color: #fef9e7;
}

/* Estilo para o item de aviso na lista do painel */
#validation-list li.warning-item {
    color: #8a6d3b; /* Cor de texto mais escura para legibilidade */
    display: flex;
    align-items: center;
}

/* Ícone de aviso amarelo para a lista */
#validation-list li.warning-item::before {
    content: "\f071"; /* Ícone de triângulo de aviso do Font Awesome */
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    margin-right: 10px;
    color: #f39c12;
}

#validation-list li.error-item {
    color: #c0392b; /* Um vermelho um pouco mais escuro para o texto ser legível */
    font-weight: bold; /* Dar mais ênfase à mensagem de erro */
    display: flex;
    align-items: center;
}

/* Ícone de erro vermelho para a lista */
#validation-list li.error-item::before {
    content: "\f071"; /* Mesmo ícone de triângulo, mas agora vermelho */
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    margin-right: 10px;
    color: #e74c3c; /* Vermelho forte, igual à borda */
}

.estatisticas-table thead th {
    cursor: pointer; /* Indica que o cabeçalho é clicável */
    position: relative;
    user-select: none; /* Previne a seleção de texto ao clicar rapidamente */
}

.estatisticas-table thead th .sort-indicator {
    margin-left: 5px;
    font-size: 0.8em;
}
    </style>
</head>
<body>
   

    <!-- =================================================================== -->
<!-- =========== INÍCIO: POPUP LABORATÓRIO DE COMBINAÇÕES ============= -->
<!-- =================================================================== -->
<div id="labPopup" class="popup-overlay">
    <div class="popup-content lab-popup" style="max-width: 90%; width: 1000px;">
        <div class="popup-header">
            <h2 class="popup-title">Laboratório de Combinações</h2>
            <button class="popup-close-button" id="closeLabPopup">×</button>
        </div>
        <div class="popup-body">
            <div class="lab-container">
                <div class="lab-current-selection" id="labSelectionContainer">
                    <!-- A réplica dos dropdowns aparecerá aqui -->
                </div>
                <div class="lab-suggestions" id="labSuggestionsContainer">
                    <!-- As sugestões aparecerão aqui -->
                </div>
            </div>
            <div class="popup-actions" style="margin-top: 20px;">
                <button class="btn-submit" id="applyLabChanges">Aplicar Modificação</button>
            </div>
        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- ============ FIM: POPUP LABORATÓRIO DE COMBINAÇÕES ============== -->
<!-- =================================================================== -->

   <!-- =================================================================== -->
<!-- ============= INÍCIO: PAINEL DE ALERTA DE VALIDAÇÃO ============== -->
<!-- =================================================================== -->
<div id="validation-alert-container" style="display: none;">
    <i id="validation-alert-icon" class="fas fa-exclamation-triangle" title="Alertas de Validação"></i>
    <div id="validation-panel">
        <div id="validation-panel-header">
            <h3>Regras Violadas</h3>
            <button id="validation-panel-close">×</button>
        </div>
        <ul id="validation-list">
            <!-- As mensagens de erro serão inseridas aqui via JavaScript -->
        </ul>
    </div>
</div>
<!-- =================================================================== -->
<!-- ================ FIM: PAINEL DE ALERTA DE VALIDAÇÃO =============== -->
<!-- =================================================================== -->
   
   <!-- =================================================================== -->
<!-- ============= INÍCIO: POPUP DE ANÁLISE DE PAR/TRIO =============== -->


<!-- =================================================================== -->
<!-- =============== INÍCIO: POPUP DE CONFIRMAÇÃO MEMORIAL ============= -->
<!-- =================================================================== -->
<div id="memorialConfirmationPopup" class="popup-overlay">
    <div class="popup-content" style="max-width: 500px;">
        <div class="popup-header">
            <h2 class="popup-title">Aviso de Evento Especial</h2>
        </div>
        <div class="popup-body" style="padding: 20px 0;">
            <p id="memorialPopupMessage" style="text-align: center; font-size: 16px; line-height: 1.6;">
                A data do Memorial coincide com esta semana. Deseja gravar um evento especial sem designações e concluir?
            </p>
        </div>
        <div class="popup-actions" style="display: flex; justify-content: flex-end; gap: 10px;">
            <button class="btn-submit" id="confirmMemorialSave" style="background-color: #2ecc71;">Sim, Gravar</button>
            <button class="btn-submit" id="cancelMemorialSave" style="background-color: #c0392b;">Cancelar</button>
        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- ================ FIM: POPUP DE CONFIRMAÇÃO MEMORIAL =============== -->
<!-- =================================================================== -->






<!-- =================================================================== -->
<div id="pairAnalysisPopup" class="popup-overlay">
    <div class="popup-content analysis-popup" style="max-width: 90%; width: 1200px;">
        <div class="popup-header">
            <h2 class="popup-title" id="pairAnalysisTitle">Análise de Designação</h2>
            <button class="popup-close-button" id="closePairAnalysisPopup">×</button>
        </div>
        <div class="popup-body">
            <div id="pairAnalysisTabsContainer" class="tabs">
                <!-- As abas (tabs) serão inseridas aqui via JS -->
            </div>
            <div id="pairAnalysisContentContainer">
                <!-- O conteúdo de cada aba será inserido aqui via JS -->
            </div>
        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- =============== FIM: POPUP DE ANÁLISE DE PAR/TRIO ================= -->
<!-- =================================================================== -->

   
    <!-- =================================================================== -->
<!-- ============= INÍCIO: POPUP DE PERFIL DO PARTICIPANTE ============= -->
<!-- =================================================================== -->
<div id="perfilPopup" class="popup-overlay">
    <div class="popup-content" style="max-width: 90%; width: 1200px;">
        <div class="popup-header">
            <h2 class="popup-title">Perfil do Participante</h2>
            <button class="popup-close-button" id="closePerfilPopup">×</button>
        </div>
        <div class="popup-body">

            <!-- Caixa de Pesquisa -->
            <div class="form-group" style="position: relative;">
                <label for="pesquisaPessoa">Pesquisar Participante:</label>
                <input type="text" id="pesquisaPessoa" class="form-control" placeholder="Comece a digitar um nome..." autocomplete="off">
                <div id="pesquisaSugestoes" class="search-suggestions">
                    <!-- Sugestões de nomes aparecerão aqui -->
                </div>
            </div>

            <!-- Filtros -->
            <div id="perfilFiltrosContainer" class="estatisticas-filtros-container" style="display: none;">
                <div class="form-group">
                    <label for="perfilFiltroAno">Ano:</label>
                    <select id="perfilFiltroAno"></select>
                </div>
                <div class="form-group">
                    <label for="perfilFiltroMes">Mês:</label>
                    <select id="perfilFiltroMes">
                        <option value="">Todos</option>
                        <option value="1">Janeiro</option>
                        <option value="2">Fevereiro</option>
                        <option value="3">Março</option>
                        <option value="4">Abril</option>
                        <option value="5">Maio</option>
                        <option value="6">Junho</option>
                        <option value="7">Julho</option>
                        <option value="8">Agosto</option>
                        <option value="9">Setembro</option>
                        <option value="10">Outubro</option>
                        <option value="11">Novembro</option>
                        <option value="12">Dezembro</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="perfilFiltroDesignacao">Designação:</label>
                    <select id="perfilFiltroDesignacao"></select>
                </div>
                <div class="form-group">
                    <label for="perfilFiltroPapel">Meu Papel:</label>
                    <select id="perfilFiltroPapel">
                        <option value="">Todos</option>
                        <option value="dirigente">Dirigente</option>
                        <option value="morador">Morador</option>
                        <option value="ajudante">Ajudante</option>
                        <option value="participante">Participante</option>
                    </select>
                </div>
            </div>

            <!-- Tabela de Histórico -->
            <div id="perfilLoading" style="text-align: center; padding: 40px; font-size: 18px; display: none;">
                <i class="fas fa-spinner fa-spin"></i> A carregar histórico...
            </div>
            <div id="perfilTableContainer" style="overflow-x: auto; max-height: 55vh; display: none;">
                <table class="estatisticas-table">
                    <thead>
                        <tr>
                            <th>Ano</th>
                            <th>Data</th>
                            <th>Designação</th>
                            <th>Companheiro(s)</th>
                            <th>Meu Papel</th>
                        </tr>
                    </thead>
                    <tbody id="perfilTableBody">
                        <!-- Linhas do histórico serão inseridas aqui -->
                    </tbody>
                </table>
            </div>

        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- ================ FIM: POPUP DE PERFIL DO PARTICIPANTE =============== -->
<!-- =================================================================== -->
    <!-- Statistics Popup Overlay -->
<div id="estatisticasPopup" class="popup-overlay">
    <div class="popup-content" style="max-width: 90%; width: 1200px;">
        <div class="popup-header">
            <h2 class="popup-title">Estatísticas de Participação</h2>
            <button class="popup-close-button" id="closeEstatisticasPopup">×</button>
        </div>
        <div class="popup-body">

            <!-- 1. Abas de Navegação -->
            <div class="tabs">
                <button class="tab-button active" data-tab="geral">Geral</button>
                <button class="tab-button" data-tab="maisMenos">Mais/Menos</button>
                <button class="tab-button" data-tab="menosDetalhado">Menos (detalhado)</button>
                <button class="tab-button" data-tab="nunca">Nunca</button>
                <button class="tab-button" data-tab="dirigentes">Dirigentes</button>
            </div>

            <!-- 2. Conteúdo das Abas -->
            <div class="tab-content-container">

                <!-- Aba 1: Geral (ESTRUTURA CORRIGIDA) -->
                <div id="tab-content-geral" class="tab-content active">
                    
      <div id="estatisticasFiltros" class="estatisticas-filtros-container">
    <div class="form-group">
        <label for="filtroAno">Ano:</label>
        <select id="filtroAno" name="filtroAno"></select>
    </div>
    <div class="form-group">
        <label for="filtroMes">Mês:</label>
        <select id="filtroMes" name="filtroMes">
            <option value="">Todos os Meses</option>
            <option value="1">Janeiro</option><option value="2">Fevereiro</option><option value="3">Março</option><option value="4">Abril</option><option value="5">Maio</option><option value="6">Junho</option><option value="7">Julho</option><option value="8">Agosto</option><option value="9">Setembro</option><option value="10">Outubro</option><option value="11">Novembro</option><option value="12">Dezembro</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroGenero">Género:</label>
        <select id="filtroGenero" name="filtroGenero">
            <option value="">Todos os Géneros</option>
            <option value="Masculino">Masculino</option>
            <option value="Feminino">Feminino</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroIdioma">Idioma:</label>
        <select id="filtroIdioma" name="filtroIdioma">
            <option value="">Todos os Idiomas</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroParte">Parte:</label>
        <select id="filtroParte" name="filtroParte">
            <option value="">Todas as Partes</option>
            <option value="escola" selected>Escola</option>
            <option value="resto da semana">Resto da Semana</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroDesignacaoGeral">Designação:</label>
        <!-- ALTERAÇÃO AQUI: O select começa vazio -->
        <select id="filtroDesignacaoGeral" name="filtroDesignacaoGeral">
            <!-- As opções serão totalmente geradas pelo JavaScript -->
        </select>
    </div>
</div>


                    <div id="estatisticasLoading" style="text-align: center; padding: 40px; font-size: 18px;">
                        <i class="fas fa-spinner fa-spin"></i> A carregar estatísticas...
                    </div>
                    <div id="estatisticasTableContainer">
                        <!-- A tabela de estatísticas original será gerada aqui -->
                    </div>

                </div>

                <!-- Aba 2: Mais/Menos -->
                <div id="tab-content-maisMenos" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

                <!-- Aba 3: Menos (detalhado) -->
                <div id="tab-content-menosDetalhado" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

                <!-- Aba 4: Nunca -->
                <div id="tab-content-nunca" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

                <!-- Aba 5: Dirigentes -->
                <div id="tab-content-dirigentes" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

            </div>
        </div>
    </div>
</div>


     <div id="sidebar-placeholder"></div>

    <main class="content">
        <style>

            /* =================================================================== */
/* ============= CSS PARA SUGESTÕES DE PESQUISA DE PERFIL ============ */
/* =================================================================== */
.search-suggestions {
    display: none; /* Escondido por padrão */
    position: absolute;
    border: 1px solid #ddd;
    border-top: none;
    background-color: white;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    z-index: 2000; /* Deve ficar sobre os outros elementos */
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.suggestion-item {
    padding: 10px;
    cursor: pointer;
}

.suggestion-item:hover {
    background-color: #f1f1f1;
}

/* Garante que o input do formulário tenha a classe para aplicar estilos */
#pesquisaPessoa {
    width: 100%;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
}

            .week-info {
                margin-bottom: 20px;
                padding: 15px;
                background-color: #f8f9fa;
                border-radius: 4px;
                border: 1px solid #e9ecef;
            }
            .week-info p {
                margin: 0;
                color: #2c3e50;
                font-size: 16px;
                text-align: center;
                line-height: 1.5em;
            }
                    /* Styles for Statistics Table */


        .estatisticas-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }

        .estatisticas-table th,
        .estatisticas-table td {
            border: 1px solid #ddd;
            padding: 10px 12px;
            text-align: left;
        }

        .estatisticas-table thead th {
            background-color: #34495e;
            color: white;
            z-index: 10;
        }
        
        .estatisticas-table thead th:first-child {
            min-width: 200px;
        }

        .estatisticas-table tbody tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .estatisticas-table tbody tr:hover {
            background-color: #e9ecef;
        }
        
        .estatisticas-table td:not(:first-child) {
            text-align: center;
        }

    .estatisticas-filtros-container {
    display: flex;
    flex-wrap: wrap; /* <-- ADICIONE ESTA LINHA */
    gap: 20px;
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
    align-items: flex-end;
}

        .estatisticas-filtros-container .form-group {
            margin-bottom: 0;
        }

        .estatisticas-filtros-container select {
            width: 180px; /* Largura fixa para os selects */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }


/* 1. Trava o scroll da página de fundo */
body.popup-open {
    overflow: hidden;
}

/* 2. Define a estrutura do popup: um cabeçalho fixo e um corpo que cresce */
#estatisticasPopup .popup-content {
    display: flex;
    flex-direction: column;
    max-height: 90vh;
}

/* 3. Garante que o cabeçalho do popup não encolha */
#estatisticasPopup .popup-header {
    flex-shrink: 0;
}

/* 4. A MÁGICA: O corpo do popup é a área de scroll */
#estatisticasPopup .popup-body {
    flex-grow: 1;       /* Ocupa todo o espaço vertical restante */
    overflow-y: auto;   /* Adiciona a barra de rolagem AQUI */
    padding: 15px;      /* Adiciona algum espaçamento interno para o conteúdo */
}

/* 5. Garante que o container da tabela NÃO tenha scroll ou altura limitada */
#estatisticasTableContainer {
    max-height: none;
    overflow: visible;
}

/* 6. IMPORTANTE: Garante que o cabeçalho da tabela NÃO seja 'sticky' para evitar conflitos */
.estatisticas-table thead th {
   position: static; /* Ou simplesmente remova qualquer regra 'position: sticky' */
}


.tabs {
    display: flex;
    border-bottom: 2px solid #ddd;
    margin-bottom: 20px;
}

/* Botão de cada aba */
.tab-button {
    padding: 12px 20px;
    cursor: pointer;
    border: none;
    background-color: transparent;
    font-size: 16px;
    color: #555;
    position: relative;
    top: 2px; /* Alinha com a borda inferior */
    border-bottom: 2px solid transparent;
}

.tab-button:hover {
    background-color: #f5f5f5;
    color: #333;
}

/* Estilo da aba ativa */
.tab-button.active {
    border-bottom: 2px solid #3498db;
    font-weight: bold;
    color: #3498db;
}

/* Container do conteúdo das abas */
.tab-content-container {
    padding-top: 10px;
}

/* Esconde as abas inativas */
.tab-content {
    display: none;
}

/* Mostra a aba ativa */
.tab-content.active {
    display: block;
}

/* Estilos para as colunas da aba "Mais/Menos" */
.mais-menos-container {
    display: flex;
    gap: 20px;
    justify-content: space-around;
}

.rank-column {
    flex: 1;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
}
.rank-column h4 {
    text-align: center;
    margin-top: 0;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}
.rank-column ol {
    padding-left: 20px;
    margin: 0;
}
.rank-column ol li {
    padding: 8px 5px;
    font-size: 15px;
}
.rank-column ol li:nth-child(odd) {
    background-color: #f9f9f9;
}

/* Cores específicas para cada coluna */
.col-mais { background-color: rgba(46, 204, 113, 0.08); border-left: 4px solid #2ecc71; }
.col-menos { background-color: rgba(231, 76, 60, 0.08); border-left: 4px solid #e74c3c; }
.col-antiga { background-color: rgba(243, 156, 18, 0.08); border-left: 4px solid #f39c12; }

/* Classe para destacar valores baixos na aba "Dirigentes" */
.low-participation {
    color: #e74c3c;
    font-weight: bold;
}



        </style>

        <div class="card">
            <h1>Iniciar Fluxo Escola</h1>
            <div class="week-info">
                <p id="weekDisplay">Carregando informações da semana...</p>
            </div>
            <form id="fluxoSemanalForm">
                <input type="hidden" id="semanaNumero" name="semanaNumero">
                <div class="form-group">
                    <label for="mes">Mês:</label>
                    <select id="mes" name="mes" required>
                        <option value="1">Janeiro</option>
                        <option value="2">Fevereiro</option>
                        <option value="3">Março</option>
                        <option value="4">Abril</option>
                        <option value="5">Maio</option>
                        <option value="6">Junho</option>
                        <option value="7">Julho</option>
                        <option value="8">Agosto</option>
                        <option value="9">Setembro</option>
                        <option value="10">Outubro</option>
                        <option value="11">Novembro</option>
                        <option value="12">Dezembro</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="tipo">Tipo de Reunião:</label>
                    <select id="tipo" name="tipo" required>
                        <option value="normal">Normal</option>
                        <option value="memorial">Memorial</option>
                        <option value="assembleia">Assembleia</option>
                        <option value="congresso">Congresso</option>
                        <option value="visita-servo">Visita do Servo</option>
                        <option value="evento-especial">Evento Especial</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Com Grupo?</label>
                    <div class="checkbox-group" id="nacionalidades">
                        <!-- Nacionalidades will be loaded here -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="sala">Sala:</label>
                    <select id="sala" name="sala" required>
                        <option value="salao-principal" selected>Salão Principal</option>
                        <option value="segunda-sala">Segunda Sala</option>
                        <option value="terceira-sala">Terceira Sala</option>
                    </select>
                </div>
                <button type="button" class="btn-submit" id="btnSeguinte">Seguinte</button>

                <div id="designacoesSection" class="designacoes-section">
                    <h4>Designações</h4>
                    <div id="designacoesList">
                        <!-- Designações will be loaded here -->
                    </div>
                    <div id="turboButtonContainer" class="turbo-button-container">
                        <button id="turboButton" class="turbo-button" type="button" title="Preencher Participantes Automaticamente" style="color: #2ecc71;">
                            <i class="fas fa-rocket"></i>
                        </button>
                        <button id="estatisticasButton" class="turbo-button" type="button" title="Estatísticas" style="color: #3498db;">
                            <i class="fas fa-chart-bar"></i>
                        </button>
                        <button id="pesquisarButton" class="turbo-button" type="button" title="Pesquisar (Futuro)" style="color: #f39c12;">
                            <i class="fas fa-search"></i>
                        </button>
                        <button id="perfilButton" class="turbo-button" type="button" title="Perfil do Participante (Futuro)" style="color: #9b59b6;">
                            <i class="fas fa-user"></i>
                        </button>
                    </div>

                <div id="leituraBibliaSection" class="designacoes-section">
                    <h4>Leitura da Bíblia - Participantes</h4>
                    <div id="leituraBibliaDesignationContainer">
                        <!-- Participant selections for Leitura da Bíblia will load here -->
                    </div>
                </div>

                <div id="activeDesignationsContainer">
                    <!-- Active designation participant selections will be loaded here -->
                </div>

                <button type="submit" class="btn-submit" style="margin-top: 20px;">Iniciar Fluxo</button>
            </form>
        </div>

        <!-- Confirmation Popup Overlay -->
        <div id="confirmationPopup" class="popup-overlay">
            <div class="popup-content">
                <div class="popup-header">
                    <div class="popup-title">
                        <h2>Criar Fluxo Escola</h2>
                        <i class="fas fa-cog status-icon thinking"></i>
                        <i class="fas fa-check-circle status-icon success"></i>
                    </div>
                    <button class="popup-close-button" id="closePopup">×</button>
                </div>
                <div class="popup-body">
                    <div id="popupDesignationSummary" class="popup-designation-list">
                        <!-- Designation summary will be loaded here -->
                    </div>
                </div>
                <div class="popup-actions">
                    <button class="btn-submit" id="createFluxoSemanal">Criar Fluxo Escola</button>
                </div>
            </div>
        </div>


    <script>
        
        document.addEventListener('DOMContentLoaded', function() {
        
            // Firebase configuration
            const firebaseConfig = {
                apiKey: "AIzaSyD1fkxq6USO5RX22TlsPQFEaVSZoTj_t2A",
                authDomain: "escalas-6e0f9.firebaseapp.com",
                projectId: "escalas-6e0f9",
                storageBucket: "escalas-6e0f9.firebasestorage.app",
                messagingSenderId: "19118998563",
                appId: "1:19118998563:web:5412be658ae34bd45add96"
            };

            

            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
            const db = firebase.firestore();

            // Set current month as default
            const currentMonth = new Date().getMonth() + 1;
            document.getElementById('mes').value = currentMonth;


 // ======================================================================== //
// ============ INÍCIO: LÓGICA DE SINCRONIZAÇÃO DE GÊNERO  ============== //
// ======================================================================== //

const handleGenderSync = (changedSelect) => {
    const instanceContainer = changedSelect.closest('.designacao-instance-container');
    if (!instanceContainer) return;

    // --- INÍCIO DA LÓGICA DO NOVO FILTRO ---
    // Primeiro, vamos encontrar o seletor do nosso novo filtro
    const mainContainer = changedSelect.closest('.active-designation-container');
    const genderMixSelect = mainContainer.querySelector('.gender-mix-select');

    // Verificamos o valor do filtro. Se for 'sim', o trabalho desta função muda.
    if (genderMixSelect && genderMixSelect.value === 'sim') {
        // Se a regra é "Sim", devemos garantir que NENHUM filtro de género está ativo.
        // Iremos percorrer todos os dropdowns e mostrar TODAS as opções.
        const allSelectsInInstance = instanceContainer.querySelectorAll('.form-select');
        allSelectsInInstance.forEach(select => {
            Array.from(select.options).forEach(option => {
                option.style.display = ''; // Mostra todas as opções
            });
        });
        return; // IMPORTANTE: Pára a execução da função aqui para não aplicar o bloqueio de género.
    }
    // --- FIM DA LÓGICA DO NOVO FILTRO ---

    // O código original abaixo só será executado se o filtro for "Não" (o comportamento padrão).
    const allSelectsInInstance = instanceContainer.querySelectorAll('.form-select');
    const selectedPersonId = changedSelect.value;

    if (!selectedPersonId) {
        allSelectsInInstance.forEach(select => {
            Array.from(select.options).forEach(option => {
                option.style.display = ''; 
            });
        });
        // Quando um campo é limpo, revalida as seleções restantes
        allSelectsInInstance.forEach(select => {
            if (select.value) handleGenderSync(select);
        });
        return;
    }

    const personData = allPeopleDataMap.get(selectedPersonId);
    if (!personData || !personData.genero) return;

    const requiredGender = personData.genero;

    allSelectsInInstance.forEach(select => {
        if (select !== changedSelect && select.value) {
            const otherPersonData = allPeopleDataMap.get(select.value);
            if (!otherPersonData || otherPersonData.genero !== requiredGender) {
                select.value = ''; 
            }
        }
        
        Array.from(select.options).forEach(option => {
            if (!option.value) {
                option.style.display = '';
                return;
            }
            const optionPersonData = allPeopleDataMap.get(option.value);
            if (optionPersonData && optionPersonData.genero === requiredGender) {
                option.style.display = '';
            } else {
                option.style.display = 'none';
            }
        });
    });
};

document.body.addEventListener('change', (event) => {
    if (event.target.classList.contains('form-select')) {
        handleGenderSync(event.target);
    }
});

// ======================================================================== //
// ============= FIM: LÓGICA DE SINCRONIZAÇÃO DE GÊNERO  =============== //
// ======================================================================== //



// ======================================================================== //
// ============ INÍCIO: LÓGICA DE VALIDAÇÃO EM TEMPO REAL (v2) ============ //
// ======================================================================== //

// --- FUNÇÃO AUXILIAR MODIFICADA para obter pares, papéis e datas ---
const getRecentPairs = async () => {
    // Aumentamos a janela para 12 meses para ter um histórico mais robusto
    const RECENT_MONTHS_WINDOW = 12;
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - RECENT_MONTHS_WINDOW);
    
    const recentPairsMap = new Map();
    const historicoRef = db.collection('historico');

    const q = historicoRef.where("timestamp", ">=", startDate);
    const snapshot = await q.get();

    snapshot.forEach(doc => {
        const historico = doc.data();
        if (historico.designacoes) {
            historico.designacoes.forEach(desig => {
                if (desig.participantes && Object.keys(desig.participantes).length >= 2) {
                    const ids = Object.values(desig.participantes);
                    const pairKey = ids.sort().join('_'); // Chave canónica do par

                    const rolesEntries = Object.entries(desig.participantes).sort((a, b) => a[1].localeCompare(b[1]));
                    const rolesKey = rolesEntries.map(([role, id]) => `${id}:${role}`).join('_');

                    if (!recentPairsMap.has(pairKey) || new Date(historico.dia) > new Date(recentPairsMap.get(pairKey).lastDate)) {
                        recentPairsMap.set(pairKey, {
                            lastDate: historico.dia,
                            lastRoles: rolesKey
                        });
                    }
                }
            });
        }
    });
    // LOG ADICIONADO
    console.log("[VALIDATION] -> DADOS (Pares Recentes):", recentPairsMap);
    return recentPairsMap;
};


// --- Função principal que valida TODAS as seleções na página (COM LOGS) ---
const validateAllSelections = async () => {
    console.log("[VALIDATION] 🚀 Função validateAllSelections iniciada.");

    const alertContainer = document.getElementById('validation-alert-container');
    const alertIcon = document.getElementById('validation-alert-icon');
    const validationList = document.getElementById('validation-list');

    // Limpa estilos antigos
    document.querySelectorAll('.form-select.invalid-selection, .form-select.warning-selection').forEach(el => {
        el.classList.remove('invalid-selection', 'warning-selection');
    });
    validationList.innerHTML = '';
    let allViolations = [];

    const ano = await getAnoPainelFirebase();
    const mes = parseInt(document.getElementById('mes').value);
    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);

    // --- OBTENÇÃO DOS DADOS ---
    const [participantsLastWeek, participantsNextWeek, recentPairsMap, participationStats] = await Promise.all([
        getParticipantsLastWeek(ano, mes, semanaNumero),
        getParticipantsNextWeek(ano, mes, semanaNumero),
        getRecentPairs(),
        getParticipationStatsForYear(ano)
    ]);

    // --- VERIFICAÇÕES INDIVIDUAIS ---
    const allSelects = document.querySelectorAll('#activeDesignationsContainer .form-select, #leituraBibliaDesignationContainer .form-select');
    const currentSelections = new Map();

    allSelects.forEach(select => {
        if (select.value) {
            const personId = select.value;
            const personName = select.options[select.selectedIndex].text;
            let hasRedError = false;

            if (currentSelections.has(personId)) {
                allViolations.push({ message: `${personName} está designado para mais de uma tarefa nesta semana.`, type: 'error' });
                select.classList.add('invalid-selection');
                currentSelections.get(personId).selectElement.classList.add('invalid-selection');
                hasRedError = true;
            } else {
                currentSelections.set(personId, { selectElement: select, name: personName });
            }
            if (participantsLastWeek.has(personId)) {
                allViolations.push({ message: `${personName} participou na semana anterior.`, type: 'error' });
                select.classList.add('invalid-selection');
                hasRedError = true;
            }
            if (participantsNextWeek.has(personId)) {
                allViolations.push({ message: `${personName} já está designado(a) para a semana seguinte.`, type: 'error' });
                select.classList.add('invalid-selection');
                hasRedError = true;
            }

            if (!hasRedError) {
                const designacaoId = select.closest('.active-designation-container')?.dataset.designacaoId;
                if (designacaoId && participationStats.has(designacaoId)) {
                    const statsForDesignation = participationStats.get(designacaoId);
                    const personCount = statsForDesignation.counts.get(personId) || 0;
                    const average = statsForDesignation.average;
                    if (personCount > average && average > 0) {
                        const violationMessage = `${personName} já realizou esta designação ${personCount} vez(es) este ano (acima da média de ${average.toFixed(1)}).`;
                        allViolations.push({ message: violationMessage, type: 'warning' });
                        select.classList.add('warning-selection');
                    }
                }
            }
        }
    });

    // --- VERIFICAÇÃO DE PARES ---
    document.querySelectorAll('#activeDesignationsContainer .designacao-instance-container, #leituraBibliaDesignationContainer .designacao-instance-container').forEach(instance => {
        const selectedPeople = [];
        const currentRoles = {};
        instance.querySelectorAll('.form-select').forEach((select, index) => {
            if (select.value) {
                const personId = select.value;
                const role = (index === 0) ? 'dirigente' : (index === 1) ? 'morador' : 'ajudante';
                currentRoles[role] = personId;
                selectedPeople.push({ id: personId, name: select.options[select.selectedIndex].text, element: select });
            }
        });
        if (selectedPeople.length >= 2) {
            const pairNames = selectedPeople.map(p => p.name).join(' e ');
            const ids = selectedPeople.map(p => p.id).sort();
            const pairKey = ids.join('_');
            const currentRolesEntries = Object.entries(currentRoles).sort((a, b) => a[1].localeCompare(b[1]));
            const currentRolesKey = currentRolesEntries.map(([role, id]) => `${id}:${role}`).join('_');
            if (recentPairsMap.has(pairKey)) {
                const history = recentPairsMap.get(pairKey);
                const lastDate = new Date(history.lastDate);
                const lastMonthYear = lastDate.getFullYear() * 12 + lastDate.getMonth();
                const currentMonthYear = new Date().getFullYear() * 12 + new Date().getMonth();
                if (Math.abs(currentMonthYear - lastMonthYear) <= 1) {
                    allViolations.push({ message: `${pairNames} trabalharam juntos no mês passado ou neste mês.`, type: 'error' });
                    selectedPeople.forEach(p => p.element.classList.add('invalid-selection'));
                } else if (history.lastRoles === currentRolesKey) {
                    const hasRedErrorAlready = selectedPeople.some(p => p.element.classList.contains('invalid-selection'));
                    if (!hasRedErrorAlready) {
                         allViolations.push({ message: `Aviso: ${pairNames} já fizeram esta parte com os mesmos papéis.`, type: 'warning' });
                        selectedPeople.forEach(p => p.element.classList.add('warning-selection'));
                    }
                }
            }
        }
    });

    // --- ATUALIZAR A UI ---
    if (allViolations.length > 0) {
        const hasErrors = allViolations.some(v => v.type === 'error');
        alertIcon.classList.remove('warning-only');
        if (!hasErrors) {
            alertIcon.classList.add('warning-only');
        }

        const uniqueViolations = Array.from(new Set(allViolations.map(v => v.message)))
                                     .map(message => allViolations.find(v => v.message === message));
        
        // ==========================================================
        // ============== INÍCIO DA MODIFICAÇÃO AQUI ================
        // ==========================================================
        uniqueViolations.forEach(violation => {
            const li = document.createElement('li');
            li.textContent = violation.message;
            
            // Adiciona a classe correta com base no tipo de violação
            if (violation.type === 'warning') {
                li.classList.add('warning-item');
            } else if (violation.type === 'error') {
                li.classList.add('error-item');
            }
            
            validationList.appendChild(li);
        });
        // ==========================================================
        // ================ FIM DA MODIFICAÇÃO AQUI =================
        // ==========================================================

        alertContainer.style.display = 'block';
    } else {
        alertContainer.style.display = 'none';
        document.getElementById('validation-panel').classList.remove('active');
    }
};



// Helper para obter a data da reunião (pode precisar de uma versão melhorada)
function getMeetingDayOfMonth(diasSemanaString, diaSemanaReuniao) {
    if (!diasSemanaString || !diaSemanaReuniao) return new Date(); // Fallback
    const [startDay] = diasSemanaString.split(' ')[0].split('-');
    return new Date(new Date().getFullYear(), new Date().getMonth(), parseInt(startDay));
}














// --- Event Listeners ---

// Usar delegação de eventos para ouvir alterações em qualquer dropdown de participante
document.body.addEventListener('change', (event) => {
    if (event.target.classList.contains('form-select')) {
        validateAllSelections();
    }
});

// Adicionar um ouvinte para o botão de foguete para validar após o preenchimento automático
document.getElementById('turboButton').addEventListener('click', () => {
    // Adiciona um pequeno atraso para garantir que os valores do select foram atualizados antes da validação
    setTimeout(validateAllSelections, 500); 
});


// Lógica para mostrar/esconder o painel de validação
const validationIcon = document.getElementById('validation-alert-icon');
const validationPanel = document.getElementById('validation-panel');
const validationPanelClose = document.getElementById('validation-panel-close');

validationIcon.addEventListener('click', () => {
    validationPanel.classList.toggle('active');
});

validationPanelClose.addEventListener('click', () => {
    validationPanel.classList.remove('active');
});

// Fechar o painel se clicar fora dele
document.addEventListener('click', (event) => {
    if (!validationPanel.contains(event.target) && !validationIcon.contains(event.target)) {
        validationPanel.classList.remove('active');
    }
});

            
           // --- INÍCIO: NOVA LÓGICA DO POPUP DE ESTATÍSTICAS COM ABAS ---

const estatisticasButton = document.getElementById('estatisticasButton');
const estatisticasPopup = document.getElementById('estatisticasPopup');
const closeEstatisticasPopup = document.getElementById('closeEstatisticasPopup');


let allYearsCache = []; // Cache para os anos, para não buscar no DB toda hora
let allLanguagesCache = []; // Cache para evitar buscas repetidas ao DB

// Função auxiliar para popular dropdowns de ano
const populateYearFilter = async (selectElement) => {
    if (allYearsCache.length === 0) {
        try {
            const historicoSnapshot = await db.collection('historico').get();
            const years = new Set();
            historicoSnapshot.forEach(doc => {
                if (doc.data().ano) {
                    years.add(doc.data().ano);
                }
            });
            allYearsCache = Array.from(years).sort((a, b) => b - a);
        } catch (error) {
            console.error("Erro ao popular filtro de anos:", error);
            return;
        }
    }

    const currentYear = new Date().getFullYear();
    selectElement.innerHTML = '';
    allYearsCache.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (parseInt(year) === currentYear) {
            option.selected = true;
        }
        selectElement.appendChild(option);
    });
};

// Função auxiliar para popular dropdowns de idioma
const populateLanguageFilter = async (selectElement) => {
    if (allLanguagesCache.length === 0) {
        try {
            const nacionalidadesSnapshot = await db.collection('nacionalidades').orderBy('nome').get();
            nacionalidadesSnapshot.forEach(doc => {
                allLanguagesCache.push(doc.data().nome);
            });
        } catch (error) {
            console.error("Erro ao popular filtro de idiomas:", error);
            return;
        }
    }

    const firstOption = selectElement.options[0];
    selectElement.innerHTML = '';
    if (firstOption) {
       selectElement.appendChild(firstOption);
    }

    allLanguagesCache.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang;
        option.textContent = lang;
        selectElement.appendChild(option);
    });
};


// --- Lógica Principal de Abertura do Popup e Gestão de Abas ---
estatisticasButton.addEventListener('click', async () => {
    estatisticasPopup.style.display = 'flex';
    document.body.classList.add('popup-open');

    // Ativa a primeira aba por defeito e carrega seu conteúdo
    if (!document.querySelector('.tab-button.active')) {
        document.querySelector('.tab-button[data-tab="geral"]').classList.add('active');
        document.querySelector('#tab-content-geral').classList.add('active');
    }

    const activeTab = document.querySelector('.tab-button.active').dataset.tab;
    loadTabData(activeTab); // Carrega os dados da aba ativa

    // Configura o listener para trocar de aba
    setupTabListeners();
});

const setupTabListeners = () => {
    const tabs = document.querySelectorAll('.tab-button');
    tabs.forEach(tab => {
        // Remove event listener antigo para evitar duplicação
        tab.replaceWith(tab.cloneNode(true));
    });

    // Adiciona o novo listener
    document.querySelectorAll('.tab-button').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const tabName = e.target.dataset.tab;
            
            document.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            e.target.classList.add('active');
            document.getElementById(`tab-content-${tabName}`).classList.add('active');

            loadTabData(tabName);
        });
    });
};

const loadTabData = (tabName) => {
    const contentArea = document.getElementById(`tab-content-${tabName}`);
    // Se a aba já foi carregada, não faz nada
    if (contentArea.dataset.loaded === 'true' && tabName !== 'geral') {
        return;
    }

   if (tabName !== 'geral') {
        contentArea.innerHTML = `<div style="text-align: center; padding: 40px; font-size: 18px;"><i class="fas fa-spinner fa-spin"></i> A carregar dados...</div>`;
    }

    switch (tabName) {
        case 'geral':
            loadGeralTab();
            break;
        case 'maisMenos':
            loadMaisMenosTab();
            break;
        case 'menosDetalhado':
            loadMenosDetalhadoTab();
            break;
        case 'nunca':
            loadNuncaTab();
            break;
        case 'dirigentes':
            loadDirigentesTab();
            break;
    }
    contentArea.dataset.loaded = 'true';
};

closeEstatisticasPopup.addEventListener('click', () => {
    estatisticasPopup.style.display = 'none';
    document.body.classList.remove('popup-open');
});


function makeTableSortable(table) {
    const header = table.querySelector('thead');
    if (!header) return;

    const headers = header.querySelectorAll('th');

    headers.forEach(th => {
        // Aplica o estilo de cursor para indicar que é clicável
        th.style.cursor = 'pointer';

        th.addEventListener('click', () => {
            if (th.classList.contains('no-sort')) return;

            const columnIndex = Array.from(headers).indexOf(th);
            const currentDirection = th.dataset.sortDirection || 'desc';
            const newDirection = currentDirection === 'asc' ? 'desc' : 'asc';

            // Limpa a direção de ordenação de todos os outros cabeçalhos
            headers.forEach(h => {
                if (h !== th) {
                    delete h.dataset.sortDirection;
                }
            });

            // Define a nova direção para o cabeçalho clicado
            th.dataset.sortDirection = newDirection;

            // Lógica de ordenação (esta parte é a mesma da versão anterior)
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            const isNumericColumn = !isNaN(parseFloat(rows[0]?.cells[columnIndex]?.textContent));

            rows.sort((a, b) => {
                const aText = a.cells[columnIndex].textContent.trim();
                const bText = b.cells[columnIndex].textContent.trim();

                if (isNumericColumn) {
                    const aNum = parseFloat(aText) || 0;
                    const bNum = parseFloat(bText) || 0;
                    return newDirection === 'asc' ? aNum - bNum : bNum - aNum;
                } else {
                    return newDirection === 'asc'
                        ? aText.localeCompare(bText, undefined, { numeric: true })
                        : bText.localeCompare(aText, undefined, { numeric: true });
                }
            });

            // Remonta o corpo da tabela com as linhas ordenadas
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        });
    });
}


// --- Funções de Carregamento para cada Aba ---

// Aba 1: GERAL (Funcionalidade antiga)
const loadGeralTab = async () => {
    const contentArea = document.getElementById('tab-content-geral');
    
    const populateDesignationFilter = async () => {
        // ... (código interno desta função não muda) ...
        console.log("--- populateDesignationFilter INICIADA ---");
        const filtroDesignacao = document.getElementById('filtroDesignacaoGeral');
        const parteSelecionada = document.getElementById('filtroParte').value;
        filtroDesignacao.innerHTML = '<option value="">Todas as Designações</option>';
        try {
            let query = db.collection('designacoes').where('tipo', '==', 'reuniao').where('quando', '==', 'Semana');
            if (parteSelecionada) {
                query = query.where('parte', '==', parteSelecionada);
            }
            const designacoesSnapshot = await query.orderBy('ordem').get();
            designacoesSnapshot.forEach(doc => {
                const desig = doc.data();
                const option = document.createElement('option');
                option.value = doc.id;
                option.textContent = desig.nome;
                filtroDesignacao.appendChild(option);
            });
            console.log("--- populateDesignationFilter FINALIZADA ---");
        } catch (error) {
            console.error("Erro ao popular filtro de designações dinâmico:", error);
        }
    };





    
    // *** INÍCIO DA NOVA LÓGICA: Popula o filtro de designação ***
    const filtroDesignacao = document.getElementById('filtroDesignacaoGeral');
if (filtroDesignacao.options.length <= 1) {
        try {
            const designacoesSnapshot = await db.collection('designacoes').where('quando', '==', 'Semana').orderBy('nome').get();
            designacoesSnapshot.forEach(doc => {
                const desig = doc.data();
                const option = document.createElement('option');
                option.value = doc.id; // O valor é o ID do documento
                option.textContent = desig.nome;
                filtroDesignacao.appendChild(option);
            });
        } catch (error) {
            console.error("Erro ao popular filtro de designações:", error);
        }
    }
    // *** FIM DA NOVA LÓGICA ***

    // Adiciona os listeners se ainda não existirem
  if(!contentArea.dataset.listenersAdded) {
        
        // Popula o filtro de ano
        const filtroAnoSelect = document.getElementById('filtroAno');
        await populateYearFilter(filtroAnoSelect);
        
        // <<< INÍCIO DA NOVA CORREÇÃO >>>
        // Popula o filtro de idioma
        const filtroIdiomaSelect = document.getElementById('filtroIdioma');
        await populateLanguageFilter(filtroIdiomaSelect);
        // <<< FIM DA NOVA CORREÇÃO >>>

        // Adiciona os listeners aos filtros
        document.getElementById('filtroParte').addEventListener('change', async () => {
            await populateDesignationFilter();
            generateStatisticsTable();
        });


         const otherFilters = ['filtroAno', 'filtroMes', 'filtroGenero', 'filtroIdioma', 'filtroDesignacaoGeral'];
        otherFilters.forEach(id => {
            document.getElementById(id).addEventListener('change', generateStatisticsTable);
        });
        
        contentArea.dataset.listenersAdded = 'true';
    }

    // --- EXECUÇÃO INICIAL ---
    await populateDesignationFilter();
    generateStatisticsTable();
};




// Aba 2: MAIS/MENOS (CORRIGIDA)
const loadMaisMenosTab = async () => {
    const contentArea = document.getElementById('tab-content-maisMenos');
    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group">
                <label for="maisMenosFiltroAno">Ano:</label>
                <select id="maisMenosFiltroAno"></select>
            </div>
        </div>
        <div id="maisMenosContent">A carregar...</div>
    `;

    const yearSelect = document.getElementById('maisMenosFiltroAno');
    await populateYearFilter(yearSelect);

    const renderMaisMenos = async () => {
        const ano = yearSelect.value;
        const contentDiv = document.getElementById('maisMenosContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados para ${ano}...</div>`;
        
        const historicoSnapshot = await db.collection('historico')
            .where('ano', '==', parseInt(ano))
            .where('quando', '==', 'Semana')
            .get();

        const participationCounts = new Map();
        const lastParticipation = new Map();

        historicoSnapshot.forEach(doc => {
            const data = doc.data();
            data.designacoes?.forEach(desig => {
                const participants = Object.values(desig.participantes || {});
                participants.forEach(pId => {
                    // Contagem de participações
                    const currentCount = participationCounts.get(pId) || 0;
                    participationCounts.set(pId, currentCount + 1);

                    // Última participação
                    const lastDate = lastParticipation.get(pId) || '1970-01-01';
                    if (data.dia && new Date(data.dia) > new Date(lastDate)) {
                        lastParticipation.set(pId, data.dia);
                    }
                });
            });
        });

        const sortedByCount = [...participationCounts.entries()].sort((a, b) => b[1] - a[1]);
        const sortedByDate = [...lastParticipation.entries()].sort((a, b) => new Date(a[1]) - new Date(b[1]));

        const maisDesignacoes = sortedByCount.slice(0, 7);
        const menosDesignacoes = sortedByCount.slice(-7).reverse();
        const maisTempoSem = sortedByDate.slice(0, 7);
        
        // --- INÍCIO DA CORREÇÃO ---
        // Acedemos a .nome para obter o nome da pessoa do objeto guardado no map.
        const getPersonName = (id) => (allPeopleDataMap.get(id) || {}).nome || 'Desconhecido';
        // --- FIM DA CORREÇÃO ---

        contentDiv.innerHTML = `
            <div class="mais-menos-container">
                <div class="rank-column col-mais">
                    <h4><i class="fas fa-arrow-up"></i> Mais Designações</h4>
                    <ol>${maisDesignacoes.map(([id, count]) => `<li>${getPersonName(id)} <strong>(${count})</strong></li>`).join('')}</ol>
                </div>
                <div class="rank-column col-menos">
                    <h4><i class="fas fa-arrow-down"></i> Menos Designações</h4>
                    <ol>${menosDesignacoes.map(([id, count]) => `<li>${getPersonName(id)} <strong>(${count})</strong></li>`).join('')}</ol>
                </div>
                <div class="rank-column col-antiga">
                    <h4><i class="far fa-clock"></i> Há Mais Tempo Sem Fazer</h4>
                    <ol>${maisTempoSem.map(([id, date]) => `<li>${getPersonName(id)} <small>(${new Date(date).toLocaleDateString()})</small></li>`).join('')}</ol>
                </div>
            </div>
        `;
    };

    yearSelect.addEventListener('change', renderMaisMenos);
    renderMaisMenos();
};

// Aba 3: MENOS (DETALHADO)
const loadMenosDetalhadoTab = async () => {
    const contentArea = document.getElementById('tab-content-menosDetalhado');
    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group">
                <label for="detalhadoFiltroAno">Ano:</label>
                <select id="detalhadoFiltroAno"></select>
            </div>
        </div>
        <div id="detalhadoContent" style="overflow-x: auto;">A carregar...</div>
    `;

    const yearSelect = document.getElementById('detalhadoFiltroAno');
    await populateYearFilter(yearSelect);

    const renderDetalhado = async () => {
        const ano = yearSelect.value;
        const contentDiv = document.getElementById('detalhadoContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados para ${ano}...</div>`;

        try {
            const [pessoasSnapshot, designacoesSnapshot, historicoSnapshot] = await Promise.all([
                db.collection('pessoas').where('fazDesignacoesReuniao', '==', true).get(),
                db.collection('designacoes').where('quando', '==', 'Semana').where('status', '==', true).get(),
                db.collection('historico').where('ano', '==', parseInt(ano)).where('quando', '==', 'Semana').get()
            ]);
            
            const designations = [];
            designacoesSnapshot.forEach(doc => {
                const data = doc.data();
                // MODIFICAÇÃO 1: Adicionado o campo 'ordem' ao objeto
                designations.push({id: doc.id, nome: data.nome, ordem: data.ordem});
            });

            // MODIFICAÇÃO 2: Alterada a ordenação para usar o campo 'ordem' em vez do nome
            designations.sort((a,b) => a.ordem - b.ordem);

            const counts = new Map();
            const totalCounts = new Map();

            pessoasSnapshot.forEach(personDoc => {
                const personId = personDoc.id;
                const innerMap = new Map();
                designations.forEach(d => innerMap.set(d.id, 0));
                counts.set(personId, innerMap);
                totalCounts.set(personId, 0);
            });

            historicoSnapshot.forEach(doc => {
                doc.data().designacoes?.forEach(desig => {
                    const participants = Object.values(desig.participantes || {});
                    participants.forEach(pId => {
                        if (counts.has(pId)) {
                            const personCounts = counts.get(pId);
                            if (personCounts.has(desig.designacaoId)) {
                                const currentCount = personCounts.get(desig.designacaoId);
                                personCounts.set(desig.designacaoId, currentCount + 1);
                            }
                        }
                    });
                });
            });
            
            for (const [pId, innerMap] of counts.entries()) {
                let total = 0;
                for (const count of innerMap.values()) {
                    total += count;
                }
                totalCounts.set(pId, total);
            }

            const rankedPeopleIds = [...totalCounts.entries()]
                .sort((a, b) => a[1] - b[1])
                .slice(0, 10)
                .map(entry => entry[0]);

            let tableHTML = `<table class="estatisticas-table"><thead><tr><th>Participante</th>`;
            designations.forEach(d => tableHTML += `<th>${d.nome}</th>`);
            tableHTML += `</tr></thead><tbody>`;

            rankedPeopleIds.forEach(pId => {
                 const personName = (allPeopleDataMap.get(pId) || {}).nome || 'Desconhecido';
                 tableHTML += `<tr><td>${personName}</td>`;
                 const personCounts = counts.get(pId);
                 designations.forEach(d => {
                    tableHTML += `<td>${personCounts.get(d.id) || 0}</td>`;
                 });
                 tableHTML += `</tr>`;
            });

            tableHTML += `</tbody></table>`;
            contentDiv.innerHTML = tableHTML;

            const detalhadoTable = contentDiv.querySelector('.estatisticas-table');
            if (detalhadoTable) {
                makeTableSortable(detalhadoTable);
            }

        } catch (error) {
            console.error("Erro ao carregar aba 'Menos (detalhado)':", error);
            contentDiv.innerHTML = `<div style="color: red; text-align: center; padding: 20px;">Ocorreu um erro ao processar os dados. Tente novamente.</div>`;
        }
    };

    yearSelect.addEventListener('change', renderDetalhado);
    renderDetalhado();
};



// Aba 4: NUNCA
const loadNuncaTab = async () => {
    const contentArea = document.getElementById('tab-content-nunca');

    // 1. Busca as nacionalidades e designações para preencher os filtros (sem alterações aqui)
    const [nacionalidadesSnapshot, designacoesSnapshot] = await Promise.all([
        db.collection('nacionalidades').get(),
        db.collection('designacoes').where('quando', '==', 'Semana').orderBy('nome').get()
    ]);

    let idiomasOptions = '';
    nacionalidadesSnapshot.forEach(doc => {
        idiomasOptions += `<option value="${doc.data().nome}">${doc.data().nome}</option>`;
    });

    let desigOptions = '<option value="">Todas as Designações</option>';
    designacoesSnapshot.forEach(doc => {
        desigOptions += `<option value="${doc.id}">${doc.data().nome}</option>`;
    });

    // 2. Constrói o HTML da aba (sem alterações aqui)
    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group"><label for="nuncaFiltroAno">Ano:</label><select id="nuncaFiltroAno"></select></div>
            <div class="form-group"><label for="nuncaFiltroMes">Mês:</label><select id="nuncaFiltroMes">
                <option value="1">Janeiro</option><option value="2">Fevereiro</option><option value="3">Março</option><option value="4">Abril</option><option value="5">Maio</option><option value="6">Junho</option><option value="7">Julho</option><option value="8">Agosto</option><option value="9">Setembro</option><option value="10">Outubro</option><option value="11">Novembro</option><option value="12">Dezembro</option>
            </select></div>
            <div class="form-group"><label for="nuncaFiltroGenero">Género:</label><select id="nuncaFiltroGenero">
                <option value="">Todos</option><option value="Masculino">Masculino</option><option value="Feminino">Feminino</option>
            </select></div>
            <div class="form-group"><label for="nuncaFiltroIdioma">Idioma:</label><select id="nuncaFiltroIdioma">
                <option value="">Todos</option>${idiomasOptions}
            </select></div>
            <div class="form-group"><label for="nuncaFiltroDesignacao">Designação:</label><select id="nuncaFiltroDesignacao">
                ${desigOptions}
            </select></div>
        </div>
        <div id="nuncaContent" style="padding-top: 15px;">A carregar...</div>
    `;

    // 3. Prepara os filtros e a função de renderização
    const yearSelect = document.getElementById('nuncaFiltroAno');
    await populateYearFilter(yearSelect);
    document.getElementById('nuncaFiltroMes').value = new Date().getMonth() + 1;

    // ==========================================================
    // =========== INÍCIO DA LÓGICA PRINCIPAL ALTERADA ==========
    // ==========================================================
    const renderNunca = async () => {
        const ano = parseInt(document.getElementById('nuncaFiltroAno').value);
        const mes = parseInt(document.getElementById('nuncaFiltroMes').value);
        const genero = document.getElementById('nuncaFiltroGenero').value;
        const idioma = document.getElementById('nuncaFiltroIdioma').value;
        const contentDiv = document.getElementById('nuncaContent');

        // ** ALTERAÇÃO 1: Obter o NOME da designação, não apenas o ID **
        // O campo 'designacoesReuniao' guarda o nome (texto), por isso precisamos dele para a consulta.
        const designacaoSelect = document.getElementById('nuncaFiltroDesignacao');
        const designacaoId = designacaoSelect.value;
        const designacaoNome = designacaoId ? designacaoSelect.options[designacaoSelect.selectedIndex].text : null;

        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados...</div>`;

        // ** ALTERAÇÃO 2: Construir a consulta de pessoas com a nova condição **
        let pessoasQuery = db.collection('pessoas').where('fazDesignacoesReuniao', '==', true);
        if (genero) pessoasQuery = pessoasQuery.where('genero', '==', genero);
        if (idioma) pessoasQuery = pessoasQuery.where('idioma', '==', idioma);

        // A MÁGICA ACONTECE AQUI:
        // Se um nome de designação foi selecionado, adiciona o filtro "array-contains".
        if (designacaoNome) {
            pessoasQuery = pessoasQuery.where('designacoesReuniao', 'array-contains', designacaoNome);
        }
        
        const [pessoasSnapshot, historicoSnapshot] = await Promise.all([
            pessoasQuery.get(),
            db.collection('historico').where('ano', '==', ano).where('mes', '==', mes).where('quando', '==', 'Semana').get()
        ]);

        // O resto da lógica permanece quase igual, mas agora 'allEligiblePeople'
        // já está pré-filtrado para conter apenas pessoas habilitadas para a designação.
        const allEligiblePeople = new Map();
        pessoasSnapshot.forEach(doc => allEligiblePeople.set(doc.id, doc.data().nomePessoa));

        const participantsThisMonth = new Set();
        historicoSnapshot.forEach(doc => {
            doc.data().designacoes?.forEach(d => {
                if (designacaoId && d.designacaoId !== designacaoId) {
                    return; 
                }
                Object.values(d.participantes || {}).forEach(pId => participantsThisMonth.add(pId));
            });
        });

        const nonParticipants = [];
        for(const [id, name] of allEligiblePeople.entries()){
            if(!participantsThisMonth.has(id)){
                nonParticipants.push(name);
            }
        }
        
        nonParticipants.sort();
        const selectedDesignacaoName = designacaoNome || 'em qualquer designação';

        contentDiv.innerHTML = `<h4>Pessoas que não participaram (${selectedDesignacaoName})</h4>
        <p>${nonParticipants.length} pessoa(s) encontrada(s).</p>
        <ul style="columns: 3; -webkit-columns: 3; -moz-columns: 3;">${nonParticipants.map(name => `<li>${name}</li>`).join('')}</ul>`;
    };
    // ==========================================================
    // ============ FIM DA LÓGICA PRINCIPAL ALTERADA ============
    // ==========================================================

    ['nuncaFiltroAno', 'nuncaFiltroMes', 'nuncaFiltroGenero', 'nuncaFiltroIdioma', 'nuncaFiltroDesignacao'].forEach(id => {
        document.getElementById(id).addEventListener('change', renderNunca);
    });
    
    renderNunca();
};






// Aba 5: DIRIGENTES
const loadDirigentesTab = async () => {
    const contentArea = document.getElementById('tab-content-dirigentes');
    const designacoesSnapshot = await db.collection('designacoes').where('quando', '==', 'Semana').get();
    let desigOptions = '<option value="">Todas as Designações</option>';
    designacoesSnapshot.forEach(doc => desigOptions += `<option value="${doc.id}">${doc.data().nome}</option>`);

    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group"><label for="dirigentesFiltroAno">Ano:</label><select id="dirigentesFiltroAno"></select></div>
            <div class="form-group"><label for="dirigentesFiltroDesignacao">Designação:</label><select id="dirigentesFiltroDesignacao">${desigOptions}</select></div>
        </div>
        <div id="dirigentesContent" style="overflow-x: auto;">A carregar...</div>
    `;

    const yearSelect = document.getElementById('dirigentesFiltroAno');
    await populateYearFilter(yearSelect);

    const renderDirigentes = async () => {
        const ano = parseInt(yearSelect.value);
        const designacaoId = document.getElementById('dirigentesFiltroDesignacao').value;
        const contentDiv = document.getElementById('dirigentesContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados...</div>`;

        let historicoQuery = db.collection('historico').where('ano', '==', ano).where('quando', '==', 'Semana');
        const [pessoasSnapshot, historicoSnapshot] = await Promise.all([
            db.collection('pessoas').where('fazDesignacoesReuniao', '==', true).orderBy('nomePessoa').get(),
            historicoQuery.get()
        ]);
        
        const peopleList = [];
        pessoasSnapshot.forEach(doc => peopleList.push({ id: doc.id, name: doc.data().nomePessoa }));

        const roleCounts = new Map(); // personId -> { dirigente: count, morador: count, ajudante: count }
        
        historicoSnapshot.forEach(doc => {
            doc.data().designacoes?.forEach(d => {
                if (designacaoId && d.designacaoId !== designacaoId) return; // Filtra por designação se selecionada
                
                for (const [role, pId] of Object.entries(d.participantes || {})) {
                    if (!roleCounts.has(pId)) roleCounts.set(pId, { dirigente: 0, morador: 0, ajudante: 0 });
                    const personCounts = roleCounts.get(pId);
                    if (personCounts[role] !== undefined) {
                        personCounts[role]++;
                    }
                }
            });
        });

        let tableHTML = `<table class="estatisticas-table">
            <thead><tr><th>Participante</th><th>Dirigente</th><th>Morador</th><th>Ajudante</th></tr></thead><tbody>`;
        
        peopleList.forEach(person => {
            const counts = roleCounts.get(person.id) || { dirigente: 0, morador: 0, ajudante: 0 };
            const dirigenteCount = counts.dirigente || 0;
            const moradorCount = counts.morador || 0;
            const ajudanteCount = counts.ajudante || 0;

            const dirigenteClass = dirigenteCount === 0 ? 'class="low-participation"' : '';

            tableHTML += `<tr>
                <td>${person.name}</td>
                <td ${dirigenteClass}>${dirigenteCount}</td>
                <td>${moradorCount}</td>
                <td>${ajudanteCount}</td>
            </tr>`;
        });

        tableHTML += `</tbody></table>`;
        contentDiv.innerHTML = tableHTML;
    };
    
const dirigentesTable = contentDiv.querySelector('.estatisticas-table');
        if (dirigentesTable) {
            makeTableSortable(dirigentesTable);
        }

    ['dirigentesFiltroAno', 'dirigentesFiltroDesignacao'].forEach(id => {
        document.getElementById(id).addEventListener('change', renderDirigentes);
    });
    renderDirigentes();
};

// --- Função original da Aba "Geral" (necessária para a primeira aba) ---
const generateStatisticsTable = async () => {
    const loadingDiv = document.getElementById('estatisticasLoading');
    const tableContainer = document.getElementById('estatisticasTableContainer');
    loadingDiv.style.display = 'block';
    tableContainer.style.display = 'none';

    // Lê os valores de TODOS os filtros no momento da execução
    const anoSelecionado = document.getElementById('filtroAno').value ? parseInt(document.getElementById('filtroAno').value) : null;
    const mesSelecionado = document.getElementById('filtroMes').value ? parseInt(document.getElementById('filtroMes').value) : null;
    const generoSelecionado = document.getElementById('filtroGenero').value;
    const idiomaSelecionado = document.getElementById('filtroIdioma').value;
    const parteSelecionada = document.getElementById('filtroParte').value;
    const designacaoSelecionada = document.getElementById('filtroDesignacaoGeral').value;

    try {
        let historicoQuery = db.collection('historico');
        if (anoSelecionado) historicoQuery = historicoQuery.where('ano', '==', anoSelecionado);
        if (mesSelecionado) historicoQuery = historicoQuery.where('mes', '==', mesSelecionado);
        
        let pessoasQuery = db.collection('pessoas').where('fazDesignacoesReuniao', '==', true);
        if (generoSelecionado) pessoasQuery = pessoasQuery.where('genero', '==', generoSelecionado);
        if (idiomaSelecionado) pessoasQuery = pessoasQuery.where('idioma', '==', idiomaSelecionado);

        let designacoesQuery = db.collection('designacoes').where('quando', '==', 'Semana');
        if (parteSelecionada) designacoesQuery = designacoesQuery.where('parte', '==', parteSelecionada);

        const [pessoasSnapshot, designacoesSnapshot, historicoSnapshot] = await Promise.all([
            pessoasQuery.get(),
            designacoesQuery.get(),
            historicoQuery.get()
        ]);
        
        let designationsInOrder = [];
        designacoesSnapshot.forEach(doc => {
            const data = doc.data();
            designationsInOrder.push({ id: doc.id, name: data.nome, ordem: data.ordem });
        });
        
        designationsInOrder.sort((a, b) => a.ordem - b.ordem);

        if (designacaoSelecionada) {
            designationsInOrder = designationsInOrder.filter(desig => desig.id === designacaoSelecionada);
        }

        const peopleMap = new Map();
        pessoasSnapshot.forEach(doc => {
            const pessoa = doc.data();
            const personCounts = new Map();
            designationsInOrder.forEach(desig => personCounts.set(desig.id, 0));
            peopleMap.set(doc.id, { name: pessoa.nomePessoa, counts: personCounts });
        });

        historicoSnapshot.forEach(doc => {
            const historico = doc.data();
            historico.designacoes?.forEach(histDesig => {
                const participants = Object.values(histDesig.participantes || {});
                participants.forEach(participanteId => {
                    if (peopleMap.has(participanteId) && peopleMap.get(participanteId).counts.has(histDesig.designacaoId)) {
                        const personData = peopleMap.get(participanteId);
                        const currentCount = personData.counts.get(histDesig.designacaoId);
                        personData.counts.set(histDesig.designacaoId, currentCount + 1);
                    }
                });
            });
        });

        let tableHTML = '<table class="estatisticas-table"><thead><tr><th>Participante</th>';
        designationsInOrder.forEach(desig => { tableHTML += `<th>${desig.name}</th>`; });
        tableHTML += '</tr></thead><tbody>';

        const sortedPeople = [...peopleMap.entries()].sort((a, b) => a[1].name.localeCompare(b[1].name));

        for (const [personId, personData] of sortedPeople) {
            tableHTML += `<tr><td>${personData.name}</td>`;
            designationsInOrder.forEach(desig => {
                tableHTML += `<td>${personData.counts.get(desig.id)}</td>`;
            });
            tableHTML += '</tr>';
        }
        tableHTML += '</tbody></table>';

        loadingDiv.style.display = 'none';
        tableContainer.innerHTML = tableHTML;
        tableContainer.style.display = 'block';

const geralTable = tableContainer.querySelector('.estatisticas-table');
        if (geralTable) {
            makeTableSortable(geralTable);
        }

    } catch (error) {
        console.error("Erro ao gerar estatísticas:", error);
        loadingDiv.innerHTML = "Ocorreu um erro ao carregar as estatísticas.";
        tableContainer.style.display = 'none';
    }
};

// --- FIM: NOVA LÓGICA DO POPUP DE ESTATÍSTICAS COM ABAS ---


// ======================================================================== //
// ============ INÍCIO: LÓGICA DO POPUP DE PERFIL DE PARTICIPANTE ========== //
// ======================================================================== //

// --- Elementos da DOM ---
const perfilButton = document.getElementById('perfilButton');
const perfilPopup = document.getElementById('perfilPopup');
const closePerfilPopup = document.getElementById('closePerfilPopup');
const pesquisaInput = document.getElementById('pesquisaPessoa');
const sugestoesDiv = document.getElementById('pesquisaSugestoes');
const perfilFiltros = document.getElementById('perfilFiltrosContainer');
const perfilLoading = document.getElementById('perfilLoading');
const perfilTableContainer = document.getElementById('perfilTableContainer');
const perfilTableBody = document.getElementById('perfilTableBody');

// --- Filtros ---
const perfilFiltroAno = document.getElementById('perfilFiltroAno'); // NOME CORRIGIDO
const perfilFiltroMes = document.getElementById('perfilFiltroMes'); // NOME CORRIGIDO
const perfilFiltroDesignacao = document.getElementById('perfilFiltroDesignacao');
const perfilFiltroPapel = document.getElementById('perfilFiltroPapel');

// --- Armazenamento de dados em cache para performance ---
let allPeople = [];
let allDesignationsMap = new Map();
let allPeopleDataMap = new Map();
let currentPersonParticipationRecords = []; // Armazena os registros processados da pessoa selecionada


// --- Função para abrir a popup de perfil ---
perfilButton.addEventListener('click', () => {
    perfilPopup.style.display = 'flex';
    if (allPeople.length === 0) { // Carrega os dados apenas na primeira vez que abre
        initializeProfileData();
    }
});

// --- Função para fechar a popup de perfil ---
closePerfilPopup.addEventListener('click', () => {
    perfilPopup.style.display = 'none';
});

// --- Inicializa os dados necessários (pessoas e designações) ---
const initializeSystemData = async () => {
    try {
        const [pessoasSnapshot, designacoesSnapshot] = await Promise.all([
            db.collection('pessoas').orderBy('nomePessoa').get(),
            db.collection('designacoes').get()
        ]);

        // Limpa e preenche os mapas
        allPeople = [];
        allPeopleDataMap.clear();
        allDesignationsMap.clear();

        pessoasSnapshot.forEach(doc => {
            const pessoaData = doc.data();
            allPeople.push({ id: doc.id, nome: pessoaData.nomePessoa });
            // GUARDA O GÊNERO AQUI
            allPeopleDataMap.set(doc.id, { nome: pessoaData.nomePessoa, genero: pessoaData.genero });
        });

        designacoesSnapshot.forEach(doc => {
            allDesignationsMap.set(doc.id, doc.data().nome);
        });

        console.log("Dados do sistema (Pessoas e Designações) inicializados.");
    } catch (error) {
        console.error("Erro ao inicializar dados do sistema:", error);
    }
};


async function loadAllPeopleMap() {
    try {
        // Busca todas as pessoas que podem participar nas reuniões
        const pessoasSnapshot = await db.collection('pessoas').where('fazDesignacoesReuniao', '==', true).get();
        // Limpa o mapa global e preenche-o com os dados mais recentes
        allPeopleDataMap = new Map();
        pessoasSnapshot.forEach(doc => {
            allPeopleDataMap.set(doc.id, doc.data().nomePessoa);
        });
        console.log("Mapa global de pessoas carregado com sucesso.");
    } catch (error) {
        console.error("Erro ao carregar o mapa global de pessoas:", error);
    }
}

// --- Lógica da caixa de pesquisa com sugestões ---
pesquisaInput.addEventListener('input', () => {
    const query = pesquisaInput.value.toLowerCase();
    sugestoesDiv.innerHTML = '';

    if (query.length === 0) {
        sugestoesDiv.style.display = 'none';
        return;
    }

    const filteredPeople = allPeople.filter(p => p.nome.toLowerCase().includes(query));

    filteredPeople.forEach(person => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.textContent = person.nome;
        item.addEventListener('click', () => {
            pesquisaInput.value = person.nome;
            sugestoesDiv.style.display = 'none';
            // Inicia a busca no histórico para a pessoa selecionada
            loadParticipantProfile(person.id);
        });
        sugestoesDiv.appendChild(item);
    });

    sugestoesDiv.style.display = filteredPeople.length > 0 ? 'block' : 'none';
});

// Função principal para carregar o histórico de um participante (CORRIGIDA)
const loadParticipantProfile = async (personId) => {
    perfilLoading.style.display = 'block';
    perfilTableContainer.style.display = 'none';
    perfilFiltros.style.display = 'none';
    perfilTableBody.innerHTML = '';
    currentPersonParticipationRecords = []; // Limpa registros anteriores

    try {
        // Obtenção dos dados do histórico (sem alterações aqui)
        const historicoSnapshot = await db.collection('historico').orderBy("dia", "desc").get();
        let records = [];
        let years = new Set();
        let designacoesDaPessoa = new Set();

        historicoSnapshot.forEach(doc => {
            const historico = doc.data();
            
            if (historico.designacoes && Array.isArray(historico.designacoes)) {
                historico.designacoes.forEach(designacaoHist => {
                    const participantes = designacaoHist.participantes;
                    let meuPapel = '';
                    let todosOsIDs = [];

                    if (participantes && typeof participantes === 'object') {
                        todosOsIDs = Object.values(participantes);
                        for (const [papel, id] of Object.entries(participantes)) {
                            if (id === personId) {
                                meuPapel = papel;
                                break;
                            }
                        }
                    }

                    if (meuPapel) {
                        years.add(historico.ano); // Coleta todos os anos para o filtro

                        const designacaoNome = allDesignationsMap.get(designacaoHist.designacaoId) || 'Designação Desconhecida';
                        designacoesDaPessoa.add(designacaoNome);

                        // --- INÍCIO DA CORREÇÃO ---
                        const companheirosIDs = todosOsIDs.filter(id => id !== personId);
                        // A linha abaixo foi corrigida para aceder à propriedade .nome
                        const companheirosNomes = companheirosIDs
                            .map(id => (allPeopleDataMap.get(id) || {}).nome || 'N/A')
                            .join(', ');
                        // --- FIM DA CORREÇÃO ---

                        records.push({
                            ano: historico.ano,
                            dia: historico.dia,
                            designacaoNome: designacaoNome,
                            companheiros: companheirosNomes,
                            meuPapel: meuPapel.charAt(0).toUpperCase() + meuPapel.slice(1)
                        });
                    }
                });
            }
        });

        currentPersonParticipationRecords = records; // Não é preciso ordenar aqui, já vem do Firestore

        // Popula os filtros (sem alterações aqui)
        perfilFiltroAno.innerHTML = '<option value="">Todos</option>';
        Array.from(years).sort((a, b) => b - a).forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            perfilFiltroAno.appendChild(option);
        });

        perfilFiltroDesignacao.innerHTML = '<option value="">Todas</option>';
        Array.from(designacoesDaPessoa).sort().forEach(nome => {
            const option = document.createElement('option');
            option.value = nome;
            option.textContent = nome;
            perfilFiltroDesignacao.appendChild(option);
        });

        // Exibe os filtros e a tabela (sem alterações aqui)
        perfilLoading.style.display = 'none';
        perfilFiltros.style.display = 'flex';
        perfilTableContainer.style.display = 'block';
        renderProfileTable();

    } catch (error) {
        console.error("Erro ao carregar perfil do participante:", error);
        perfilLoading.innerHTML = 'Ocorreu um erro ao carregar o histórico.';
    }
};





// --- Função para renderizar/filtrar a tabela ---
const renderProfileTable = () => {
    // Log 1: Confirma que a função foi chamada
    console.log("--- renderProfileTable chamada ---");

    perfilTableBody.innerHTML = '';

    const ano = perfilFiltroAno.value;
    const mes = perfilFiltroMes.value;
    const designacao = perfilFiltroDesignacao.value;
    const papel = perfilFiltroPapel.value;

    // Log 2: Mostra os valores dos filtros que estão a ser usados
    console.log("Filtros Atuais:", { ano, mes, designacao, papel });

    const filteredRecords = currentPersonParticipationRecords.filter(rec => {
        const recDate = new Date(rec.dia);
        const recMonth = recDate.getMonth() + 1;
        let keepRecord = true; // Começamos por assumir que o registo deve ser mantido

        if (ano && rec.ano.toString() !== ano) {
            keepRecord = false;
        }
        if (mes && recMonth.toString() !== mes) {
            keepRecord = false;
        }
        if (papel && rec.meuPapel.toLowerCase() !== papel) {
            keepRecord = false;
        }

        // --- Lógica de Depuração para a Designação ---
        if (designacao) { // Apenas se um filtro de designação estiver ativo
            const recordDesignacao = rec.designacaoNome;
            const filtroDesignacao = designacao;
            
            // Log 3: Compara os valores exatos para cada linha da tabela
            console.log(`Comparando: [${recordDesignacao}] com filtro [${filtroDesignacao}] | Iguais? ${recordDesignacao === filtroDesignacao}`);
            
            if (recordDesignacao !== filtroDesignacao) {
                keepRecord = false;
            }
        }
        // --- Fim da Lógica de Depuração ---
        
        return keepRecord;
    });
    
    // Log 4: Mostra quantos registos passaram no filtro
    console.log(`Número de registos após o filtro: ${filteredRecords.length}`);

    if (filteredRecords.length === 0) {
        perfilTableBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">Nenhum registro encontrado para os filtros selecionados.</td></tr>';
        return;
    }
    
    filteredRecords.forEach(rec => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${rec.ano}</td>
            <td>${formatDateForDisplay(rec.dia)}</td>
            <td>${rec.designacaoNome}</td>
            <td>${rec.companheiros || 'Nenhum'}</td>
            <td>${rec.meuPapel}</td>
        `;
        perfilTableBody.appendChild(tr);
    });
};

// --- Adiciona listeners para os filtros ---
[perfilFiltroAno, perfilFiltroMes, perfilFiltroDesignacao, perfilFiltroPapel].forEach(filtro => {
    filtro.addEventListener('change', renderProfileTable);
});


// --- Helper para formatar a data ---
const formatDateForDisplay = (dateString) => {
    if (!dateString) return 'Data Inválida';
    const meses = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
    const [ano, mes, dia] = dateString.split('-');
    return `${parseInt(dia)} ${meses[parseInt(mes) - 1]} ${ano}`;
};


// Fecha as sugestões se clicar fora da caixa
document.addEventListener('click', function(event) {
    if (!pesquisaInput.contains(event.target) && !sugestoesDiv.contains(event.target)) {
        sugestoesDiv.style.display = 'none';
    }
});

// ======================================================================== //
// ============== FIM: LÓGICA DO POPUP DE PERFIL DE PARTICIPANTE ========== //
// ======================================================================== //



            
            // Load nacionalidades from Firebase
            const loadNacionalidades = async () => {
                const nacionalidadesRef = db.collection('nacionalidades');
                const snapshot = await nacionalidadesRef.get();
                const nacionalidadesDiv = document.getElementById('nacionalidades');

                nacionalidadesDiv.innerHTML = ''; // Clear existing checkboxes
                snapshot.forEach(doc => {
                    const nacionalidade = doc.data();
                    const label = document.createElement('label');
                    label.className = 'checkbox-item';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.name = 'nacionalidades';
                    input.value = nacionalidade.nome;
                    if (nacionalidade.nome === 'Portugal') {
                        input.checked = true;
                    }
                    label.appendChild(input);
                    label.appendChild(document.createTextNode(nacionalidade.nome));
                    nacionalidadesDiv.appendChild(label);
                });
            };

             // CHAME A NOVA FUNÇÃO AQUI:
    loadAllDesignationsMap();
    loadAllPeopleMap();
    initializeSystemData();

            // Call loadNacionalidades when page loads
            loadNacionalidades();


            const reIndexOrderNumbers = () => {
                const designacaoItems = document.querySelectorAll('#designacoesList .designacao-item');
                let currentOrder = 1;
                let orderedDesignations = [];

                // Collect ordered designations
                designacaoItems.forEach(item => {
                    const orderButton = item.querySelector('.order-button');
                    const order = parseInt(orderButton.dataset.order) || 0;
                    if (order > 0) {
                        orderedDesignations.push({ item: item, order: order });
                    }
                });

                // Sort ordered designations by their current order
                orderedDesignations.sort((a, b) => a.order - b.order);

                // Re-index and update display
                orderedDesignations.forEach(orderedDesignation => {
                    const orderButton = orderedDesignation.item.querySelector('.order-button');
                    orderButton.dataset.order = currentOrder;
                    orderButton.textContent = currentOrder;

                    orderButton.classList.remove('ordered', 'ordered-level-2', 'ordered-level-3', 'ordered-level-4', 'ordered-level-5', 'ordered-level-6', 'ordered-level-7');
                    orderButton.classList.add('ordered');
                    if (currentOrder >= 2) orderButton.classList.add('ordered-level-2');
                    if (currentOrder >= 3) orderButton.classList.add('ordered-level-3');
                    if (currentOrder >= 4) orderButton.classList.add('ordered-level-4');
                    if (currentOrder >= 5) orderButton.classList.add('ordered-level-5');
                    if (currentOrder >= 6) orderButton.classList.add('ordered-level-6');
                    if (currentOrder >= 7) orderButton.classList.add('ordered-level-7');

                    currentOrder++;
                });
            };


            const removeActiveDesignationDisplay = (designacaoId) => {
                const displayToRemove = document.getElementById(`active-designation-${designacaoId}`);
                if (displayToRemove) {
                    displayToRemove.remove();
                }
            };


  const loadPeopleOptionsIntoSelects = async (designacao, container, preferences = {}, diasSemana, diaSemanaReuniaoString, genderPreference = 'masculino feminino') => {
    try {
    const anoFirebase = await getAnoPainelFirebase(); 
        const pessoasRef = db.collection('pessoas');
        const preferenceForDesignation = preferences[designacao.id];

        let query = pessoasRef
            .where('fazDesignacoesReuniao', '==', true)
            .where('designacoesReuniao', 'array-contains', designacao.nome);

        if (genderPreference === 'masculino') {
            query = query.where('genero', '==', 'Masculino');
        } else if (genderPreference === 'feminino') {
            query = query.where('genero', '==', 'Feminino');
        }
        const selectedLanguages = Array.from(document.querySelectorAll('#nacionalidades input[name="nacionalidades"]:checked'))
            .map(checkbox => checkbox.value);

        query.get().then(snapshot => {
            
            // 1. Recolher todas as pessoas elegíveis para uma lista temporária
            const eligiblePeopleList = [];
            snapshot.forEach(doc => {
                const pessoa = doc.data();
                
                // Aplicar regras gerais de elegibilidade aqui
                let isAbsent = false;
                const designationDateFormatted = getMeetingDayOfMonth(anoFirebase, diasSemana, diaSemanaReuniaoString);
                if (designationDateFormatted) {
                    if (pessoa.ausencias && Array.isArray(pessoa.ausencias)) {
                        isAbsent = pessoa.ausencias.includes(designationDateFormatted);
                    }
                }
                const temPrivilegiosNecessarios = designacao.quemFaz.some(
                    privilegio => pessoa.privilegiosCongregacao && pessoa.privilegiosCongregacao.includes(privilegio)
                );
                let languageMatches = true;
                if (selectedLanguages.length > 0) {
                    languageMatches = selectedLanguages.includes(pessoa.idioma);
                }

                if (languageMatches && temPrivilegiosNecessarios && !isAbsent) {
                    eligiblePeopleList.push({ id: doc.id, data: pessoa });
                }
            });

            // 2. Ordenar a lista alfabeticamente pelo nome da pessoa
            eligiblePeopleList.sort((a, b) => a.data.nomePessoa.localeCompare(b.data.nomePessoa));

            // 3. Preencher os dropdowns com a lista já ordenada
            container.querySelectorAll('.designacao-instance-container').forEach((instanceContainer, instanceIndex) => {
                instanceContainer.querySelectorAll('.form-select').forEach((participantSelect, participantIndex) => {
                    participantSelect.innerHTML = '<option value="">Selecione uma pessoa</option>';

                    // Percorrer a lista ordenada
                    eligiblePeopleList.forEach(person => {
                        const pessoaData = person.data;

                        // ===================================================================
                        // =========== INÍCIO DA ALTERAÇÃO APLICADA AQUI =====================
                        // ===================================================================
                        
                        // Aplicar a regra de personalidade específica do papel
                        let podeAssumirEstePapel = false;
                        if (participantIndex === 0) { // Se for o dropdown 'Dirigente'
                            // REGRA ANTIGA: por defeito, só quem tem '+ à vontade' pode ser dirigente
                            if (pessoaData.personalidade === '+ à vontade') {
                                podeAssumirEstePapel = true;
                            }

                            // NOVA REGRA: verifica se a própria designação permite '- à vontade'
                            // Se permitir, as pessoas com essa personalidade também se tornam elegíveis
                            if (
                                Array.isArray(designacao.personalidade) &&
                                designacao.personalidade.includes('- à vontade') &&
                                pessoaData.personalidade === '- à vontade'
                            ) {
                                podeAssumirEstePapel = true;
                            }

                        } else { // Se for 'Morador' ou 'Ajudante'
                            podeAssumirEstePapel = true;
                        }
                        
                        // ===================================================================
                        // ============ FIM DA ALTERAÇÃO APLICADA AQUI =======================
                        // ===================================================================
                        
                        // Adicionar a opção se a regra do papel for cumprida
                        if (podeAssumirEstePapel) {
                            const option = document.createElement('option');
                            option.value = person.id;
                            option.textContent = pessoaData.nomePessoa;
                            participantSelect.appendChild(option);
                        }
                    });
                });
            });

            console.log("[loadPeopleOptionsIntoSelects] END - Designation:", designacao.nome, ", Gender Preference:", genderPreference);
        });

    } catch (error) {
        console.error('Erro ao carregar pessoas elegíveis:', error);
        console.log("[loadPeopleОptionsIntoSelects] ERROR - Designation:", designacao.nome, ", Error:", error, ", Gender Preference:", genderPreference);
    }
};


            const getAnoPainelFirebase = async () => {
                const painelAnoRef = db.collection('painel').doc('ano');
                const doc = await painelAnoRef.get();
                if (doc.exists) {
                    return doc.data().ano;
                } else {
                    return new Date().getFullYear();
                }
            };

            const countHistoricoSemanas = async (ano, mes) => {
                const historicoRef = db.collection('historico');
                const querySnapshot = await historicoRef
                    .where("ano", "==", ano)
                    .where("mes", "==", parseInt(mes))
                    .where("quando", "==", "Semana") // <-- ALTERAÇÃO AQUI
                    .where("parte", "==", "escola")
                    .get();
                return querySnapshot.size;
            };

          const getDiasSemana = (ano, mes, semanaNumero) => { // FUNÇÃO 1 CORRIGIDA
    const primeiroDiaMes = new Date(ano, mes - 1, 1);
    let diaSemanaPrimeiroDia = primeiroDiaMes.getDay();
    if (diaSemanaPrimeiroDia === 0) diaSemanaPrimeiroDia = 7;

    let diasToAddForFirstMonday = 0;
    if (diaSemanaPrimeiroDia !== 1) {
        diasToAddForFirstMonday = (8 - diaSemanaPrimeiroDia) % 7;
    }

    const primeiroSegundaMes = new Date(ano, mes - 1, 1 + diasToAddForFirstMonday);
    const inicioSemanaDate = new Date(ano, mes - 1, primeiroSegundaMes.getDate() + (semanaNumero - 1) * 7);
    const fimSemanaDate = new Date(ano, mes - 1, primeiroSegundaMes.getDate() + (semanaNumero - 1) * 7 + 6);

    const formatarData = (date) => {
        return date.getDate();
    };

    const formatarMes = (date) => {
        // O array de meses mal formatado foi corrigido aqui.
        const monthNames = ["Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
        return monthNames[date.getMonth()];
    };

    const inicio_dia = formatarData(inicioSemanaDate);
    const fim_dia = formatarData(fimSemanaDate);
    const inicio_mes = formatarMes(inicioSemanaDate);
    const fim_mes = formatarMes(fimSemanaDate);

    let diasSemanaString;
    if (inicioSemanaDate.getMonth() !== fimSemanaDate.getMonth()) {
        diasSemanaString = `${inicio_dia} ${inicio_mes} - ${fim_dia} ${fim_mes}`;
    } else {
        diasSemanaString = `${inicio_dia} - ${fim_dia} ${inicio_mes}`;
    }
    return diasSemanaString;
};



            const getTotalSemanasNoMes = async (ano, mes) => {
                let countWeeks = 0;
                let currentDay = new Date(ano, mes - 1, 1);
                const lastDayOfMonth = new Date(ano, mes, 0);

                while (currentDay <= lastDayOfMonth) {
                    if (currentDay.getDay() === 1) {
                        countWeeks++;
                    }
                    currentDay.setDate(currentDay.getDate() + 1);
                }
                return countWeeks;
            };




          const updateWeekDisplay = async () => {
    // Get references to DOM elements once for efficiency
    const weekDisplay = document.getElementById('weekDisplay');
    const nextButton = document.getElementById('btnSeguinte');

    // Get date and week information
    const mesSelecionado = document.getElementById('mes').value;
    const anoFirebase = await getAnoPainelFirebase();
    const semanaNumero = await countHistoricoSemanas(anoFirebase, mesSelecionado) + 1;
    const totalSemanas = await getTotalSemanasNoMes(anoFirebase, mesSelecionado);

    // -- NOVA LÓGICA DE VALIDAÇÃO --
    // Verifica se o número da próxima semana excede o total de semanas do mês.
    // A condição `totalSemanas > 0` é uma segurança para meses sem histórico.
    if (totalSemanas > 0 && semanaNumero > totalSemanas) {
        // Se exceder, exibe a mensagem de aviso
        weekDisplay.innerHTML = "Mude o Mês, já não há mais semanas neste mês";
        weekDisplay.style.color = '#e74c3c'; // Um vermelho forte para alerta
        weekDisplay.style.fontWeight = 'bold';

        // Desativa o botão "Seguinte" para impedir que o utilizador avance
        nextButton.disabled = true;
        nextButton.style.backgroundColor = '#bdc3c7'; // Cor cinza para indicar desativado
        nextButton.style.cursor = 'not-allowed';

    } else {
        // Se a semana for válida, executa a lógica original
        const diasSemana = getDiasSemana(anoFirebase, mesSelecionado, semanaNumero);

        // Atualiza o input escondido
        document.getElementById('semanaNumero').value = semanaNumero;

        // Exibe as informações da semana
        const weekDisplayText = `${semanaNumero}ª semana de ${totalSemanas} semanas <br>(${diasSemana})`;
        weekDisplay.innerHTML = weekDisplayText;
        
        // Restaura o estilo normal do texto
        weekDisplay.style.color = '#2c3e50';
        weekDisplay.style.fontWeight = 'normal';

        // Garante que o botão "Seguinte" está ativo e com o estilo correto
        nextButton.disabled = false;
        nextButton.style.backgroundColor = '#2ecc71'; // Cor original verde
        nextButton.style.cursor = 'pointer';
    }
};







   const getWeekMondayFriday = (ano, mes, semanaNumero) => {
                const primeiroDiaMes = new Date(ano, mes - 1, 1);
                let diaSemanaPrimeiroDia = primeiroDiaMes.getDay();
                if (diaSemanaPrimeiroDia === 0) diaSemanaPrimeiroDia = 7; // Converte Domingo (0) para 7

                let diasToAddForFirstMonday = (8 - diaSemanaPrimeiroDia) % 7;
                if (primeiroDiaMes.getDay() === 1) {
                    diasToAddForFirstMonday = 0;
                }

                const primeiroSegundaMes = new Date(ano, mes - 1, 1 + diasToAddForFirstMonday);
                const monday = new Date(primeiroSegundaMes);
                monday.setDate(monday.getDate() + (semanaNumero - 1) * 7);
                const friday = new Date(monday);
                friday.setDate(friday.getDate() + 4);

                monday.setHours(0, 0, 0, 0);
                friday.setHours(23, 59, 59, 999);

                return { monday, friday };
            };

            /**
             * Guarda um registo no histórico para um evento especial.
             */
            const saveSpecialEvent = async () => {
                try {
                    const ano = await getAnoPainelFirebase();
                    const mes = parseInt(document.getElementById('mes').value);
                    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);
                    const tipoEvento = document.getElementById('tipo').value;
                    const idiomasSelecionados = Array.from(document.querySelectorAll('#nacionalidades input[name="nacionalidades"]:checked')).map(c => c.value);
                    const salaSelecionada = document.getElementById('sala').value;
                    const diasSemana = getDiasSemana(ano, mes, semanaNumero);
                    const horariosData = await getHorariosFromFirebase(ano);
                    const diaSemanaReuniaoString = horariosData['dia-semana'];
                    const meetingDayOfMonth = getMeetingDayOfMonth(diasSemana, diaSemanaReuniaoString);
                    const semanaIndexValue = `(${diasSemana} ${ano})`;

                    const historicoData = {
                        ano: ano, mes: mes, semanaNumero: semanaNumero, semanaindex: semanaIndexValue,
                        designacoes: [], evento: tipoEvento, tipo: "reuniao", idioma: idiomasSelecionados,
                        sala: salaSelecionada, dia: meetingDayOfMonth, hora: null, quando: "Semana",
                        oque: "reuniao", parte: "escola", timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    await db.collection("historico").add(historicoData);
                    return true;
                } catch (error) {
                    console.error("Erro ao gravar evento especial:", error);
                    alert("Ocorreu um erro ao gravar o evento especial: " + error.message);
                    return false;
                }
            };
            

   const getWeekMondaySunday = (ano, mes, semanaNumero) => {
                const primeiroDiaMes = new Date(ano, mes - 1, 1);
                let diaSemanaPrimeiroDia = primeiroDiaMes.getDay();
                if (diaSemanaPrimeiroDia === 0) diaSemanaPrimeiroDia = 7; // Converte Domingo (0) para 7

                let diasToAddForFirstMonday = (8 - diaSemanaPrimeiroDia) % 7;
                if (primeiroDiaMes.getDay() === 1) {
                    diasToAddForFirstMonday = 0;
                }

                const primeiroSegundaMes = new Date(ano, mes - 1, 1 + diasToAddForFirstMonday);
                const monday = new Date(primeiroSegundaMes);
                monday.setDate(monday.getDate() + (semanaNumero - 1) * 7);
                const sunday = new Date(monday);
                sunday.setDate(sunday.getDate() + 6); // Adiciona 6 dias para ir de Segunda a Domingo

                monday.setHours(0, 0, 0, 0);
                sunday.setHours(23, 59, 59, 999);

                return { monday, sunday };
            };





            /**
             * Mostra um painel de confirmação customizado para o Memorial e retorna uma Promise.
             * @returns {Promise<boolean>} Resolve para true se o utilizador confirmar, false se cancelar.
             */
          const showSpecialEventConfirmation = (eventType) => {
                const eventDisplayNames = {
                    'memorial': 'O Memorial',
                    'assembleia': 'A Assembleia',
                    'congresso': 'O Congresso'
                };
                const eventName = eventDisplayNames[eventType] || 'Este evento especial';

                return new Promise((resolve) => {
                    const popup = document.getElementById('memorialConfirmationPopup');
                    const messageEl = document.getElementById('memorialPopupMessage');
                    const confirmBtn = document.getElementById('confirmMemorialSave');
                    const cancelBtn = document.getElementById('cancelMemorialSave');

                    // Atualiza a mensagem do popup dinamicamente
                    messageEl.textContent = `A data de ${eventName} coincide com esta semana. Deseja gravar um evento especial sem designações e concluir?`;
                    
                    popup.style.display = 'flex';

                    const handleConfirm = () => {
                        popup.style.display = 'none';
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(true);
                    };

                    const handleCancel = () => {
                        popup.style.display = 'none';
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(false);
                    };

                    confirmBtn.addEventListener('click', handleConfirm);
                    cancelBtn.addEventListener('click', handleCancel);
                });
            };

            // Handle "Seguinte" button click (VERSÃO COM PAINEL CUSTOMIZADO)
   document.getElementById('btnSeguinte').addEventListener('click', async function() {
    const tipoReuniao = document.getElementById('tipo').value;
    
    // Lista de eventos que acionam a verificação (incluindo Visita do Servo, para consistência)
    const specialEventTypes = ['memorial', 'assembleia', 'congresso', 'visita-servo'];

    if (specialEventTypes.includes(tipoReuniao)) {
        const ano = await getAnoPainelFirebase();
        
        const eventNameMap = {
            'memorial': 'Memorial',
            'assembleia': 'Assembleia',
            'congresso': 'Congresso',
            'visita-servo': 'Visita do Servo'
        };
        const eventNameForQuery = eventNameMap[tipoReuniao];
        
        if (eventNameForQuery) {
            const snapshot = await db.collection('eventos')
                .where('nome', '==', eventNameForQuery)
                .where('ano', '==', ano)
                .get();

            if (!snapshot.empty) {
                const mes = parseInt(document.getElementById('mes').value);
                const semanaNumero = parseInt(document.getElementById('semanaNumero').value);
                const { monday: weekStart, sunday: weekEnd } = getWeekMondaySunday(ano, mes, semanaNumero);
                
                let overlapFound = false;

                // ===== INÍCIO DA LÓGICA CORRIGIDA =====
                // Agora percorremos TODOS os documentos de evento encontrados
                for (const doc of snapshot.docs) {
                    const eventData = doc.data();
                    
                    // Verifica evento com data única
                    if (eventData.data) {
                        const eventDate = new Date(eventData.data + 'T12:00:00');
                        if (eventDate >= weekStart && eventDate <= weekEnd) {
                            overlapFound = true;
                            break; // Encontrou uma correspondência, pode parar de procurar
                        }
                    } 
                    // Verifica evento com intervalo de datas
                    else if (eventData.data_inicio && eventData.data_fim) {
                        const eventStart = new Date(eventData.data_inicio + 'T00:00:00');
                        const eventEnd = new Date(eventData.data_fim + 'T23:59:59');
                        if (eventStart <= weekEnd && eventEnd >= weekStart) {
                            overlapFound = true;
                            break; // Encontrou uma correspondência, pode parar de procurar
                        }
                    }
                }
                // ===== FIM DA LÓGICA CORRIGIDA =====

                if (overlapFound) {
                    const confirmed = await showSpecialEventConfirmation(tipoReuniao);
                    if (confirmed) {
                        const success = await saveSpecialEvent();
                        if (success) {
                            alert(`Evento de ${eventNameForQuery} gravado com sucesso!`);
                            window.location.reload();
                        }
                    }
                    return; // Interrompe o fluxo para não mostrar as designações
                }
            }
        }
    }

    // Se não for um evento especial com sobreposição de datas, continua com a lógica original
    const designacoesSection = document.getElementById('designacoesSection');
    const leituraBibliaSection = document.getElementById('leituraBibliaSection');
    const iniciarFluxoButton = document.querySelector('#fluxoSemanalForm button[type="submit"].btn-submit');

    designacoesSection.classList.add('active');
    leituraBibliaSection.style.display = 'block';
    iniciarFluxoButton.style.display = 'block';
    designacoesSection.scrollIntoView({ behavior: 'smooth' });
});

            // ======================================================================== //
            // ============= FIM: NOVAS FUNÇÕES PARA LÓGICA DO MEMORIAL =============== //
            // ======================================================================== //




            // Call updateWeekDisplay initially and when month changes
            updateWeekDisplay();
            document.getElementById('mes').addEventListener('change', updateWeekDisplay);






            

            const activeDesignationsDisplay = {};


            // --- Nova Função: getEligiblePeopleForDropdown (já existente - manter) ---
            const getEligiblePeopleForDropdown = (dropdown) => {
    const peopleIds = [];
    const options = dropdown.querySelectorAll('option');
    
    options.forEach(option => {
        // A CONDIÇÃO MAIS IMPORTANTE ESTÁ AQUI:
        // Só considera a opção se ela tiver um valor E se não estiver escondida (style.display !== 'none')
        if (option.value && option.style.display !== 'none') {
            peopleIds.push(option.value);
        }
    });
    
    return peopleIds;
};



            // --- Função rankPeopleByDesignationCount - IMPLEMENTAÇÃO COMPLETA (já existente - manter) ---
            const rankPeopleByDesignationCount = async (eligiblePeopleIds, designationName, ano, returnScore = false) => {
    const historicoRef = db.collection('historico');
    const historicoQuery = historicoRef
        .where("ano", "==", ano)
        .where("quando", "==", "Semana");

    const historicoSnapshot = await historicoQuery.get();
    const designationCounts = {};

    eligiblePeopleIds.forEach(personId => {
        designationCounts[personId] = { total: 0, specific: 0 };
    });

    historicoSnapshot.forEach(doc => {
        const historicoData = doc.data();
        historicoData.designacoes.forEach(designacaoHistorico => {
            if (designacaoHistorico.participantes) {
                let listaDeParticipantes = [];
                if (Array.isArray(designacaoHistorico.participantes)) {
                    listaDeParticipantes = designacaoHistorico.participantes;
                } else if (typeof designacaoHistorico.participantes === 'object') {
                    listaDeParticipantes = Object.values(designacaoHistorico.participantes);
                }

                listaDeParticipantes.forEach(participanteId => {
                    if (eligiblePeopleIds.includes(participanteId)) {
                        if (!designationCounts[participanteId]) {
                            designationCounts[participanteId] = { total: 0, specific: 0 };
                        }
                        designationCounts[participanteId].total++;
                        
                        const designacaoIdNoHistorico = designacaoHistorico.designacaoId || designacaoHistorico.designacao;
                        if (designacaoIdNoHistorico === getDesignationIdByName(designationName)) {
                            designationCounts[participanteId].specific++;
                        }
                    }
                });
            }
        });
    });

    function getDesignationIdByName(name) {
        const el = Array.from(document.querySelectorAll('#designacoesList .designacao-item label > span'))
                      .find(span => span.textContent === name);
        return el ? el.closest('.designacao-item').dataset.designacaoId : null;
    }

    const rankedPeopleArray = eligiblePeopleIds.map(personId => ({
        personId: personId,
        totalDesignations: designationCounts[personId].total,
        specificDesignations: designationCounts[personId].specific
    }));

    rankedPeopleArray.sort((a, b) => {
        if (a.totalDesignations !== b.totalDesignations) {
            return a.totalDesignations - b.totalDesignations;
        }
        return a.specificDesignations - b.specificDesignations;
    });

    // =================================================================
    // =========== INÍCIO DA CORREÇÃO AQUI =============================
    // =================================================================
    if (returnScore) {
        // Agora, em vez de retornar apenas UMA pontuação, retornamos o ARRAY COMPLETO
        // de objetos classificados. A função chamadora pode então usar .slice().
        return rankedPeopleArray;
    }
    // =================================================================
    // ============ FIM DA CORREÇÃO AQUI ===============================
    // =================================================================

    // O comportamento padrão (quando returnScore é false) continua o mesmo.
    return rankedPeopleArray.map(item => item.personId);
};





            // --- Função autoFillDesignations - MODIFICADA para regra de unicidade (já existente - MODIFICADA) ---
        const autoFillDesignations = async () => {
    const assignedPeopleThisWeek = new Set();

    document.querySelectorAll('.active-designation-container').forEach(container => {
        if (container.dataset.locked === 'true') {
            container.querySelectorAll('.form-select').forEach(select => {
                if (select.value) {
                    assignedPeopleThisWeek.add(select.value);
                }
            });
        }
    });

    document.querySelectorAll('.active-designation-container').forEach(container => {
        if (container.dataset.locked !== 'true') {
            container.querySelectorAll('.form-select').forEach(select => {
                select.value = '';
                // IMPORTANTE: Reseta a visibilidade das opções para o foguetão
                Array.from(select.options).forEach(opt => opt.style.display = '');
            });
        }
    });

    const activeDesignationContainers = document.querySelectorAll('#activeDesignationsContainer .active-designation-container, #leituraBibliaDesignationContainer .active-designation-container');
    const ano = await getAnoPainelFirebase();
    const mes = parseInt(document.getElementById('mes').value);
    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);

    const participantsLastWeek = await getParticipantsLastWeek(ano, mes, semanaNumero);
    const participantsThisMonth = await getParticipantsThisMonth(ano, mes);
    const recentPairsMap = await getRecentPairs();

    // Garante que o mapa de designações está atualizado
    const allDesignations = new Map();
    const designacoesSnapshot = await db.collection('designacoes').get();
    designacoesSnapshot.forEach(doc => allDesignations.set(doc.id, doc.data().nome));

    for (const designationContainer of activeDesignationContainers) {
        if (designationContainer.dataset.locked === 'true') {
            continue;
        }

        const designacaoId = designationContainer.dataset.designacaoId;
        const designationName = allDesignations.get(designacaoId) || 'Designação Desconhecida';
        
        const instances = designationContainer.querySelectorAll('.designacao-instance-container');
        for (let instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
            const instanceContainer = instances[instanceIndex];
            const participantSelects = instanceContainer.querySelectorAll('.form-select');

            // Lógica para 1 participante (continua igual)
            if (participantSelects.length === 1) {
                const select = participantSelects[0];
                let eligible = getEligiblePeopleForDropdown(select)
                    .filter(id => !assignedPeopleThisWeek.has(id))
                    .filter(id => !participantsLastWeek.has(id));
                
                let idealCandidates = eligible.filter(id => !participantsThisMonth.has(id));
                let finalCandidates = (idealCandidates.length > 0) ? idealCandidates : eligible;

                if (finalCandidates.length > 0) {
                    const ranked = await rankPeopleByDesignationCount(finalCandidates, designationName, ano);
                    if (ranked.length > 0) {
                        select.value = ranked[0];
                        assignedPeopleThisWeek.add(ranked[0]);
                    }
                }
            } 
            // Lógica para 2 participantes (COM A CORREÇÃO DE GÊNERO)
            else if (participantSelects.length >= 2) {
                const [dirigenteSelect, moradorSelect] = participantSelects;
                
                // IMPORTANTE: Resetamos os filtros visuais antes de obter os candidatos
                handleGenderSync(dirigenteSelect);

                const eligibleDirigentes = getEligiblePeopleForDropdown(dirigenteSelect);
                const eligibleMoradores = getEligiblePeopleForDropdown(moradorSelect);

                let possiblePairs = [];
                for (const dirigenteId of eligibleDirigentes) {
                    for (const moradorId of eligibleMoradores) {
                        if (dirigenteId === moradorId) continue;
                        if (assignedPeopleThisWeek.has(dirigenteId) || assignedPeopleThisWeek.has(moradorId)) continue;
                        if (participantsLastWeek.has(dirigenteId) || participantsLastWeek.has(moradorId)) continue;

                        // ==========================================================
                        // ============ NOVA VERIFICAÇÃO DE GÊNERO AQUI =============
                        // ==========================================================
                        const dirigenteData = allPeopleDataMap.get(dirigenteId);
                        const moradorData = allPeopleDataMap.get(moradorId);

                        // Se temos os dados de gênero de ambos e eles são DIFERENTES, o par é inválido.
                        if (dirigenteData && moradorData && dirigenteData.genero !== moradorData.genero) {
                            continue; // Salta para o próximo par
                        }
                        // ==========================================================
                        // =================== FIM DA VERIFICAÇÃO ===================
                        // ==========================================================

                        possiblePairs.push({ dirigente: dirigenteId, morador: moradorId });
                    }
                }

                const validPairs = possiblePairs.filter(pair => {
                    const pairKey = [pair.dirigente, pair.morador].sort().join('_');
                    if (!recentPairsMap.has(pairKey)) return true;
                    const history = recentPairsMap.get(pairKey);
                    const lastDate = new Date(history.lastDate);
                    const currentDate = new Date();
                    const lastMonthYear = lastDate.getFullYear() * 12 + lastDate.getMonth();
                    const currentMonthYear = currentDate.getFullYear() * 12 + currentDate.getMonth();
                    return Math.abs(currentMonthYear - lastMonthYear) > 1;
                });

                if (validPairs.length > 0) {
                    const rankedPairs = await Promise.all(validPairs.map(async (pair) => {
                        const score1Array = await rankPeopleByDesignationCount([pair.dirigente], designationName, ano, true);
                const score2Array = await rankPeopleByDesignationCount([pair.morador], designationName, ano, true);
                // Lemos o score do primeiro elemento do array retornado, com uma verificação de segurança
                const score1 = score1Array.length > 0 ? score1Array[0].totalDesignations : Infinity;
                const score2 = score2Array.length > 0 ? score2Array[0].totalDesignations : Infinity;
                // <<< FIM DA CORREÇÃO AQUI >>>
                return { pair, totalScore: score1 + score2 };
            }));
            rankedPairs.sort((a, b) => a.totalScore - b.totalScore);
            
            const bestPair = rankedPairs[0].pair;
            dirigenteSelect.value = bestPair.dirigente;
            moradorSelect.value = bestPair.morador;
            
            assignedPeopleThisWeek.add(bestPair.dirigente);
            assignedPeopleThisWeek.add(bestPair.morador);
            
            handleGenderSync(dirigenteSelect); 
        } else {
            console.warn(`autoFillDesignations - Nenhuma combinação de par válida encontrada para ${designationName}.`);
        }
    }
        }
    }
    // No final, faz uma validação geral para destacar quaisquer problemas
    setTimeout(validateAllSelections, 500);
};


async function getParticipationStatsForYear(ano) {
    // Se os dados para este ano já estiverem no cache, retorna-os imediatamente
    if (participationStatsCache.ano === ano && participationStatsCache.data) {
        return participationStatsCache.data;
    }

    console.log(`[STATS] Calculando estatísticas de participação para o ano ${ano}...`);
    const historicoSnapshot = await db.collection('historico')
                                      .where('ano', '==', ano)
                                      .where('quando', '==', 'Semana')
                                      .get();

    // Estrutura: Map<designacaoId, { total: number, participants: Set<personId>, counts: Map<personId, count> }>
    const stats = new Map();

    historicoSnapshot.forEach(doc => {
        const historico = doc.data();
        historico.designacoes?.forEach(desig => {
            const desigId = desig.designacaoId;
            if (!desigId) return;

            // Inicializa a estrutura para esta designação se for a primeira vez
            if (!stats.has(desigId)) {
                stats.set(desigId, {
                    total: 0,
                    participants: new Set(),
                    counts: new Map()
                });
            }
            const desigStats = stats.get(desigId);

            const allParticipantIds = Object.values(desig.participantes || {});
            allParticipantIds.forEach(pId => {
                desigStats.total++;
                desigStats.participants.add(pId);
                
                const currentCount = desigStats.counts.get(pId) || 0;
                desigStats.counts.set(pId, currentCount + 1);
            });
        });
    });

    // Agora, calcula a média para cada designação
    const finalData = new Map();
    for (const [desigId, desigStats] of stats.entries()) {
        const uniqueParticipantsCount = desigStats.participants.size;
        const average = uniqueParticipantsCount > 0 ? desigStats.total / uniqueParticipantsCount : 0;
        
        finalData.set(desigId, {
            average: average,
            counts: desigStats.counts
        });
    }

    // Guarda os dados calculados no cache antes de retornar
    participationStatsCache = { ano: ano, data: finalData };
    console.log("[STATS] Estatísticas calculadas e guardadas em cache.", finalData);
    return finalData;
}


// Função "inteligente" para calcular o contexto da semana anterior
async function getPreviousWeekContext(currentAno, currentMes, currentSemana) {
    if (currentSemana > 1) {
        // Caso simples: a semana anterior está no mesmo mês
        return { ano: currentAno, mes: currentMes, semana: currentSemana - 1 };
    } else {
        // Caso complexo: a semana anterior está no mês/ano anterior
        let prevMes = currentMes - 1;
        let prevAno = currentAno;
        if (prevMes === 0) {
            // Se o mês atual é Janeiro, voltamos para Dezembro do ano anterior
            prevMes = 12;
            prevAno = currentAno - 1;
        }
        // Descobrimos qual era a última semana desse mês anterior
        const ultimaSemanaDoMesAnterior = await countHistoricoSemanas(prevAno, prevMes);
        return { ano: prevAno, mes: prevMes, semana: ultimaSemanaDoMesAnterior };
    }
}

// Função "inteligente" para calcular o contexto da próxima semana
async function getNextWeekContext(currentAno, currentMes, currentSemana) {
    const totalSemanasNoMes = await getTotalSemanasNoMes(currentAno, currentMes);
    if (currentSemana < totalSemanasNoMes) {
        // Caso simples: a próxima semana está no mesmo mês
        return { ano: currentAno, mes: currentMes, semana: currentSemana + 1 };
    } else {
        // Caso complexo: a próxima semana está no próximo mês/ano
        let proxMes = currentMes + 1;
        let proxAno = currentAno;
        if (proxMes === 13) {
            // Se o mês atual é Dezembro, avançamos para Janeiro do próximo ano
            proxMes = 1;
            proxAno = currentAno + 1;
        }
        return { ano: proxAno, mes: proxMes, semana: 1 };
    }
}





// Função auxiliar para obter os participantes da semana anterior
const getParticipantsLastWeek = async (ano, mes, semanaNumero) => {
    try {
        const prevWeek = await getPreviousWeekContext(ano, mes, semanaNumero);
        
        console.log(`[VALIDATION] -> A procurar semana anterior com contexto: Ano=${prevWeek.ano}, Mês=${prevWeek.mes}, Semana=${prevWeek.semana}`);

        const q = db.collection('historico')
            // A MUDANÇA ESTÁ AQUI: Usamos o operador 'in' para apanhar tanto o número como o texto.
            .where("ano", "in", [prevWeek.ano, String(prevWeek.ano)]) 
            .where("mes", "==", prevWeek.mes)
            .where("semanaNumero", "==", prevWeek.semana);

        const snapshot = await q.get();
        const participants = new Set();
        
        if (!snapshot.empty) {
            snapshot.docs[0].data().designacoes.forEach(desig => {
                if (desig.participantes) {
                    Object.values(desig.participantes).forEach(personId => participants.add(personId.toString()));
                }
            });
        }
        console.log(`[VALIDATION] -> DADOS (Semana Anterior):`, participants);
        return participants;

    } catch (error) {
        console.error("Erro em getParticipantsLastWeek (versão robusta):", error);
        return new Set();
    }
};


// Função auxiliar para obter os participantes deste mês (até agora)
const getParticipantsThisMonth = async (ano, mes) => {
    const historicoRef = db.collection('historico');
    const q = historicoRef
        .where("ano", "==", ano)
        .where("mes", "==", mes)
        .where("quando", "==", "Semana");
        
    const snapshot = await q.get();
    const participants = new Set();
    
    snapshot.forEach(doc => {
        const historicoData = doc.data();
        if (historicoData.designacoes) {
            historicoData.designacoes.forEach(desig => {
                if (desig.participantes) {
                    Object.values(desig.participantes).forEach(personId => participants.add(personId.toString()));
                }
            });
        }
    });
    return participants;
};

            // --- Modificar Evento do Botão Turbo (já existente - manter) - REMOVENDO POPUP ---
            document.getElementById('turboButton').addEventListener('click', async function() {
                const rocketButton = this;
                rocketButton.classList.add('loading');

                try {
                    await autoFillDesignations();
                } finally {
                    rocketButton.classList.remove('loading');
                    rocketButton.classList.add('returning');

                    // Remove the 'returning' class after animation completes
                    setTimeout(() => {
                        rocketButton.classList.remove('returning');
                    }, 1000);
                }
            });


            // **MODIFIED: Evento de clique dos botões de ordenar (já existente - manter)**
            document.querySelectorAll('#designacoesList').forEach(designacoesList => {
                designacoesList.addEventListener('click', async function(event) {
                    if (event.target.classList.contains('order-button')) {
                        const orderButton = event.target;
                        const designacaoItem = orderButton.closest('.designacao-item');
                        const designacaoId = designacaoItem.dataset.designacaoId;
                        const quantitySubmenu = designacaoItem.querySelector('.quantity-submenu');
                        let nextOrderNumber = getNextOrderNumber();
                        const leituraBibliaSection = document.getElementById('leituraBibliaSection'); // Get Leitura Bíblia section

                        let currentOrderValue = parseInt(orderButton.dataset.order) || 0;
                        let currentQuantity = parseInt(orderButton.dataset.quantity) || 0;

                        if (currentOrderValue === 0) {
                            currentOrderValue = nextOrderNumber;
                            if (currentQuantity === 0) {
                                currentQuantity = 1;
                                orderButton.dataset.quantity = currentQuantity;
                                updateQuantitySubmenuSelection(quantitySubmenu, currentQuantity);
                            }
                        } else {
                            currentOrderValue = 0;
                            currentQuantity = 0;
                            orderButton.dataset.quantity = currentQuantity;
                            updateQuantitySubmenuSelection(quantitySubmenu, currentQuantity);
                            // Remove all instances when un-ordering
                            for (let instanceIndex = 1; instanceIndex <= 7; instanceIndex++) { // Loop through max possible instances to ensure removal
                                removeActiveDesignationDisplay(designacaoId, instanceIndex);
                                removeLeituraBibliaDisplay(designacaoId, instanceIndex);
                            }
                            if (designacaoItem.querySelector('label > span').textContent === 'Leitura da Bíblia') {
                                leituraBibliaSection.style.display = 'none'; // Hide Leitura Bíblia Section if un-ordering Leitura Bíblia
                            }
                        }

                        orderButton.dataset.order = currentOrderValue;
                        orderButton.textContent = currentOrderValue > 0 ? currentOrderValue : '';

                        updateOrderButtonClasses(orderButton, currentOrderValue);
                        reIndexOrderNumbers();
                        quantitySubmenu.classList.toggle('active', currentOrderValue > 0);

                        // ** UPDATED:  Immediately update participant display after order change (já existente - manter)**
                        try {
                            const designacaoDoc = await db.collection('designacoes').doc(designacaoId).get();
                            if (designacaoDoc.exists) {
                                const designacaoData = designacaoDoc.data();
                                const designacaoInfo = {
                                    id: designacaoId,
                                    ordem: currentOrderValue,
                                    quantidade: currentQuantity,
                                    numeroParticipantes: designacaoData.numeroParticipantes,
                                    quemFaz: designacaoData.quemFaz,
                                    feitoPor: designacaoData.feitoPor,
                                    nome: designacaoData.nome
                                };
                                const diasSemanaDisplay = document.getElementById('weekDisplay').innerHTML; // Get diasSemana again
                                const diasSemanaMatch = diasSemanaDisplay.match(/\((.*?)\)/);
                                const diasSemana = diasSemanaMatch ? diasSemanaMatch[1] : null;

                                const horariosData = await getHorariosFromFirebase(await getAnoPainelFirebase()); // Fetch horariosData
                                const diaSemanaReuniaoString = horariosData['dia-semana']; // Get diaSemanaReuniaoString

                                updateActiveDesignationDisplay(designacaoInfo, currentOrderValue, currentQuantity, {}, diasSemana, diaSemanaReuniaoString, temporaryPreferences); // Call update display and pass diasSemana and diaSemanaReuniaoString
                                 if (designacaoInfo.nome === 'Leitura da Bíblia' && currentOrderValue > 0) {
                                    leituraBibliaSection.style.display = 'block'; // Ensure section is visible when ordering Leitura Bíblia
                                }
                            }
                        } catch (error) {
                            console.error('Erro ao buscar detalhes da designação:', error);
                        }
                    }
                });
            });


            // Funções auxiliares para o evento de clique dos botões de ordenar (para manter o código mais organizado) (já existente - manter)
            const getNextOrderNumber = () => {
                const designacaoItems = document.querySelectorAll('#designacoesList .designacao-item');
                let maxOrder = 0;
                designacaoItems.forEach(item => {
                    const orderButton = item.querySelector('.order-button');
                    const order = parseInt(orderButton.dataset.order) || 0;
                    maxOrder = Math.max(maxOrder, order);
                });
                return maxOrder + 1;
            };

            const updateQuantitySubmenuSelection = (quantitySubmenu, quantity) => {
                quantitySubmenu.querySelectorAll('.quantity-button').forEach(btn => {
                    if (parseInt(btn.dataset.quantityValue) === quantity) {
                        btn.classList.add('selected');
                    } else {
                        btn.classList.remove('selected');
                    }
                });
            };

            const updateOrderButtonClasses = (orderButton, orderValue) => {
                orderButton.classList.remove('ordered', 'ordered-level-2', 'ordered-level-3');
                if (orderValue > 0) {
                    orderButton.classList.add('ordered');
                    if (orderValue >= 2) orderButton.classList.add('ordered-level-2');
                    if (orderValue >= 3) orderButton.classList.add('ordered-level-3');
                }
            };


            // **MODIFIED: Evento de submit do formulário "Iniciar Fluxo" - REMOVED POPUP on submit, keeping for summary (já existente - manter)**
            document.getElementById('fluxoSemanalForm').addEventListener('submit', async function(e) {
                e.preventDefault();

                // Prepare summary content
                const summaryHTML = await generatePopupSummary();
                document.getElementById('popupDesignationSummary').innerHTML = summaryHTML;

                // Show the popup
                document.getElementById('confirmationPopup').style.display = 'flex';
            });

            // Function to generate the summary HTML for the popup (já existente - manter)
            const generatePopupSummary = async () => {
                let summaryHTML = '';
                const activeDesignationContainers = document.querySelectorAll('#activeDesignationsContainer .active-designation-container, #leituraBibliaDesignationContainer .active-designation-container');

                for (const designationContainer of activeDesignationContainers) {
                    
                    const designacaoId = designationContainer.dataset.designacaoId;
                    const designacaoDoc = await db.collection('designacoes').doc(designacaoId).get();
                    const designacaoData = designacaoDoc.data();
                    const instances = designationContainer.querySelectorAll('.designacao-instance-container');

                    summaryHTML += `<div class="popup-designation-item">`;
                    summaryHTML += `<h4 class="popup-designacao-name">${designacaoData.nome}</h4>`;

                    for (let instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
                        const instanceContainer = instances[instanceIndex];
                        const participantSelects = instanceContainer.querySelectorAll('.form-select');
                        let instanceSummary = `<ul class="popup-participant-list">`;

                        for (const select of participantSelects) { // Changed forEach to for...of for await
                            const selectedPersonId = select.value;
                            if (selectedPersonId) {
                                try {
                                    const personDoc = await db.collection('pessoas').doc(selectedPersonId).get(); // Added await
                                    if (personDoc.exists) {
                                        const personData = personDoc.data();
                                        instanceSummary += `<li class="popup-participant-item">${personData.nomePessoa}</li>`;
                                    } else {
                                        instanceSummary += `<li class="popup-participant-item">Pessoa não encontrada</li>`;
                                    }
                                } catch (error) {
                                    instanceSummary += `<li class=\"popup-participant-item\">Erro ao carregar participante</li>`;
                                }
                            } else {
                                instanceSummary += `<li class=\"popup-participant-item\">Não selecionado</li>`;
                            }
                        }
                        instanceSummary += `</ul>`;
                        if (instances.length > 1) {
                            summaryHTML += `<h5>Designação ${instanceIndex + 1}</h5>`;
                        }
                        summaryHTML += instanceSummary;
                    }
                    summaryHTML += `</div>`;
                }
                return summaryHTML;
            };


            // Close popup event (já existente - manter)
            document.getElementById('closePopup').addEventListener('click', function() {
                document.getElementById('confirmationPopup').style.display = 'none';
            });

            // "Criar Fluxo Semanal" button event (já existente - manter)
document.getElementById('createFluxoSemanal').addEventListener('click', async function() {
                const confirmationPopup = document.getElementById('confirmationPopup');
                const titleElement = confirmationPopup.querySelector('.popup-title');
                const thinkingIcon = titleElement.querySelector('.thinking');
                const successIcon = titleElement.querySelector('.success');

                // Mostra o ícone de "a pensar"
                thinkingIcon.style.display = 'inline-block';
                successIcon.style.display = 'none';

                try {
                    // --- 1. Recolha de dados iniciais (sem alterações) ---
                    const ano = await getAnoPainelFirebase();
                    const mes = parseInt(document.getElementById('mes').value);
                    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);
                    const tipoEvento = document.getElementById('tipo').value;
                    const idiomasSelecionados = Array.from(document.querySelectorAll('#nacionalidades input[name="nacionalidades"]:checked'))
                        .map(checkbox => checkbox.value);
                    const salaSelecionada = document.getElementById('sala').value;
                    const diasSemana = getDiasSemana(ano, mes, semanaNumero);
                    const horariosData = await getHorariosFromFirebase(ano);
                    const horaSemana = horariosData['hora-semana'];
                    const semanaIndexValue = `(${diasSemana} ${ano})`;

                    // --- 2. LÓGICA CONDICIONAL PARA DETERMINAR A DATA (A NOVA ALTERAÇÃO) ---
                    let meetingDayOfMonth;

                    if (tipoEvento === 'visita-servo') {
                        // Se for "Visita do Servo", busca a data diretamente do evento
                        console.log("DEBUG: 'Visita do Servo' detetada. A buscar data do evento...");
                        const eventosRef = db.collection('eventos');
                        const q = eventosRef.where('nome', '==', 'Visita do Servo').where('ano', '==', ano);
                        const snapshot = await q.get();

                        if (!snapshot.empty) {
                            const eventData = snapshot.docs[0].data();
                            meetingDayOfMonth = eventData.data; // Usa a data do evento
                            console.log(`DEBUG: Data do evento encontrada e definida como: ${meetingDayOfMonth}`);
                        } else {
                            // Fallback: se não encontrar o evento, calcula a data normalmente e avisa
                            console.warn(`AVISO: Evento 'Visita do Servo' para o ano ${ano} não encontrado na base de dados. A usar a data calculada da semana.`);
                            const diaSemanaReuniaoString = horariosData['dia-semana'];
                            meetingDayOfMonth = getMeetingDayOfMonth(ano, diasSemana, diaSemanaReuniaoString);
                        }
                    } else {
                        // Para todos os outros tipos de reunião ("normal", etc.), calcula a data como antes
                        const diaSemanaReuniaoString = horariosData['dia-semana'];
                        meetingDayOfMonth = getMeetingDayOfMonth(ano, diasSemana, diaSemanaReuniaoString);
                    }
                    
                    // --- 3. Construção do objeto para o histórico (agora usa a data correta) ---
                    const historicoData = {
                        ano: ano,
                        mes: mes,
                        semanaNumero: semanaNumero,
                        semanaindex: semanaIndexValue,
                        designacoes: [],
                        evento: tipoEvento,
                        tipo: "reuniao",
                        idioma: idiomasSelecionados,
                        sala: salaSelecionada,
                        dia: meetingDayOfMonth, // << AQUI USA A VARIÁVEL QUE FOI DEFINIDA CONDICIONALMENTE
                        hora: horaSemana,
                        quando: "Semana",
                        oque: "reuniao",
                        parte: "escola",
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    // --- 4. Processamento das designações e gravação (sem alterações) ---
                    const activeDesignationContainers = document.querySelectorAll('#activeDesignationsContainer .active-designation-container, #leituraBibliaDesignationContainer .active-designation-container');
                    for (const designationContainer of activeDesignationContainers) {
                        const designacaoId = designationContainer.dataset.designacaoId;
                        const instances = designationContainer.querySelectorAll('.designacao-instance-container');
                        for (let instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
                            const instanceContainer = instances[instanceIndex];
                            const participantSelects = instanceContainer.querySelectorAll('.form-select');
                            const participantesPorFuncao = {};
                            const numParticipantes = participantSelects.length;

                            if (numParticipantes === 1 && participantSelects[0].value) {
                                participantesPorFuncao.participante = participantSelects[0].value;
                            } else if (numParticipantes === 2) {
                                if (participantSelects[0].value) participantesPorFuncao.dirigente = participantSelects[0].value;
                                if (participantSelects[1].value) participantesPorFuncao.morador = participantSelects[1].value;
                            } else if (numParticipantes >= 3) {
                                if (participantSelects[0].value) participantesPorFuncao.dirigente = participantSelects[0].value;
                                if (participantSelects[1].value) participantesPorFuncao.morador = participantSelects[1].value;
                                if (participantSelects[2].value) participantesPorFuncao.ajudante = participantSelects[2].value;
                            }

                            if (Object.keys(participantesPorFuncao).length > 0) {
                                historicoData.designacoes.push({
                                    designacaoId: designacaoId,
                                    instanceIndex: instanceIndex,
                                    participantes: participantesPorFuncao
                                });
                            }
                        }
                    }

                    await db.collection("historico").add(historicoData);
                    await saveParticipationHistoryForIndividuals(historicoData);

                    // Mostra o ícone de sucesso
                    thinkingIcon.style.display = 'none';
                    successIcon.style.display = 'inline-block';

                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);

                } catch (error) {
                    console.error("Erro ao adicionar documento: ", error);
                    thinkingIcon.style.display = 'none';
                    successIcon.style.display = 'none';
                    alert('Erro ao criar fluxo semanal: ' + error.message);
                }
            });



            // --- Helper function to get day of week number (Sunday: 0, Monday: 1, ..., Saturday: 6) (já existente - manter) ---
            function getDayOfWeekNumber(dayOfWeekString) {
                const daysOfWeek = {
                    'domingo': 0, 'segunda': 1, 'terça': 2, 'quarta': 3, 'quinta': 4, 'sexta': 5, 'sábado': 6,
                    'domingo-feira': 0, 'segunda-feira': 1, 'terça-feira': 2, 'quarta-feira': 3, 'quinta-feira': 4, 'sexta-feira': 5, 'sábado-feira': 6
                };
                const normalizedDayOfWeekString = dayOfWeekString.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(); // Normalize and remove accents
                return daysOfWeek[normalizedDayOfWeekString] !== undefined ? daysOfWeek[normalizedDayOfWeekString] : null;
            }


          // --- Helper function to get meeting day of month (CORRIGIDA) ---
function getMeetingDayOfMonth(ano, diasSemanaString, diaSemanaReuniao) {
    if (!diasSemanaString || !diaSemanaReuniao || !ano) {
        console.error("[getMeetingDayOfMonth] Erro: Faltam parâmetros essenciais (ano, diasSemanaString, ou diaSemanaReuniao).");
        return null;
    }

    try {
        const parts = diasSemanaString.split(" - ");
        if (parts.length < 2) return null;

        // Extrai o dia e o mês de início
        const startParts = parts[0].split(" ");
        const startDay = parseInt(startParts[0]);
        let startMonthStr = startParts.length > 1 ? startParts[1] : null;

        // Extrai o dia e o mês de fim
        const endParts = parts[1].split(" ");
        const endDay = parseInt(endParts[0]);
        const endMonthStr = endParts[1];

        const monthNames = ["Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
        
        // Se o mês não estiver na parte inicial (ex: "24 - 30 Jul"), usa o mês final
        if (!startMonthStr) {
            startMonthStr = endMonthStr;
        }

        const startMonthIndex = monthNames.indexOf(startMonthStr);
        const endMonthIndex = monthNames.indexOf(endMonthStr);

        if (startMonthIndex === -1 || endMonthIndex === -1) return null;

        const dayOfWeekMeetingNumber = getDayOfWeekNumber(diaSemanaReuniao);
        if (dayOfWeekMeetingNumber === null) return null;

        // Usa o ANO recebido para criar as datas, corrigindo o bug
        const startOfWeekDate = new Date(ano, startMonthIndex, startDay);
        const endOfWeekDate = new Date(ano, endMonthIndex, endDay);

        let currentDay = startOfWeekDate;
        while (currentDay <= endOfWeekDate) {
            if (currentDay.getDay() === dayOfWeekMeetingNumber) {
                const month = String(currentDay.getMonth() + 1).padStart(2, '0');
                const day = String(currentDay.getDate()).padStart(2, '0');
                // Retorna a data formatada corretamente
                return `${ano}-${month}-${day}`;
            }
            currentDay.setDate(currentDay.getDate() + 1);
        }
        return null; // Retorna null se não encontrar o dia na semana

    } catch (error) {
        console.error("[getMeetingDayOfMonth] Ocorreu uma exceção ao calcular a data:", error);
        return null;
    }
}








            const loadDesignacoes = async () => { // (já existente - manter)
                const designacoesRef = db.collection('designacoes');
                const query = designacoesRef
                    .where('tipo', '==', 'reuniao')
                    .where('quando', '==', 'Semana')
                    .where('parte', '==', 'escola')
                     .orderBy('ordem');
                const snapshot = await query.get();
                const designacoesList = document.getElementById('designacoesList');
                designacoesList.innerHTML = '';
                let nextOrderNumber = 1;
                let leituraBibliaDesignacao = null; // To store Leitura da Bíblia data

                const horariosData = await getHorariosFromFirebase(await getAnoPainelFirebase()); // Fetch horariosData here
                const diaSemanaReuniaoString = horariosData['dia-semana']; // Get diaSemanaReuniaoString

                const diasSemanaDisplay = document.getElementById('weekDisplay').innerHTML; // Get diasSemana
                const diasSemanaMatch = diasSemanaDisplay.match(/\((.*?)\)/);
                const diasSemana = diasSemanaMatch ? diasSemanaMatch[1] : null;


                for (const doc of snapshot.docs) { // Use for...of loop for synchronous processing
                    const designacao = doc.data();
                    const div = document.createElement('div');
                    div.className = 'designacao-item';
                    div.dataset.designacaoId = doc.id;

                    // Create order button
                    const orderButton = document.createElement('button');
                    orderButton.type = 'button'; // Explicitly set type="button" - IMPORTANT
                    orderButton.className = 'order-button';
                    let designationOrder = 0;
                    let designationQuantity = 0;
                    if (designacao.nome === 'Leitura da Bíblia') {
                        designationOrder = nextOrderNumber++;
                        designationQuantity = 1;
                        leituraBibliaDesignacao = { ...designacao, id: doc.id, ordem: designationOrder, quantidade: designationQuantity }; // Store Leitura da Bíblia data and default order/quantity
                    }
                    orderButton.dataset.order = designationOrder;
                    orderButton.dataset.quantity = designationQuantity;
                    orderButton.textContent = designationOrder > 0 ? designationOrder : '';

                    if (designationOrder > 0) {
                        orderButton.classList.add('ordered');
                        if (designationOrder >= 2) orderButton.classList.add('ordered-level-2');
                        if (designationOrder >= 3) orderButton.classList.add('ordered-level-3');
                    }

                    // Create label
                    const label = document.createElement('label');
                    label.setAttribute('for', doc.id);
                    label.style.marginBottom = '0';
                    label.style.flexGrow = '1';
                    label.style.display = 'flex';

                    label.appendChild(orderButton);
                    const textSpan = document.createElement('span');
                    textSpan.textContent = designacao.nome;
                    label.appendChild(textSpan);

                    div.appendChild(label);

                    // Create quantity submenu
                    const quantitySubmenu = createQuantitySubmenu(doc.id, designationQuantity, orderButton); // Helper function to create submenu
                    div.appendChild(quantitySubmenu);

                    designacoesList.appendChild(div);
                }

                // After loading all designations, if Leitura da Bíblia was found and ordered, display it
                if (leituraBibliaDesignacao) { // Check if leituraBibliaDesignacao is not null
                    updateLeituraBibliaDisplay(leituraBibliaDesignacao, leituraBibliaDesignacao.ordem, leituraBibliaDesignacao.quantidade, {}, diasSemana, diaSemanaReuniaoString); // pass diaSemanaReuniaoString here
                }
            };



            // Função principal que abre o popup de análise de par
            async function openPairAnalysisPopup(participants) {
    const popup = document.getElementById('pairAnalysisPopup');
    const title = document.getElementById('pairAnalysisTitle');
    const tabsContainer = document.getElementById('pairAnalysisTabsContainer');
    const contentContainer = document.getElementById('pairAnalysisContentContainer');

    tabsContainer.innerHTML = 'A carregar...';
    contentContainer.innerHTML = '';

    const participantNames = participants.map(p => p.name).join(' & ');
    title.textContent = `Análise de: ${participantNames}`;
    popup.style.display = 'flex';

    const participantIds = participants.map(p => p.id);
    const pairHistory = await fetchPairHistory(participantIds);

    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    // =================================================================
    // =========== INÍCIO: CORREÇÃO NOS NOMES DOS ALVOS E IDs ==========
    // =================================================================
    // Aba 1: Histórico do Par - O alvo AGORA é "content-history"
    const historyTab = createTab('Histórico do Par', 'content-history', true);
    const historyContent = createTabContent('content-history', true);
    historyContent.appendChild(buildHistoryTable(pairHistory, "Histórico de Colaboração"));
    tabsContainer.appendChild(historyTab);
    contentContainer.appendChild(historyContent);
    
    // Abas 2, 3, ...: Perfis Individuais - O alvo AGORA é "content-pX"
    participants.forEach((participant, index) => {
        const tab = createTab(participant.name, `content-p${index}`, false);
        const content = createTabContent(`content-p${index}`, false);
        content.innerHTML = `<p>A carregar perfil de ${participant.name}...</p>`;
        
        tabsContainer.appendChild(tab);
        contentContainer.appendChild(content);

        tab.addEventListener('click', async () => {
            if (content.dataset.loaded !== 'true') {
                const individualHistory = await fetchIndividualHistory(participant.id);
                content.innerHTML = '';
                content.appendChild(buildHistoryTable(individualHistory, `Histórico Completo de ${participant.name}`));
                content.dataset.loaded = 'true';
            }
        });
    });
    // =================================================================
    // ============ FIM: CORREÇÃO NOS NOMES DOS ALVOS E IDs ============
    // =================================================================

    setupTabClickListeners();
}


// Função para buscar o histórico onde TODOS os participantes estiveram juntos
async function fetchPairHistory(participantIds) {
    const historicoSnapshot = await db.collection('historico').get();
    const records = [];
    historicoSnapshot.forEach(doc => {
        const historico = doc.data();
        if (historico.designacoes && Array.isArray(historico.designacoes)) {
            historico.designacoes.forEach(designacao => {
                const allParticipantIdsInDesig = Object.values(designacao.participantes);
                // Verifica se TODOS os IDs do nosso par estão na designação
                const allMembersPresent = participantIds.every(id => allParticipantIdsInDesig.includes(id));
                if (allMembersPresent) {
                    records.push({
                        dia: historico.dia,
                        designacaoNome: allDesignations.get(designacao.designacaoId) || 'Desconhecida',
                        papeis: designacao.participantes
                    });
                }
            });
        }
    });
    return records.sort((a, b) => new Date(b.dia) - new Date(a.dia));
}

// Reutilizar a sua lógica de buscar histórico, mas de forma mais simples
async function fetchIndividualHistory(personId) {
    const historicoSnapshot = await db.collection('historico').get();
    let records = [];

    historicoSnapshot.forEach(doc => {
        const historico = doc.data();
        if (historico.designacoes && Array.isArray(historico.designacoes)) {
            historico.designacoes.forEach(designacao => {
                
                // Primeiro, verifica se a pessoa participou, independentemente do formato
                let allParticipantIdsInDesig = [];
                if (Array.isArray(designacao.participantes)) {
                    allParticipantIdsInDesig = designacao.participantes;
                } else if (designacao.participantes && typeof designacao.participantes === 'object') {
                    allParticipantIdsInDesig = Object.values(designacao.participantes);
                }

                if (allParticipantIdsInDesig.includes(personId)) {
                    
                    // ==========================================================
                    // INÍCIO: LÓGICA INTELIGENTE PARA DETERMINAR OS PAPÉIS
                    // ==========================================================
                    let papeisCorrigidos = {};
                    if (Array.isArray(designacao.participantes)) {
                        // Se for um array, vamos assumir os papéis pela posição
                        if(designacao.participantes[0]) papeisCorrigidos.Dirigente = designacao.participantes[0];
                        if(designacao.participantes[1]) papeisCorrigidos.Morador = designacao.participantes[1];
                        if(designacao.participantes[2]) papeisCorrigidos.Ajudante = designacao.participantes[2];
                    } else {
                        // Se já for um objeto, usa-o diretamente
                        papeisCorrigidos = designacao.participantes;
                    }
                    // ==========================================================
                    // FIM: LÓGICA INTELIGENTE PARA DETERMINAR OS PAPÉIS
                    // ==========================================================

                    records.push({
                        dia: historico.dia, // Garanta que todos os docs de histórico têm este campo
                        designacaoNome: allDesignations.get(designacao.designacaoId) || 'Designação Desconhecida',
                        papeis: papeisCorrigidos // Usa o nosso novo objeto de papéis corrigido
                    });
                }
            });
        }
    });

    return records.sort((a, b) => new Date(b.dia) - new Date(a.dia));
}

async function loadAllDesignationsMap() {
    try {
        const designacoesSnapshot = await db.collection('designacoes').get();
        // Limpa o Map e preenche-o com os dados mais recentes
        allDesignations = new Map(); 
        designacoesSnapshot.forEach(doc => {
            allDesignations.set(doc.id, doc.data().nome);
        });
        console.log("Mapa global de designações carregado com sucesso.");
    } catch (error) {
        console.error("Erro ao carregar o mapa global de designações:", error);
    }
}

// Funções de ajuda para criar os elementos das abas
function createTab(text, target, isActive) {
    const button = document.createElement('button');
    button.className = 'tab-button' + (isActive ? ' active' : '');
    button.textContent = text;
    button.dataset.target = '#' + target;
    return button;
}
function createTabContent(id, isActive) {
    const div = document.createElement('div');
    div.className = 'tab-content' + (isActive ? ' active' : '');
    div.id = id;
    return div;
}

// Lógica de clique para as abas
function setupTabClickListeners() {
    const tabs = document.querySelectorAll('.analysis-popup .tab-button');
    const contents = document.querySelectorAll('.analysis-popup .tab-content');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            document.querySelector(tab.dataset.target).classList.add('active');
        });
    });
}

// Lógica para o botão de fechar o novo popup
document.getElementById('closePairAnalysisPopup').addEventListener('click', () => {
    document.getElementById('pairAnalysisPopup').style.display = 'none';
});

function buildHistoryTable(records, titleText) {
    const container = document.createElement('div');
    
    const title = document.createElement('h3');
    title.style.marginBottom = '15px';
    title.textContent = titleText;
    container.appendChild(title);

    if (!records || records.length === 0) {
        container.innerHTML += '<p>Nenhum histórico encontrado para os critérios selecionados.</p>';
        return container;
    }

    const table = document.createElement('table');
    table.className = 'estatisticas-table'; // Reutiliza o estilo da sua tabela de estatísticas

    table.innerHTML = `
        <thead>
            <tr>
                <th>Data</th>
                <th>Designação</th>
                <th>Papéis Desempenhados</th>
            </tr>
        </thead>
    `;

    const tbody = document.createElement('tbody');
    records.forEach(record => {
        const tr = document.createElement('tr');
        
        // Formata a data (reutiliza a sua função existente)
        const formattedDate = formatDateForDisplay(record.dia); 
        
        // Formata os papéis para serem mais legíveis
        let rolesHtml = '<ul style="padding-left: 15px; margin: 0;">';
        if (record.papeis && typeof record.papeis === 'object') {
            for (const [role, personId] of Object.entries(record.papeis)) {
                // `allPeopleDataMap` é o Map que você já carrega para outros fins
                const personName = allPeopleDataMap.get(personId) || 'Participante Desconhecido';
                const formattedRole = role.charAt(0).toUpperCase() + role.slice(1);
                rolesHtml += `<li><strong>${formattedRole}:</strong> ${personName}</li>`;
            }
        } else {
            rolesHtml += '<li>Informação de papéis indisponível</li>';
        }
        rolesHtml += '</ul>';

        tr.innerHTML = `
            <td>${formattedDate}</td>
            <td>${record.designacaoNome}</td>
            <td>${rolesHtml}</td>
        `;
        tbody.appendChild(tr);
    });
    
    table.appendChild(tbody);
    container.appendChild(table);
    
    return container;
}

// ======================================================================== //
// ============  NOVA FUNÇÃO: OBTER PARTICIPANTES DA SEMANA SEGUINTE ====== //
// ======================================================================== //

const getParticipantsNextWeek = async (ano, mes, semanaNumero) => {
    try {
        const nextWeek = await getNextWeekContext(ano, mes, semanaNumero);

        console.log(`[VALIDATION] -> A procurar próxima semana com contexto: Ano=${nextWeek.ano}, Mês=${nextWeek.mes}, Semana=${nextWeek.semana}`);

        const q = db.collection('historico')
            // A MUDANÇA ESTÁ AQUI: Usamos o operador 'in' para apanhar tanto o número como o texto.
            .where("ano", "in", [nextWeek.ano, String(nextWeek.ano)])
            .where("mes", "==", nextWeek.mes)
            .where("semanaNumero", "==", nextWeek.semana)
            .where("quando", "==", "Semana");

        const snapshot = await q.get();
        const participants = new Set();
        
        if (!snapshot.empty) {
            snapshot.docs[0].data().designacoes.forEach(desig => {
                if (desig.participantes) {
                    Object.values(desig.participantes).forEach(personId => participants.add(personId.toString()));
                }
            });
        }
        console.log(`[VALIDATION] -> DADOS (Semana Seguinte):`, participants);
        return participants;

    } catch (error) {
        console.error("Erro em getParticipantsNextWeek (versão robusta):", error);
        return new Set();
    }
};



const saveParticipationHistoryForIndividuals = async (historicoData) => {
    try {
        // Usamos um Map para agrupar todas as designações por participante numa única passagem.
        // A chave será o ID da pessoa, e o valor será o objeto de histórico personalizado para ela.
        const participantsMap = new Map();

        // Itera sobre cada designação da semana
        for (const designacao of historicoData.designacoes) {
            // Itera sobre cada participante dentro da designação (dirigente, morador, etc.)
            for (const personId of Object.values(designacao.participantes)) {

                // Se o participante ainda não está no nosso mapa, inicializa os seus dados.
                if (!participantsMap.has(personId)) {
                    // Cria uma cópia do histórico principal, mas com um array de designações vazio.
                    const personHistoryData = {
                        ...historicoData, // Copia todos os campos: ano, mes, dia, tipo, etc.
                        designacoes: []   // Começa com uma lista de designações vazia
                    };
                    participantsMap.set(personId, personHistoryData);
                }

                // Adiciona a designação atual à lista de designações daquela pessoa para esta semana.
                participantsMap.get(personId).designacoes.push(designacao);
            }
        }

        // Agora, `participantsMap` contém um registo para cada pessoa com apenas as suas próprias designações.
        // Vamos criar uma promessa de gravação para cada um.
        const savePromises = [];

        for (const [personId, personHistoryData] of participantsMap.entries()) {
            // Constrói a referência para a subcoleção correta.
            // Ex: db.collection('pessoas').doc('ID_DA_MARIA').collection('2024')
            const personHistoryCollectionRef = db.collection('pessoas')
                                                 .doc(personId)
                                                 .collection(String(historicoData.ano)); // O nome da coleção é o ano.

            // Adiciona a promessa de gravação ao nosso array.
            savePromises.push(personHistoryCollectionRef.add(personHistoryData));
        }

        // Executa todas as gravações em paralelo para maior eficiência.
        await Promise.all(savePromises);
        console.log("Histórico de participação individual salvo com sucesso para todos os participantes.");

    } catch (error) {
        console.error("Erro ao salvar o histórico de participação individual:", error);
        // Opcional: Adicionar tratamento de erro, embora o erro principal seja capturado na função chamadora.
    }
};






            const createQuantitySubmenu = (designacaoId, designationQuantity, orderButton) => { // (já existente - manter)
                const quantitySubmenu = document.createElement('div');
                quantitySubmenu.className = 'quantity-submenu';
                quantitySubmenu.dataset.designacaoId = designacaoId;
                for (let i = 1; i <= 7; i++) {
                    const quantityButton = document.createElement('button');
                    quantityButton.className = 'quantity-button';
                    quantityButton.textContent = i;
                    quantityButton.dataset.quantityValue = i;
                    if (i === designationQuantity) {
                        quantityButton.classList.add('selected');
                    }
                    quantityButton.addEventListener('click', async (e) => { // ADDED ASYNC
                        e.preventDefault(); // ADDED preventDefault - IMPORTANT
                        e.stopPropagation(); // Ensure event propagation is stopped - CHECK THIS LINE


                        const selectedQuantity = parseInt(quantityButton.dataset.quantityValue);
                        orderButton.dataset.quantity = selectedQuantity;

                        quantitySubmenu.querySelectorAll('.quantity-button').forEach(btn => btn.classList.remove('selected'));
                        quantityButton.classList.add('selected');
                        quantitySubmenu.classList.remove('active');

                        // **--- FIX: Call updateActiveDesignationDisplay here ---**
                        const designacaoIdForUpdate = quantitySubmenu.dataset.designacaoId;
                        try {
                            const designacaoDoc = await db.collection('designacoes').doc(designacaoIdForUpdate).get();
                            if (designacaoDoc.exists) {
                                const designacaoData = designacaoDoc.data();
                                // Initialize temporaryPreferences for each instance
                                for (let i = 1; i <= selectedQuantity; i++) {
                                    const instanceKey = `participantes-${designacaoIdForUpdate}-${i}`;
                                    if (!temporaryPreferences[instanceKey]) {
                                        temporaryPreferences[instanceKey] = designacaoData.numeroParticipantes || 1;
                                    }
                                }
                                const designacaoInfo = {
                                    id: designacaoIdForUpdate,
                                    ordem: parseInt(orderButton.dataset.order) || 0, // Get current order
                                    quantidade: selectedQuantity,
                                    numeroParticipantes: designacaoData.numeroParticipantes,
                                    quemFaz: designacaoData.quemFaz,
                                    feitoPor: designacaoData.feitoPor,
                                    nome: designacaoData.nome
                                };
                                const diasSemanaDisplay = document.getElementById('weekDisplay').innerHTML; // Get diasSemana again
                                const diasSemanaMatch = diasSemanaDisplay.match(/\((.*?)\)/);
                                const diasSemana = diasSemanaMatch ? diasSemanaMatch[1] : null;
                                const horariosData = await getHorariosFromFirebase(await getAnoPainelFirebase()); // Fetch horariosData
                                const diaSemanaReuniaoString = horariosData['dia-semana']; // Get diaSemanaReuniaoString
                                updateActiveDesignationDisplay(designacaoInfo, designacaoInfo.ordem, selectedQuantity, {}, diasSemana, diaSemanaReuniaoString, temporaryPreferences); // **Pass temporaryPreferences here**
                            }
                        } catch (error) {
                            console.error('Erro ao buscar detalhes da designação para atualizar display:', error);
                        }
                    });
                    quantitySubmenu.appendChild(quantityButton);
                }
                return quantitySubmenu;
            };

            function saveSelectionsForDesignation(designacaoId) {
                // Inicializa ou limpa o estado para esta designação
                participantSelections[designacaoId] = {};

                const allInstances = document.querySelectorAll(`.active-designation-container[data-designacao-id="${designacaoId}"]`);

                allInstances.forEach(container => {
                    // Extrai o número da instância a partir do ID do container
                    const instanceNumber = parseInt(container.id.split('-').pop());
                    if (!isNaN(instanceNumber)) {
                        const selects = container.querySelectorAll('.form-select');
                        // Guarda um array com os valores dos dropdowns para esta instância
                        participantSelections[designacaoId][instanceNumber] = Array.from(selects).map(s => s.value);
                    }
                });
            }





     const updateActiveDesignationDisplay = async (designacao, order, quantity, instancePreferences = {}, diasSemana, diaSemanaReuniaoString, temporaryPreferences = {}) => {
    const designacaoId = designacao.id;

    // PASSO 1: SALVA O ESTADO ATUAL (OS NOMES SELECIONADOS) ANTES DE FAZER QUALQUER ALTERAÇÃO VISUAL
    saveSelectionsForDesignation(designacaoId);

    const isLeituraBiblia = designacao.nome === 'Leitura da Bíblia';
    const containerToUse = isLeituraBiblia ? document.getElementById('leituraBibliaDesignationContainer') : document.getElementById('activeDesignationsContainer');

    // Remove os cards que já não são necessários (se a quantidade diminuiu)
    const existingContainers = containerToUse.querySelectorAll(`.active-designation-container[data-designacao-id="${designacaoId}"]`);
    existingContainers.forEach(container => {
        const instanceNum = parseInt(container.id.split('-').pop());
        if (instanceNum > quantity) {
            container.remove();
        }
    });

    if (quantity <= 0) {
        return;
    }

    // Loop através de cada instância para criar ou atualizar os seus containers
    for (let designacaoInstance = 1; designacaoInstance <= quantity; designacaoInstance++) {
        let designationDisplayContainer;
        const containerId = `active-designation-${designacaoId}-${designacaoInstance}`;
        let existingDisplay = containerToUse.querySelector(`#${containerId}`);

        if (!existingDisplay) {
            designationDisplayContainer = document.createElement('div');
            designationDisplayContainer.id = containerId;
            designationDisplayContainer.className = 'active-designation-container';
            designationDisplayContainer.style.marginTop = '20px';
            designationDisplayContainer.style.padding = '15px';
            designationDisplayContainer.style.borderRadius = '8px';
            designationDisplayContainer.dataset.designacaoId = designacao.id;
            containerToUse.appendChild(designationDisplayContainer);
        } else {
            designationDisplayContainer = existingDisplay;
            designationDisplayContainer.innerHTML = ''; // Limpa o conteúdo para reconstruir
        }

        const designacaoInstanceContainer = document.createElement('div');
        designacaoInstanceContainer.className = 'designacao-instance-container';
        designacaoInstanceContainer.style.marginBottom = '20px';

        const orderLevel = designacao.ordem || 0;
        if (orderLevel === 1) { designationDisplayContainer.style.backgroundColor = 'rgba(46, 204, 113, 0.1)'; } 
        else if (orderLevel === 2) { designationDisplayContainer.style.backgroundColor = 'rgba(52, 152, 219, 0.1)'; }
        else if (orderLevel === 3) { designationDisplayContainer.style.backgroundColor = 'rgba(243, 156, 18, 0.1)'; }
        else if (orderLevel === 4) { designationDisplayContainer.style.backgroundColor = 'rgba(155, 89, 182, 0.1)'; }
        else if (orderLevel === 5) { designationDisplayContainer.style.backgroundColor = 'rgba(231, 76, 60, 0.1)'; }
        else if (orderLevel === 6) { designationDisplayContainer.style.backgroundColor = 'rgba(26, 188, 156, 0.1)'; }
        else if (orderLevel === 7) { designationDisplayContainer.style.backgroundColor = 'rgba(241, 196, 15, 0.1)'; }
        else { designationDisplayContainer.style.backgroundColor = '#f8f9fa'; }

        const title = document.createElement('h5');
        title.textContent = `${designacao.nome || designacaoId} (${designacaoInstance})`;
        title.style.marginBottom = '10px';
        designacaoInstanceContainer.appendChild(title);

        // --- LÓGICA DE PREFERÊNCIAS (AGORA CENTRALIZADA) ---
        const instanceKeyPrefix = `${designacaoId}-${designacaoInstance}`;
        const keyNumParticipantes = `numParticipantes-${instanceKeyPrefix}`;
        const keyGeneroPref = `generoPreferencia-${instanceKeyPrefix}`;
        const keyGeneroMix = `generoMix-${instanceKeyPrefix}`;

        let numeroParticipantesDynamic = parseInt(temporaryPreferences[keyNumParticipantes]) || designacao.numeroParticipantes || 1;
        let generoPreferencia = temporaryPreferences[keyGeneroPref] || (designacao.feitoPor ? designacao.feitoPor.toLowerCase() : 'masculino feminino');
        let generoMix = temporaryPreferences[keyGeneroMix] || 'nao';

        const participantRoles = [];
        if (numeroParticipantesDynamic === 1) { participantRoles.push("Dirigente"); } 
        else if (numeroParticipantesDynamic === 2) { participantRoles.push("Dirigente", "Morador"); } 
        else if (numeroParticipantesDynamic === 3) { participantRoles.push("Dirigente", "Morador", "Ajudante"); }

        for (let i = 0; i < numeroParticipantesDynamic; i++) {
            const roleLabel = document.createElement('span');
            roleLabel.textContent = (numeroParticipantesDynamic > 1) ? participantRoles[i] : `Participante`;
            roleLabel.style.fontSize = '0.9em'; roleLabel.style.color = '#777'; roleLabel.style.display = 'block'; roleLabel.style.marginBottom = '3px';
            designacaoInstanceContainer.appendChild(roleLabel);

            let participantSelect = document.createElement('select');
            participantSelect.id = `participant-${designacaoId}-${designacaoInstance}-${i}`;
            participantSelect.className = 'form-select';
            participantSelect.style.marginBottom = '10px'; participantSelect.style.width = '100%';
            participantSelect.innerHTML = '<option value="">Selecione uma pessoa</option>';

            if (participantSelections[designacaoId] && participantSelections[designacaoId][designacaoInstance] && participantSelections[designacaoId][designacaoInstance][i]) {
                participantSelect.value = participantSelections[designacaoId][designacaoInstance][i];
            }
            participantSelect.addEventListener('change', () => {
                saveSelectionsForDesignation(designacaoId);
            });
            designacaoInstanceContainer.appendChild(participantSelect);
        }

        designationDisplayContainer.appendChild(designacaoInstanceContainer);
        designationDisplayContainer.style.position = 'relative';

        const filterIcon = document.createElement('i');
        filterIcon.className = 'fas fa-filter filter-icon';
        filterIcon.title = 'Filtrar';

        const filterPopup = document.createElement('div');
        filterPopup.className = 'filter-popup';
        filterPopup.innerHTML = `
            <h4>Filtros</h4>
            <div class="filter-options">
                <label for="num-participantes-${designacaoInstance}">Número de Participantes</label>
                <select id="num-participantes-${designacaoInstance}">
                    <option value="1">1</option> <option value="2">2</option> <option value="3">3</option>
                </select>
            </div>
            <div class="filter-options" style="margin-top: 15px;">
                <label for="genero-preferencia-${designacaoInstance}">Preferência de Género</label>
                <select id="genero-preferencia-${designacaoInstance}">
                    <option value="masculino feminino">Masculino/Feminino</option>
                    <option value="masculino">Masculino</option>
                    <option value="feminino">Feminino</option>
                </select>
            </div>
            <div class="filter-options" style="margin-top: 15px;">
                <label for="genero-mix-${designacaoInstance}">Masculino com Feminino</label>
                <select id="genero-mix-${designacaoInstance}" class="gender-mix-select">
                    <option value="nao">Não</option> <option value="sim">Sim</option>
                </select>
            </div>
        `;

        // Configura e adiciona listeners aos filtros
        const numParticipantesSelect = filterPopup.querySelector(`#num-participantes-${designacaoInstance}`);
        numParticipantesSelect.value = numeroParticipantesDynamic;
        numParticipantesSelect.addEventListener('change', (e) => {
            temporaryPreferences[keyNumParticipantes] = e.target.value; // SALVA A PREFERÊNCIA
            updateActiveDesignationDisplay(designacao, order, quantity, instancePreferences, diasSemana, diaSemanaReuniaoString, temporaryPreferences);
        });
        
        const generoPreferenciaSelect = filterPopup.querySelector(`#genero-preferencia-${designacaoInstance}`);
        generoPreferenciaSelect.value = generoPreferencia;
        generoPreferenciaSelect.addEventListener('change', (e) => {
            temporaryPreferences[keyGeneroPref] = e.target.value; // SALVA A PREFERÊNCIA
            const selectedGender = e.target.value;
            loadPeopleOptionsIntoSelects(designacao, designationDisplayContainer, {}, diasSemana, diaSemanaReuniaoString, selectedGender);
            filterPopup.classList.remove('active');
        });
        
        const generoMixSelect = filterPopup.querySelector(`#genero-mix-${designacaoInstance}`);
        generoMixSelect.value = generoMix;
        generoMixSelect.addEventListener('change', (e) => {
            temporaryPreferences[keyGeneroMix] = e.target.value; // SALVA A PREFERÊNCIA
            const firstParticipantSelect = designationDisplayContainer.querySelector('.form-select');
            if (firstParticipantSelect) {
                handleGenderSync(firstParticipantSelect);
            }
        });

        filterIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.filter-popup').forEach(popup => {
                if (popup !== filterPopup) popup.classList.remove('active');
            });
            filterPopup.classList.toggle('active');
        });

        designationDisplayContainer.appendChild(filterPopup);
        designationDisplayContainer.appendChild(filterIcon);

        // Ícones de ação (sem alteração de lógica)
        const lockIcon = document.createElement('i');
        lockIcon.className = 'fas fa-lock-open lock-icon';
        lockIcon.title = 'Bloquear/Desbloquear Designação';
        if (designationDisplayContainer.dataset.locked === 'true') {
            lockIcon.classList.add('locked', 'fa-lock');
            lockIcon.classList.remove('fa-lock-open');
        }
        lockIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = e.target.closest('.active-designation-container');
            const isCurrentlyLocked = container.dataset.locked === 'true';
            container.dataset.locked = isCurrentlyLocked ? 'false' : 'true';
            e.target.classList.toggle('locked');
            e.target.classList.toggle('fa-lock');
            e.target.classList.toggle('fa-lock-open');
        });
        designationDisplayContainer.appendChild(lockIcon);

        const lupaIcon = document.createElement('i');
        lupaIcon.className = 'fas fa-search-plus lupa-icon';
        lupaIcon.title = 'Analisar Histórico';
        lupaIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = e.target.closest('.active-designation-container');
            const selectedParticipants = Array.from(container.querySelectorAll('.form-select'))
                .map(select => select.value ? { id: select.value, name: select.options[select.selectedIndex].text } : null)
                .filter(Boolean);
            if (selectedParticipants.length === 0) {
                alert("Por favor, selecione pelo menos um participante para analisar.");
                return;
            }
            if (selectedParticipants.length === 1) {
                document.getElementById('pesquisaPessoa').value = selectedParticipants[0].name;
                loadParticipantProfile(selectedParticipants[0].id);
                document.getElementById('perfilPopup').style.display = 'flex';
            } else {
                openPairAnalysisPopup(selectedParticipants);
            }
        });
        designationDisplayContainer.appendChild(lupaIcon);

        const labIcon = document.createElement('i');
        labIcon.className = 'fas fa-flask lab-icon';
        labIcon.title = 'Laboratório de Combinações';
        labIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            openLabPopup(e.target.closest('.active-designation-container'));
        });
        designationDisplayContainer.appendChild(labIcon);
        
        // Carrega as opções de pessoas com base na preferência de género já definida
        await loadPeopleOptionsIntoSelects(designacao, designationDisplayContainer, {}, diasSemana, diaSemanaReuniaoString, generoPreferencia);
    }
    
    // PASSO 4 (REAPLICAR): Garante que as seleções são mantidas mesmo depois de as opções serem carregadas
    for (let designacaoInstance = 1; designacaoInstance <= quantity; designacaoInstance++) {
        const containerId = `active-designation-${designacaoId}-${designacaoInstance}`;
        const container = containerToUse.querySelector(`#${containerId}`);
        if (container && participantSelections[designacaoId] && participantSelections[designacaoId][designacaoInstance]) {
            const selects = container.querySelectorAll('.form-select');
            selects.forEach((select, i) => {
                const savedValue = participantSelections[designacaoId][designacaoInstance][i];
                if (savedValue) {
                    if (select.querySelector(`option[value="${savedValue}"]`)) {
                        select.value = savedValue;
                    }
                }
            });
        }
    }
};








            const updateLeituraBibliaDisplay = async (designacao, order, quantity, preferences = {}, diasSemana, diaSemanaReuniaoString) => { // ADD diaSemanaReuniaoString parameter
                updateActiveDesignationDisplay(designacao, order, quantity, preferences, diasSemana, diaSemanaReuniaoString, temporaryPreferences); // Reuse updateActiveDesignationDisplay for Leitura Bíblia, pass diaSemanaReuniaoString and temporaryPreferences
            };

            const removeLeituraBibliaDisplay = (designacaoId) => { // (já existente - manter)
                const displayToRemove = document.getElementById('leituraBibliaDesignationContainer').querySelector(`#active-designation-${designacaoId}`);
                if (displayToRemove) {
                    displayToRemove.remove();
                }
            };


            // Evento para fechar submenu de quantidade (keep as is) (já existente - manter)
            document.addEventListener('click', function(event) {
                if (!event.target.closest('.designacao-item')) {
                    document.querySelectorAll('.quantity-submenu.active').forEach(submenu => {
                        submenu.classList.remove('active');
                    });
                }
            });

            // --- Fetch horarios from Firebase (já existente - manter) ---
            async function getHorariosFromFirebase(ano) {
                try {
                    const horariosRef = db.collection('horarios');
                    const querySnapshot = await horariosRef
                        .where('ano', '==', ano)
                        .limit(1) // Assuming only one document per year
                        .get();

                    if (!querySnapshot.empty) {
                        const doc = querySnapshot.docs[0];
                        const data = doc.data();
                        return data;
                    } else {
                        return { 'dia-semana': null, 'hora-semana': null }; // Return default or null values if not found
                    }
                } catch (error) {
                    return { 'dia-semana': null, 'hora-semana': null }; // Return default or null values in case of error
                }
            }

            let temporaryPreferences = {}; // Objeto para guardar as preferências temporárias
let participantSelections = {};
let participationStatsCache = { ano: null, data: null };

            // Initial load of designacoes
            loadDesignacoes();
        });
    </script>

<script src="main.js"></script>


</body>
</html>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD1fkxq6USO5RX22TlsPQFEaVSZoTj_t2A",
            authDomain: "escalas-6e0f9.firebaseapp.com",
            projectId: "escalas-6e0f9",
            storageBucket: "escalas-6e0f9.firebasestorage.app",
            messagingSenderId: "19118998563",
            appId: "1:19118998563:web:5412be658ae34bd45add96"
        };

        // Initialize Firebase only if it's not already initialized
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
    </script>
    <style>

.lupa-icon {
    position: absolute;
    bottom: 10px;
    left: 70px; /* Ao lado do cadeado (que está em 40px) */
    cursor: pointer;
    color: #3498db; /* Azul */
    font-size: 16px;
    transition: all 0.3s ease;
}
.lupa-icon:hover {
    transform: scale(1.2) rotate(-10deg);
}

/* Estilos para o novo Popup de Análise de Par */
.analysis-popup .tabs {
    display: flex;
    border-bottom: 1px solid #ddd;
    margin-bottom: 15px;
}
.analysis-popup .tab-button {
    padding: 10px 15px;
    cursor: pointer;
    border: none;
    background-color: transparent;
    font-size: 16px;
    border-bottom: 3px solid transparent;
}
.analysis-popup .tab-button.active {
    border-bottom: 3px solid #3498db;
    font-weight: bold;
}
.analysis-popup .tab-content {
    display: none;
}
.analysis-popup .tab-content.active {
    display: block;
}

#validation-list {
    list-style: none;
    padding: 15px;
    margin: 0;
    max-height: 300px; /* Aumentado de 250px para 300px */
    overflow-y: auto;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            min-height: 100vh;
            background-color: #f5f6fa;
        }

        .sidebar {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 20px 0;
            height: 100vh;
            position: fixed;
        }

        .logo {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #34495e;
        }

        .nav-list {
            list-style: none;
            padding: 20px 0;
        }

        .nav-item {
            padding: 10px 20px;
        }

        .nav-item a {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
        }

        .nav-item:hover {
            background-color: #34495e;
        }

        .content {
            margin-left: 250px;
            padding: 30px;
            flex-grow: 1;
        }

        .card {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 600px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: bold;
        }

        .form-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            color: #2c3e50;
            background-color: white;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            padding: 4px 0;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .form-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52,152,219,0.3);
        }

        .btn-submit {
            background-color: #2ecc71;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            transition: all 0.3s ease;
        }

        .btn-submit:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        .designacoes-section {
            display: none;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        .designacoes-section.active {
            display: block;
        }

        .designacao-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 8px 16px;
            background-color: #f8f9fa;
            border-radius: 8px;
            min-height: 32px;
            position: relative;
            flex-direction: column;
            align-items: flex-start;
        }

        .filter-icon {
            position: absolute;
            bottom: 10px;
            left: 10px;
            cursor: pointer;
            color: #e67e22;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .filter-popup {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 200px;
        }

        .filter-popup.active {
            display: block;
        }

        .filter-popup h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .filter-popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            color: #2c3e50;
            margin-top: 8px;
        }

        .filter-icon:hover {
            color: #d35400;
            transform: rotate(15deg) scale(1.2);
        }

        .filter-popup {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 200px;
        }

        .filter-popup.active {
            display: block;
        }

        .designacao-item label {
            margin-bottom: 0;
            flex-grow: 1;
            font-size: 16px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .designacao-item label > span {
            flex-grow: 1;
            margin-left: 8px;
        }


        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            text-align: center;
        }

        /* Styles for order buttons */
        .order-button {
            background-color: #ddd;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            margin-right: 8px;
            color: #555;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .order-button.ordered {
            background-color: #2ecc71;
            color: white;
        }

        .order-button.ordered-level-2 {
            background-color: #3498db;
        }

        .order-button.ordered-level-3 {
            background-color: #f39c12;
        }

        .order-button.ordered-level-4 {
            background-color: #9b59b6;
        }

        .order-button.ordered-level-5 {
            background-color: #e74c3c;
        }

        .order-button.ordered-level-6 {
            background-color: #1abc9c;
        }

        .order-button.ordered-level-7 {
            background-color: #f1c40f;
        }

        .order-display {
            font-size: 14px;
            color: #777;
            margin-left: 4px;
        }

        /* Styles for quantity submenu */
        .quantity-submenu {
            position: relative;
            left: 0;
            top: auto;
            bottom: auto;
            transform: none;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            display: none;
            z-index: 10;
            margin-top: 5px;
        }


        .quantity-submenu.active {
            display: flex;
            gap: 5px;
        }

        .quantity-button {
            background-color: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background-color 0.3s ease;
        }

        .quantity-button.selected {
            background-color: #2ecc71;
            color: white;
        }

        .quantity-button:hover {
            background-color: #e0e0e0;
        }

        /* Styles for turbo button */
        .turbo-button-container {
        display: flex;
        justify-content: flex-end; /* Align to the right */
        margin-top: 10px;
        margin-bottom: 10px;
    }

    .turbo-button {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        transition: color 0.3s ease;
        margin-left: 10px; /* Add spacing between buttons */
    }

    .turbo-button:hover {
        color: #2980b9; /* Keep the hover effect */
    }

    .turbo-button[title*="Filtrar"] {
        transform-origin: center;
        transition: transform 0.3s ease, color, 0.3s ease;
    }

    .turbo-button[title*="Filtrar"]:hover {
        color: #e67e22;
        transform: rotate(15deg) scale(1.1);
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"] {
        transform-origin: center;
        transition: transform 0.3s ease, color, 0.3s ease;
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"]:hover {
        color: #27ae60;
        transform: translateY(-5px) scale(1.1);
        animation: rocket-shake 0.5s ease infinite;
    }

    @keyframes rocket-shake {
        0%, 100% { transform: translateY(-5px) rotate(0deg); }
        25% { transform: translateY(-5px) rotate(-2deg); }
        75% { transform: translateY(-5px) rotate(2deg); }
    }

    @keyframes rocket-loading {
        0% { transform: translateY(0) rotate(0deg); }
        15% { transform: translateY(0) rotate(-90deg); }
        30% { transform: translateY(0) rotate(-90deg); }
        50% { transform: translateY(-200px) rotate(-90deg); }
        70% { transform: translateY(-350px) rotate(-90deg); }
        90% { transform: translateY(-450px) rotate(-90deg); opacity: 0.3; }
        100% { transform: translateY(-500px) rotate(-90deg); opacity: 0; }
    }

    @keyframes rocket-return {
        0% { transform: translateY(-500px) rotate(180deg); opacity: 0; }
        20% { transform: translateY(-400px) rotate(180deg); opacity: 0.2; }
        40% { transform: translateY(-300px) rotate(180deg); opacity: 0.4; }
        60% { transform: translateY(-200px) rotate(180deg); opacity: 0.6; }
        80% { transform: translateY(-100px) rotate(180deg); opacity: 0.8; }
        90% { transform: translateY(-50px) rotate(180deg); opacity: 0.9; }
        100% { transform: translateY(0) rotate(180deg); opacity: 1; }
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"].loading {
        animation: rocket-loading 1s forwards;
    }

    .turbo-button[title*="Preencher Participantes Automaticamente"].returning {
        animation: rocket-return 1s forwards;
    }

    /* Initially hide Leitura da Bíblia section */
    #leituraBibliaSection {
        display: none; /* Initially hidden */
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #ddd;
    }

    /* Initially hide Iniciar Fluxo button */
    #fluxoSemanalForm button[type="submit"].btn-submit {
        display: none; /* Initially hidden */
    }

    /* Styles for the popup */
    .popup-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
        z-index: 1000; /* Ensure it's on top */
        justify-content: center;
        align-items: center;
    }

    .popup-content {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        width: 80%;
        max-width: 700px;
        position: relative; /* For close button positioning */
    }

    .popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
    }

    .popup-title {
        color: #2c3e50;
        font-size: 24px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .popup-title .status-icon {
        display: none;
        font-size: 20px;
    }

    .popup-title .status-icon.thinking {
        display: none;
        color: #3498db;
        animation: spin 2s linear infinite;
    }

    .popup-title .status-icon.success {
        display: none;
        color: #2ecc71;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .popup-close-button {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #777;
        position: absolute;
        top: 10px;
        right: 10px;
    }

    .popup-designation-list {
        margin-bottom: 20px;
    }

    .popup-designation-item {
        margin-bottom: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
    }

    .popup-designation-name {
        font-weight: bold;
        margin-bottom: 5px;
        color: #34495e;
    }

    .popup-participant-list {
        list-style: none;
        padding-left: 20px;
    }

    .popup-participant-item {
        margin-bottom: 3px;
        color: #555;
    }

    .popup-actions {
        text-align: right;
    }


/* Estilo para o dropdown inválido */
.form-select.invalid-selection {
    border: 2px solid #e74c3c; /* Vermelho forte */
    background-color: #fbeae5;
}

/* Container principal do alerta, fixo no canto inferior direito */
#validation-alert-container {
    position: fixed;
    bottom: 25px;
    right: 25px;
    z-index: 2000;
}

/* Ícone de perigo */
#validation-alert-icon {
    font-size: 36px;
    color: #e74c3c; /* Vermelho por defeito para erros críticos */
    cursor: pointer;
    background-color: white;
    border-radius: 50%;
    padding: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    transition: transform 0.2s ease, color 0.3s ease; /* Adiciona transição de cor */
}

#validation-alert-icon.warning-only {
    color: #f39c12; /* Laranja/Amarelo para avisos */
}

#validation-alert-icon:hover {
    transform: scale(1.1);
}

/* Painel que mostra os detalhes dos erros */
#validation-panel {
    display: none; /* Escondido por padrão */
    position: absolute;
    bottom: 0;
    right: 0;
    width: 350px;
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    overflow: hidden;
}

#validation-panel.active {
    display: block; /* Mostra o painel quando tem a classe 'active' */
}

#validation-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background-color: #34495e;
    color: white;
}

#validation-panel-header h3 {
    margin: 0;
    font-size: 16px;
}

#validation-panel-close {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    line-height: 1;
}

/* Lista de erros dentro do painel */
#validation-list {
    list-style: none;
    padding: 15px;
    margin: 0;
    max-height: 250px;
    overflow-y: auto;
}

#validation-list li {
    padding: 8px 0;
    border-bottom: 1px solid #eee;
    color: #333;
    font-size: 14px;
}

#validation-list li:last-child {
    border-bottom: none;
}


.lock-icon {
    position: absolute;
    bottom: 10px;
    left: 40px; /* Posicionado ao lado do ícone de filtro */
    cursor: pointer;
    color: #7f8c8d; /* Cor neutra para "desbloqueado" */
    font-size: 16px;
    transition: all 0.3s ease;
}

.lock-icon:hover {
    color: #34495e;
    transform: scale(1.2);
}

/* Este estilo será aplicado quando o cadeado estiver "fechado" */
.lock-icon.locked {
    color: #e67e22; /* Uma cor de destaque (laranja) para "bloqueado" */
}



.lab-icon {
    position: absolute;
    bottom: 10px;
    left: 100px; /* Ao lado da lupa (que está em 70px) */
    cursor: pointer;
    color: #9b59b6; /* Roxo */
    font-size: 16px;
    transition: all 0.3s ease;
}
.lab-icon:hover {
    transform: scale(1.2) rotate(10deg);
}

/* Estilos para o popup do laboratório */
.lab-popup .lab-container {
    display: flex;
    gap: 30px;
}
.lab-popup .lab-current-selection {
    flex: 1;
}
.lab-popup .lab-suggestions {
    flex: 1;
    border-left: 1px solid #eee;
    padding-left: 30px;
}
.lab-popup .suggestion-group h4 {
    margin-bottom: 10px;
}
.lab-popup .suggestion-item {
    padding: 8px;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 5px;
}
.lab-popup .suggestion-item:hover {
    background-color: #f1f1f1;
}
.lab-popup .suggestion-justification {
    font-size: 0.8em;
    color: #777;
    margin-left: 10px;
}

/* =================================================================== */
/* = CSS CORRETIVO PARA O POPUP "LABORATÓRIO DE COMBINAÇÕES" = */
/* =================================================================== */

/* 1. Transforma o corpo do popup do laboratório num container flexível */
.lab-popup .popup-body {
    display: flex;
    flex-direction: column;
    /* Evita que o próprio corpo tenha uma barra de rolagem */
    overflow: hidden; 
    /* Garante que o corpo se estique para preencher o espaço vertical */
    flex-grow: 1; 
}

/* 2. Faz com que APENAS a área das duas colunas (o .lab-container) cresça e role */
.lab-popup .lab-container {
    flex-grow: 1; /* Diz para esta área ocupar todo o espaço vertical que sobrar */
    overflow-y: auto; /* Adiciona a barra de rolagem vertical APENAS SE necessário */
    padding-right: 15px; /* Adiciona espaço para a barra de rolagem não sobrepor o conteúdo */
}

/* 3. Garante que a área de ações (o botão) nunca encolha e permaneça visível */
.lab-popup .popup-actions {
    flex-shrink: 0;
}


/* Alvo: Apenas os filtros dentro do popup de estatísticas */
#estatisticasPopup .estatisticas-filtros-container {
    gap: 15px; /* Reduz o espaçamento entre os filtros */
}

/* Alvo: As etiquetas (labels) dos filtros */
#estatisticasPopup .estatisticas-filtros-container label {
    font-size: 13px; /* Reduz o tamanho do texto da etiqueta */
    margin-bottom: 5px; /* Reduz o espaço abaixo da etiqueta */
}

/* Alvo: Os dropdowns (selects) dos filtros */
#estatisticasPopup .estatisticas-filtros-container select {
    font-size: 13px;       /* Reduz o tamanho do texto dentro do dropdown */
    padding: 6px 10px;     /* Reduz a altura do dropdown (preenchimento interno) */
    width: 160px;          /* Reduz a largura do dropdown */
}

.form-select.warning-selection {
    border: 2px solid #f39c12; /* Laranja/Amarelo */
    background-color: #fef9e7;
}

/* Estilo para o item de aviso na lista do painel */
#validation-list li.warning-item {
    color: #8a6d3b; /* Cor de texto mais escura para legibilidade */
    display: flex;
    align-items: center;
}

/* Ícone de aviso amarelo para a lista */
#validation-list li.warning-item::before {
    content: "\f071"; /* Ícone de triângulo de aviso do Font Awesome */
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    margin-right: 10px;
    color: #f39c12;
}

#validation-list li.error-item {
    color: #c0392b; /* Um vermelho um pouco mais escuro para o texto ser legível */
    font-weight: bold; /* Dar mais ênfase à mensagem de erro */
    display: flex;
    align-items: center;
}

/* Ícone de erro vermelho para a lista */
#validation-list li.error-item::before {
    content: "\f071"; /* Mesmo ícone de triângulo, mas agora vermelho */
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    margin-right: 10px;
    color: #e74c3c; /* Vermelho forte, igual à borda */
}

    </style>
</head>
<body>
   

    <!-- =================================================================== -->
<!-- =========== INÍCIO: POPUP LABORATÓRIO DE COMBINAÇÕES ============= -->
<!-- =================================================================== -->
<div id="labPopup" class="popup-overlay">
    <div class="popup-content lab-popup" style="max-width: 90%; width: 1000px;">
        <div class="popup-header">
            <h2 class="popup-title">Laboratório de Combinações</h2>
            <button class="popup-close-button" id="closeLabPopup">×</button>
        </div>
        <div class="popup-body">
            <div class="lab-container">
                <div class="lab-current-selection" id="labSelectionContainer">
                    <!-- A réplica dos dropdowns aparecerá aqui -->
                </div>
                <div class="lab-suggestions" id="labSuggestionsContainer">
                    <!-- As sugestões aparecerão aqui -->
                </div>
            </div>
            <div class="popup-actions" style="margin-top: 20px;">
                <button class="btn-submit" id="applyLabChanges">Aplicar Modificação</button>
            </div>
        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- ============ FIM: POPUP LABORATÓRIO DE COMBINAÇÕES ============== -->
<!-- =================================================================== -->

   <!-- =================================================================== -->
<!-- ============= INÍCIO: PAINEL DE ALERTA DE VALIDAÇÃO ============== -->
<!-- =================================================================== -->
<div id="validation-alert-container" style="display: none;">
    <i id="validation-alert-icon" class="fas fa-exclamation-triangle" title="Alertas de Validação"></i>
    <div id="validation-panel">
        <div id="validation-panel-header">
            <h3>Regras Violadas</h3>
            <button id="validation-panel-close">×</button>
        </div>
        <ul id="validation-list">
            <!-- As mensagens de erro serão inseridas aqui via JavaScript -->
        </ul>
    </div>
</div>
<!-- =================================================================== -->
<!-- ================ FIM: PAINEL DE ALERTA DE VALIDAÇÃO =============== -->
<!-- =================================================================== -->
   
   <!-- =================================================================== -->
<!-- ============= INÍCIO: POPUP DE ANÁLISE DE PAR/TRIO =============== -->


<!-- =================================================================== -->
<!-- =============== INÍCIO: POPUP DE CONFIRMAÇÃO MEMORIAL ============= -->
<!-- =================================================================== -->
<div id="memorialConfirmationPopup" class="popup-overlay">
    <div class="popup-content" style="max-width: 500px;">
        <div class="popup-header">
            <h2 class="popup-title">Aviso de Evento Especial</h2>
        </div>
        <div class="popup-body" style="padding: 20px 0;">
            <p id="memorialPopupMessage" style="text-align: center; font-size: 16px; line-height: 1.6;">
                A data do Memorial coincide com esta semana. Deseja gravar um evento especial sem designações e concluir?
            </p>
        </div>
        <div class="popup-actions" style="display: flex; justify-content: flex-end; gap: 10px;">
            <button class="btn-submit" id="confirmMemorialSave" style="background-color: #2ecc71;">Sim, Gravar</button>
            <button class="btn-submit" id="cancelMemorialSave" style="background-color: #c0392b;">Cancelar</button>
        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- ================ FIM: POPUP DE CONFIRMAÇÃO MEMORIAL =============== -->
<!-- =================================================================== -->






<!-- =================================================================== -->
<div id="pairAnalysisPopup" class="popup-overlay">
    <div class="popup-content analysis-popup" style="max-width: 90%; width: 1200px;">
        <div class="popup-header">
            <h2 class="popup-title" id="pairAnalysisTitle">Análise de Designação</h2>
            <button class="popup-close-button" id="closePairAnalysisPopup">×</button>
        </div>
        <div class="popup-body">
            <div id="pairAnalysisTabsContainer" class="tabs">
                <!-- As abas (tabs) serão inseridas aqui via JS -->
            </div>
            <div id="pairAnalysisContentContainer">
                <!-- O conteúdo de cada aba será inserido aqui via JS -->
            </div>
        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- =============== FIM: POPUP DE ANÁLISE DE PAR/TRIO ================= -->
<!-- =================================================================== -->

   
    <!-- =================================================================== -->
<!-- ============= INÍCIO: POPUP DE PERFIL DO PARTICIPANTE ============= -->
<!-- =================================================================== -->
<div id="perfilPopup" class="popup-overlay">
    <div class="popup-content" style="max-width: 90%; width: 1200px;">
        <div class="popup-header">
            <h2 class="popup-title">Perfil do Participante</h2>
            <button class="popup-close-button" id="closePerfilPopup">×</button>
        </div>
        <div class="popup-body">

            <!-- Caixa de Pesquisa -->
            <div class="form-group" style="position: relative;">
                <label for="pesquisaPessoa">Pesquisar Participante:</label>
                <input type="text" id="pesquisaPessoa" class="form-control" placeholder="Comece a digitar um nome..." autocomplete="off">
                <div id="pesquisaSugestoes" class="search-suggestions">
                    <!-- Sugestões de nomes aparecerão aqui -->
                </div>
            </div>

            <!-- Filtros -->
            <div id="perfilFiltrosContainer" class="estatisticas-filtros-container" style="display: none;">
                <div class="form-group">
                    <label for="perfilFiltroAno">Ano:</label>
                    <select id="perfilFiltroAno"></select>
                </div>
                <div class="form-group">
                    <label for="perfilFiltroMes">Mês:</label>
                    <select id="perfilFiltroMes">
                        <option value="">Todos</option>
                        <option value="1">Janeiro</option>
                        <option value="2">Fevereiro</option>
                        <option value="3">Março</option>
                        <option value="4">Abril</option>
                        <option value="5">Maio</option>
                        <option value="6">Junho</option>
                        <option value="7">Julho</option>
                        <option value="8">Agosto</option>
                        <option value="9">Setembro</option>
                        <option value="10">Outubro</option>
                        <option value="11">Novembro</option>
                        <option value="12">Dezembro</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="perfilFiltroDesignacao">Designação:</label>
                    <select id="perfilFiltroDesignacao"></select>
                </div>
                <div class="form-group">
                    <label for="perfilFiltroPapel">Meu Papel:</label>
                    <select id="perfilFiltroPapel">
                        <option value="">Todos</option>
                        <option value="dirigente">Dirigente</option>
                        <option value="morador">Morador</option>
                        <option value="ajudante">Ajudante</option>
                        <option value="participante">Participante</option>
                    </select>
                </div>
            </div>

            <!-- Tabela de Histórico -->
            <div id="perfilLoading" style="text-align: center; padding: 40px; font-size: 18px; display: none;">
                <i class="fas fa-spinner fa-spin"></i> A carregar histórico...
            </div>
            <div id="perfilTableContainer" style="overflow-x: auto; max-height: 55vh; display: none;">
                <table class="estatisticas-table">
                    <thead>
                        <tr>
                            <th>Ano</th>
                            <th>Data</th>
                            <th>Designação</th>
                            <th>Companheiro(s)</th>
                            <th>Meu Papel</th>
                        </tr>
                    </thead>
                    <tbody id="perfilTableBody">
                        <!-- Linhas do histórico serão inseridas aqui -->
                    </tbody>
                </table>
            </div>

        </div>
    </div>
</div>
<!-- =================================================================== -->
<!-- ================ FIM: POPUP DE PERFIL DO PARTICIPANTE =============== -->
<!-- =================================================================== -->
    <!-- Statistics Popup Overlay -->
<div id="estatisticasPopup" class="popup-overlay">
    <div class="popup-content" style="max-width: 90%; width: 1200px;">
        <div class="popup-header">
            <h2 class="popup-title">Estatísticas de Participação</h2>
            <button class="popup-close-button" id="closeEstatisticasPopup">×</button>
        </div>
        <div class="popup-body">

            <!-- 1. Abas de Navegação -->
            <div class="tabs">
                <button class="tab-button active" data-tab="geral">Geral</button>
                <button class="tab-button" data-tab="maisMenos">Mais/Menos</button>
                <button class="tab-button" data-tab="menosDetalhado">Menos (detalhado)</button>
                <button class="tab-button" data-tab="nunca">Nunca</button>
                <button class="tab-button" data-tab="dirigentes">Dirigentes</button>
            </div>

            <!-- 2. Conteúdo das Abas -->
            <div class="tab-content-container">

                <!-- Aba 1: Geral (ESTRUTURA CORRIGIDA) -->
                <div id="tab-content-geral" class="tab-content active">
                    
      <div id="estatisticasFiltros" class="estatisticas-filtros-container">
    <div class="form-group">
        <label for="filtroAno">Ano:</label>
        <select id="filtroAno" name="filtroAno"></select>
    </div>
    <div class="form-group">
        <label for="filtroMes">Mês:</label>
        <select id="filtroMes" name="filtroMes">
            <option value="">Todos os Meses</option>
            <option value="1">Janeiro</option><option value="2">Fevereiro</option><option value="3">Março</option><option value="4">Abril</option><option value="5">Maio</option><option value="6">Junho</option><option value="7">Julho</option><option value="8">Agosto</option><option value="9">Setembro</option><option value="10">Outubro</option><option value="11">Novembro</option><option value="12">Dezembro</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroGenero">Género:</label>
        <select id="filtroGenero" name="filtroGenero">
            <option value="">Todos os Géneros</option>
            <option value="Masculino">Masculino</option>
            <option value="Feminino">Feminino</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroIdioma">Idioma:</label>
        <select id="filtroIdioma" name="filtroIdioma">
            <option value="">Todos os Idiomas</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroParte">Parte:</label>
        <select id="filtroParte" name="filtroParte">
            <option value="">Todas as Partes</option>
            <option value="escola" selected>Escola</option>
            <option value="resto da semana">Resto da Semana</option>
        </select>
    </div>
    <div class="form-group">
        <label for="filtroDesignacaoGeral">Designação:</label>
        <!-- ALTERAÇÃO AQUI: O select começa vazio -->
        <select id="filtroDesignacaoGeral" name="filtroDesignacaoGeral">
            <!-- As opções serão totalmente geradas pelo JavaScript -->
        </select>
    </div>
</div>


                    <div id="estatisticasLoading" style="text-align: center; padding: 40px; font-size: 18px;">
                        <i class="fas fa-spinner fa-spin"></i> A carregar estatísticas...
                    </div>
                    <div id="estatisticasTableContainer">
                        <!-- A tabela de estatísticas original será gerada aqui -->
                    </div>

                </div>

                <!-- Aba 2: Mais/Menos -->
                <div id="tab-content-maisMenos" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

                <!-- Aba 3: Menos (detalhado) -->
                <div id="tab-content-menosDetalhado" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

                <!-- Aba 4: Nunca -->
                <div id="tab-content-nunca" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

                <!-- Aba 5: Dirigentes -->
                <div id="tab-content-dirigentes" class="tab-content">
                    <!-- O conteúdo desta aba será gerado via JS -->
                </div>

            </div>
        </div>
    </div>
</div>


     <div id="sidebar-placeholder"></div>

    <main class="content">
        <style>

            /* =================================================================== */
/* ============= CSS PARA SUGESTÕES DE PESQUISA DE PERFIL ============ */
/* =================================================================== */
.search-suggestions {
    display: none; /* Escondido por padrão */
    position: absolute;
    border: 1px solid #ddd;
    border-top: none;
    background-color: white;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    z-index: 2000; /* Deve ficar sobre os outros elementos */
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.suggestion-item {
    padding: 10px;
    cursor: pointer;
}

.suggestion-item:hover {
    background-color: #f1f1f1;
}

/* Garante que o input do formulário tenha a classe para aplicar estilos */
#pesquisaPessoa {
    width: 100%;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
}

            .week-info {
                margin-bottom: 20px;
                padding: 15px;
                background-color: #f8f9fa;
                border-radius: 4px;
                border: 1px solid #e9ecef;
            }
            .week-info p {
                margin: 0;
                color: #2c3e50;
                font-size: 16px;
                text-align: center;
                line-height: 1.5em;
            }
                    /* Styles for Statistics Table */


        .estatisticas-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }

        .estatisticas-table th,
        .estatisticas-table td {
            border: 1px solid #ddd;
            padding: 10px 12px;
            text-align: left;
        }

        .estatisticas-table thead th {
            background-color: #34495e;
            color: white;
            z-index: 10;
        }
        
        .estatisticas-table thead th:first-child {
            min-width: 200px;
        }

        .estatisticas-table tbody tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .estatisticas-table tbody tr:hover {
            background-color: #e9ecef;
        }
        
        .estatisticas-table td:not(:first-child) {
            text-align: center;
        }

    .estatisticas-filtros-container {
    display: flex;
    flex-wrap: wrap; /* <-- ADICIONE ESTA LINHA */
    gap: 20px;
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
    align-items: flex-end;
}

        .estatisticas-filtros-container .form-group {
            margin-bottom: 0;
        }

        .estatisticas-filtros-container select {
            width: 180px; /* Largura fixa para os selects */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }


/* 1. Trava o scroll da página de fundo */
body.popup-open {
    overflow: hidden;
}

/* 2. Define a estrutura do popup: um cabeçalho fixo e um corpo que cresce */
#estatisticasPopup .popup-content {
    display: flex;
    flex-direction: column;
    max-height: 90vh;
}

/* 3. Garante que o cabeçalho do popup não encolha */
#estatisticasPopup .popup-header {
    flex-shrink: 0;
}

/* 4. A MÁGICA: O corpo do popup é a área de scroll */
#estatisticasPopup .popup-body {
    flex-grow: 1;       /* Ocupa todo o espaço vertical restante */
    overflow-y: auto;   /* Adiciona a barra de rolagem AQUI */
    padding: 15px;      /* Adiciona algum espaçamento interno para o conteúdo */
}

/* 5. Garante que o container da tabela NÃO tenha scroll ou altura limitada */
#estatisticasTableContainer {
    max-height: none;
    overflow: visible;
}

/* 6. IMPORTANTE: Garante que o cabeçalho da tabela NÃO seja 'sticky' para evitar conflitos */
.estatisticas-table thead th {
   position: static; /* Ou simplesmente remova qualquer regra 'position: sticky' */
}


.tabs {
    display: flex;
    border-bottom: 2px solid #ddd;
    margin-bottom: 20px;
}

/* Botão de cada aba */
.tab-button {
    padding: 12px 20px;
    cursor: pointer;
    border: none;
    background-color: transparent;
    font-size: 16px;
    color: #555;
    position: relative;
    top: 2px; /* Alinha com a borda inferior */
    border-bottom: 2px solid transparent;
}

.tab-button:hover {
    background-color: #f5f5f5;
    color: #333;
}

/* Estilo da aba ativa */
.tab-button.active {
    border-bottom: 2px solid #3498db;
    font-weight: bold;
    color: #3498db;
}

/* Container do conteúdo das abas */
.tab-content-container {
    padding-top: 10px;
}

/* Esconde as abas inativas */
.tab-content {
    display: none;
}

/* Mostra a aba ativa */
.tab-content.active {
    display: block;
}

/* Estilos para as colunas da aba "Mais/Menos" */
.mais-menos-container {
    display: flex;
    gap: 20px;
    justify-content: space-around;
}

.rank-column {
    flex: 1;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
}
.rank-column h4 {
    text-align: center;
    margin-top: 0;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}
.rank-column ol {
    padding-left: 20px;
    margin: 0;
}
.rank-column ol li {
    padding: 8px 5px;
    font-size: 15px;
}
.rank-column ol li:nth-child(odd) {
    background-color: #f9f9f9;
}

/* Cores específicas para cada coluna */
.col-mais { background-color: rgba(46, 204, 113, 0.08); border-left: 4px solid #2ecc71; }
.col-menos { background-color: rgba(231, 76, 60, 0.08); border-left: 4px solid #e74c3c; }
.col-antiga { background-color: rgba(243, 156, 18, 0.08); border-left: 4px solid #f39c12; }

/* Classe para destacar valores baixos na aba "Dirigentes" */
.low-participation {
    color: #e74c3c;
    font-weight: bold;
}



        </style>

        <div class="card">
            <h1>Iniciar Fluxo Escola</h1>
            <div class="week-info">
                <p id="weekDisplay">Carregando informações da semana...</p>
            </div>
            <form id="fluxoSemanalForm">
                <input type="hidden" id="semanaNumero" name="semanaNumero">
                <div class="form-group">
                    <label for="mes">Mês:</label>
                    <select id="mes" name="mes" required>
                        <option value="1">Janeiro</option>
                        <option value="2">Fevereiro</option>
                        <option value="3">Março</option>
                        <option value="4">Abril</option>
                        <option value="5">Maio</option>
                        <option value="6">Junho</option>
                        <option value="7">Julho</option>
                        <option value="8">Agosto</option>
                        <option value="9">Setembro</option>
                        <option value="10">Outubro</option>
                        <option value="11">Novembro</option>
                        <option value="12">Dezembro</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="tipo">Tipo de Reunião:</label>
                    <select id="tipo" name="tipo" required>
                        <option value="normal">Normal</option>
                        <option value="memorial">Memorial</option>
                        <option value="assembleia">Assembleia</option>
                        <option value="congresso">Congresso</option>
                        <option value="visita-servo">Visita do Servo</option>
                        <option value="evento-especial">Evento Especial</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Com Grupo?</label>
                    <div class="checkbox-group" id="nacionalidades">
                        <!-- Nacionalidades will be loaded here -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="sala">Sala:</label>
                    <select id="sala" name="sala" required>
                        <option value="salao-principal" selected>Salão Principal</option>
                        <option value="segunda-sala">Segunda Sala</option>
                        <option value="terceira-sala">Terceira Sala</option>
                    </select>
                </div>
                <button type="button" class="btn-submit" id="btnSeguinte">Seguinte</button>

                <div id="designacoesSection" class="designacoes-section">
                    <h4>Designações</h4>
                    <div id="designacoesList">
                        <!-- Designações will be loaded here -->
                    </div>
                    <div id="turboButtonContainer" class="turbo-button-container">
                        <button id="turboButton" class="turbo-button" type="button" title="Preencher Participantes Automaticamente" style="color: #2ecc71;">
                            <i class="fas fa-rocket"></i>
                        </button>
                        <button id="estatisticasButton" class="turbo-button" type="button" title="Estatísticas" style="color: #3498db;">
                            <i class="fas fa-chart-bar"></i>
                        </button>
                        <button id="pesquisarButton" class="turbo-button" type="button" title="Pesquisar (Futuro)" style="color: #f39c12;">
                            <i class="fas fa-search"></i>
                        </button>
                        <button id="perfilButton" class="turbo-button" type="button" title="Perfil do Participante (Futuro)" style="color: #9b59b6;">
                            <i class="fas fa-user"></i>
                        </button>
                    </div>

                <div id="leituraBibliaSection" class="designacoes-section">
                    <h4>Leitura da Bíblia - Participantes</h4>
                    <div id="leituraBibliaDesignationContainer">
                        <!-- Participant selections for Leitura da Bíblia will load here -->
                    </div>
                </div>

                <div id="activeDesignationsContainer">
                    <!-- Active designation participant selections will be loaded here -->
                </div>

                <button type="submit" class="btn-submit" style="margin-top: 20px;">Iniciar Fluxo</button>
            </form>
        </div>

        <!-- Confirmation Popup Overlay -->
        <div id="confirmationPopup" class="popup-overlay">
            <div class="popup-content">
                <div class="popup-header">
                    <div class="popup-title">
                        <h2>Criar Fluxo Escola</h2>
                        <i class="fas fa-cog status-icon thinking"></i>
                        <i class="fas fa-check-circle status-icon success"></i>
                    </div>
                    <button class="popup-close-button" id="closePopup">×</button>
                </div>
                <div class="popup-body">
                    <div id="popupDesignationSummary" class="popup-designation-list">
                        <!-- Designation summary will be loaded here -->
                    </div>
                </div>
                <div class="popup-actions">
                    <button class="btn-submit" id="createFluxoSemanal">Criar Fluxo Escola</button>
                </div>
            </div>
        </div>


    <script>
        
        document.addEventListener('DOMContentLoaded', function() {
        
            // Firebase configuration
            const firebaseConfig = {
                apiKey: "AIzaSyD1fkxq6USO5RX22TlsPQFEaVSZoTj_t2A",
                authDomain: "escalas-6e0f9.firebaseapp.com",
                projectId: "escalas-6e0f9",
                storageBucket: "escalas-6e0f9.firebasestorage.app",
                messagingSenderId: "19118998563",
                appId: "1:19118998563:web:5412be658ae34bd45add96"
            };

            

            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
            const db = firebase.firestore();

            // Set current month as default
            const currentMonth = new Date().getMonth() + 1;
            document.getElementById('mes').value = currentMonth;


 // ======================================================================== //
// ============ INÍCIO: LÓGICA DE SINCRONIZAÇÃO DE GÊNERO  ============== //
// ======================================================================== //

const handleGenderSync = (changedSelect) => {
    const instanceContainer = changedSelect.closest('.designacao-instance-container');
    if (!instanceContainer) return;

    // --- INÍCIO DA LÓGICA DO NOVO FILTRO ---
    // Primeiro, vamos encontrar o seletor do nosso novo filtro
    const mainContainer = changedSelect.closest('.active-designation-container');
    const genderMixSelect = mainContainer.querySelector('.gender-mix-select');

    // Verificamos o valor do filtro. Se for 'sim', o trabalho desta função muda.
    if (genderMixSelect && genderMixSelect.value === 'sim') {
        // Se a regra é "Sim", devemos garantir que NENHUM filtro de género está ativo.
        // Iremos percorrer todos os dropdowns e mostrar TODAS as opções.
        const allSelectsInInstance = instanceContainer.querySelectorAll('.form-select');
        allSelectsInInstance.forEach(select => {
            Array.from(select.options).forEach(option => {
                option.style.display = ''; // Mostra todas as opções
            });
        });
        return; // IMPORTANTE: Pára a execução da função aqui para não aplicar o bloqueio de género.
    }
    // --- FIM DA LÓGICA DO NOVO FILTRO ---

    // O código original abaixo só será executado se o filtro for "Não" (o comportamento padrão).
    const allSelectsInInstance = instanceContainer.querySelectorAll('.form-select');
    const selectedPersonId = changedSelect.value;

    if (!selectedPersonId) {
        allSelectsInInstance.forEach(select => {
            Array.from(select.options).forEach(option => {
                option.style.display = ''; 
            });
        });
        // Quando um campo é limpo, revalida as seleções restantes
        allSelectsInInstance.forEach(select => {
            if (select.value) handleGenderSync(select);
        });
        return;
    }

    const personData = allPeopleDataMap.get(selectedPersonId);
    if (!personData || !personData.genero) return;

    const requiredGender = personData.genero;

    allSelectsInInstance.forEach(select => {
        if (select !== changedSelect && select.value) {
            const otherPersonData = allPeopleDataMap.get(select.value);
            if (!otherPersonData || otherPersonData.genero !== requiredGender) {
                select.value = ''; 
            }
        }
        
        Array.from(select.options).forEach(option => {
            if (!option.value) {
                option.style.display = '';
                return;
            }
            const optionPersonData = allPeopleDataMap.get(option.value);
            if (optionPersonData && optionPersonData.genero === requiredGender) {
                option.style.display = '';
            } else {
                option.style.display = 'none';
            }
        });
    });
};

document.body.addEventListener('change', (event) => {
    if (event.target.classList.contains('form-select')) {
        handleGenderSync(event.target);
    }
});

// ======================================================================== //
// ============= FIM: LÓGICA DE SINCRONIZAÇÃO DE GÊNERO  =============== //
// ======================================================================== //



// ======================================================================== //
// ============ INÍCIO: LÓGICA DE VALIDAÇÃO EM TEMPO REAL (v2) ============ //
// ======================================================================== //

// --- FUNÇÃO AUXILIAR MODIFICADA para obter pares, papéis e datas ---
const getRecentPairs = async () => {
    // Aumentamos a janela para 12 meses para ter um histórico mais robusto
    const RECENT_MONTHS_WINDOW = 12;
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - RECENT_MONTHS_WINDOW);
    
    const recentPairsMap = new Map();
    const historicoRef = db.collection('historico');

    const q = historicoRef.where("timestamp", ">=", startDate);
    const snapshot = await q.get();

    snapshot.forEach(doc => {
        const historico = doc.data();
        if (historico.designacoes) {
            historico.designacoes.forEach(desig => {
                if (desig.participantes && Object.keys(desig.participantes).length >= 2) {
                    const ids = Object.values(desig.participantes);
                    const pairKey = ids.sort().join('_'); // Chave canónica do par

                    const rolesEntries = Object.entries(desig.participantes).sort((a, b) => a[1].localeCompare(b[1]));
                    const rolesKey = rolesEntries.map(([role, id]) => `${id}:${role}`).join('_');

                    if (!recentPairsMap.has(pairKey) || new Date(historico.dia) > new Date(recentPairsMap.get(pairKey).lastDate)) {
                        recentPairsMap.set(pairKey, {
                            lastDate: historico.dia,
                            lastRoles: rolesKey
                        });
                    }
                }
            });
        }
    });
    // LOG ADICIONADO
    console.log("[VALIDATION] -> DADOS (Pares Recentes):", recentPairsMap);
    return recentPairsMap;
};


// --- Função principal que valida TODAS as seleções na página (COM LOGS) ---
const validateAllSelections = async () => {
    console.log("[VALIDATION] 🚀 Função validateAllSelections iniciada.");

    const alertContainer = document.getElementById('validation-alert-container');
    const alertIcon = document.getElementById('validation-alert-icon');
    const validationList = document.getElementById('validation-list');

    // Limpa estilos antigos
    document.querySelectorAll('.form-select.invalid-selection, .form-select.warning-selection').forEach(el => {
        el.classList.remove('invalid-selection', 'warning-selection');
    });
    validationList.innerHTML = '';
    let allViolations = [];

    const ano = await getAnoPainelFirebase();
    const mes = parseInt(document.getElementById('mes').value);
    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);

    // --- OBTENÇÃO DOS DADOS ---
    const [participantsLastWeek, participantsNextWeek, recentPairsMap, participationStats] = await Promise.all([
        getParticipantsLastWeek(ano, mes, semanaNumero),
        getParticipantsNextWeek(ano, mes, semanaNumero),
        getRecentPairs(),
        getParticipationStatsForYear(ano)
    ]);

    // --- VERIFICAÇÕES INDIVIDUAIS ---
    const allSelects = document.querySelectorAll('#activeDesignationsContainer .form-select, #leituraBibliaDesignationContainer .form-select');
    const currentSelections = new Map();

    allSelects.forEach(select => {
        if (select.value) {
            const personId = select.value;
            const personName = select.options[select.selectedIndex].text;
            let hasRedError = false;

            if (currentSelections.has(personId)) {
                allViolations.push({ message: `${personName} está designado para mais de uma tarefa nesta semana.`, type: 'error' });
                select.classList.add('invalid-selection');
                currentSelections.get(personId).selectElement.classList.add('invalid-selection');
                hasRedError = true;
            } else {
                currentSelections.set(personId, { selectElement: select, name: personName });
            }
            if (participantsLastWeek.has(personId)) {
                allViolations.push({ message: `${personName} participou na semana anterior.`, type: 'error' });
                select.classList.add('invalid-selection');
                hasRedError = true;
            }
            if (participantsNextWeek.has(personId)) {
                allViolations.push({ message: `${personName} já está designado(a) para a semana seguinte.`, type: 'error' });
                select.classList.add('invalid-selection');
                hasRedError = true;
            }

            if (!hasRedError) {
                const designacaoId = select.closest('.active-designation-container')?.dataset.designacaoId;
                if (designacaoId && participationStats.has(designacaoId)) {
                    const statsForDesignation = participationStats.get(designacaoId);
                    const personCount = statsForDesignation.counts.get(personId) || 0;
                    const average = statsForDesignation.average;
                    if (personCount > average && average > 0) {
                        const violationMessage = `${personName} já realizou esta designação ${personCount} vez(es) este ano (acima da média de ${average.toFixed(1)}).`;
                        allViolations.push({ message: violationMessage, type: 'warning' });
                        select.classList.add('warning-selection');
                    }
                }
            }
        }
    });

    // --- VERIFICAÇÃO DE PARES ---
    document.querySelectorAll('#activeDesignationsContainer .designacao-instance-container, #leituraBibliaDesignationContainer .designacao-instance-container').forEach(instance => {
        const selectedPeople = [];
        const currentRoles = {};
        instance.querySelectorAll('.form-select').forEach((select, index) => {
            if (select.value) {
                const personId = select.value;
                const role = (index === 0) ? 'dirigente' : (index === 1) ? 'morador' : 'ajudante';
                currentRoles[role] = personId;
                selectedPeople.push({ id: personId, name: select.options[select.selectedIndex].text, element: select });
            }
        });
        if (selectedPeople.length >= 2) {
            const pairNames = selectedPeople.map(p => p.name).join(' e ');
            const ids = selectedPeople.map(p => p.id).sort();
            const pairKey = ids.join('_');
            const currentRolesEntries = Object.entries(currentRoles).sort((a, b) => a[1].localeCompare(b[1]));
            const currentRolesKey = currentRolesEntries.map(([role, id]) => `${id}:${role}`).join('_');
            if (recentPairsMap.has(pairKey)) {
                const history = recentPairsMap.get(pairKey);
                const lastDate = new Date(history.lastDate);
                const lastMonthYear = lastDate.getFullYear() * 12 + lastDate.getMonth();
                const currentMonthYear = new Date().getFullYear() * 12 + new Date().getMonth();
                if (Math.abs(currentMonthYear - lastMonthYear) <= 1) {
                    allViolations.push({ message: `${pairNames} trabalharam juntos no mês passado ou neste mês.`, type: 'error' });
                    selectedPeople.forEach(p => p.element.classList.add('invalid-selection'));
                } else if (history.lastRoles === currentRolesKey) {
                    const hasRedErrorAlready = selectedPeople.some(p => p.element.classList.contains('invalid-selection'));
                    if (!hasRedErrorAlready) {
                         allViolations.push({ message: `Aviso: ${pairNames} já fizeram esta parte com os mesmos papéis.`, type: 'warning' });
                        selectedPeople.forEach(p => p.element.classList.add('warning-selection'));
                    }
                }
            }
        }
    });

    // --- ATUALIZAR A UI ---
    if (allViolations.length > 0) {
        const hasErrors = allViolations.some(v => v.type === 'error');
        alertIcon.classList.remove('warning-only');
        if (!hasErrors) {
            alertIcon.classList.add('warning-only');
        }

        const uniqueViolations = Array.from(new Set(allViolations.map(v => v.message)))
                                     .map(message => allViolations.find(v => v.message === message));
        
        // ==========================================================
        // ============== INÍCIO DA MODIFICAÇÃO AQUI ================
        // ==========================================================
        uniqueViolations.forEach(violation => {
            const li = document.createElement('li');
            li.textContent = violation.message;
            
            // Adiciona a classe correta com base no tipo de violação
            if (violation.type === 'warning') {
                li.classList.add('warning-item');
            } else if (violation.type === 'error') {
                li.classList.add('error-item');
            }
            
            validationList.appendChild(li);
        });
        // ==========================================================
        // ================ FIM DA MODIFICAÇÃO AQUI =================
        // ==========================================================

        alertContainer.style.display = 'block';
    } else {
        alertContainer.style.display = 'none';
        document.getElementById('validation-panel').classList.remove('active');
    }
};



// Helper para obter a data da reunião (pode precisar de uma versão melhorada)
function getMeetingDayOfMonth(diasSemanaString, diaSemanaReuniao) {
    if (!diasSemanaString || !diaSemanaReuniao) return new Date(); // Fallback
    const [startDay] = diasSemanaString.split(' ')[0].split('-');
    return new Date(new Date().getFullYear(), new Date().getMonth(), parseInt(startDay));
}














// --- Event Listeners ---

// Usar delegação de eventos para ouvir alterações em qualquer dropdown de participante
document.body.addEventListener('change', (event) => {
    if (event.target.classList.contains('form-select')) {
        validateAllSelections();
    }
});

// Adicionar um ouvinte para o botão de foguete para validar após o preenchimento automático
document.getElementById('turboButton').addEventListener('click', () => {
    // Adiciona um pequeno atraso para garantir que os valores do select foram atualizados antes da validação
    setTimeout(validateAllSelections, 500); 
});


// Lógica para mostrar/esconder o painel de validação
const validationIcon = document.getElementById('validation-alert-icon');
const validationPanel = document.getElementById('validation-panel');
const validationPanelClose = document.getElementById('validation-panel-close');

validationIcon.addEventListener('click', () => {
    validationPanel.classList.toggle('active');
});

validationPanelClose.addEventListener('click', () => {
    validationPanel.classList.remove('active');
});

// Fechar o painel se clicar fora dele
document.addEventListener('click', (event) => {
    if (!validationPanel.contains(event.target) && !validationIcon.contains(event.target)) {
        validationPanel.classList.remove('active');
    }
});

            
           // --- INÍCIO: NOVA LÓGICA DO POPUP DE ESTATÍSTICAS COM ABAS ---

const estatisticasButton = document.getElementById('estatisticasButton');
const estatisticasPopup = document.getElementById('estatisticasPopup');
const closeEstatisticasPopup = document.getElementById('closeEstatisticasPopup');


let allYearsCache = []; // Cache para os anos, para não buscar no DB toda hora
let allLanguagesCache = []; // Cache para evitar buscas repetidas ao DB

// Função auxiliar para popular dropdowns de ano
const populateYearFilter = async (selectElement) => {
    if (allYearsCache.length === 0) {
        try {
            const historicoSnapshot = await db.collection('historico').get();
            const years = new Set();
            historicoSnapshot.forEach(doc => {
                if (doc.data().ano) {
                    years.add(doc.data().ano);
                }
            });
            allYearsCache = Array.from(years).sort((a, b) => b - a);
        } catch (error) {
            console.error("Erro ao popular filtro de anos:", error);
            return;
        }
    }

    const currentYear = new Date().getFullYear();
    selectElement.innerHTML = '';
    allYearsCache.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (parseInt(year) === currentYear) {
            option.selected = true;
        }
        selectElement.appendChild(option);
    });
};

// Função auxiliar para popular dropdowns de idioma
const populateLanguageFilter = async (selectElement) => {
    if (allLanguagesCache.length === 0) {
        try {
            const nacionalidadesSnapshot = await db.collection('nacionalidades').orderBy('nome').get();
            nacionalidadesSnapshot.forEach(doc => {
                allLanguagesCache.push(doc.data().nome);
            });
        } catch (error) {
            console.error("Erro ao popular filtro de idiomas:", error);
            return;
        }
    }

    const firstOption = selectElement.options[0];
    selectElement.innerHTML = '';
    if (firstOption) {
       selectElement.appendChild(firstOption);
    }

    allLanguagesCache.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang;
        option.textContent = lang;
        selectElement.appendChild(option);
    });
};


// --- Lógica Principal de Abertura do Popup e Gestão de Abas ---
estatisticasButton.addEventListener('click', async () => {
    estatisticasPopup.style.display = 'flex';
    document.body.classList.add('popup-open');

    // Ativa a primeira aba por defeito e carrega seu conteúdo
    if (!document.querySelector('.tab-button.active')) {
        document.querySelector('.tab-button[data-tab="geral"]').classList.add('active');
        document.querySelector('#tab-content-geral').classList.add('active');
    }

    const activeTab = document.querySelector('.tab-button.active').dataset.tab;
    loadTabData(activeTab); // Carrega os dados da aba ativa

    // Configura o listener para trocar de aba
    setupTabListeners();
});

const setupTabListeners = () => {
    const tabs = document.querySelectorAll('.tab-button');
    tabs.forEach(tab => {
        // Remove event listener antigo para evitar duplicação
        tab.replaceWith(tab.cloneNode(true));
    });

    // Adiciona o novo listener
    document.querySelectorAll('.tab-button').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const tabName = e.target.dataset.tab;
            
            document.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            e.target.classList.add('active');
            document.getElementById(`tab-content-${tabName}`).classList.add('active');

            loadTabData(tabName);
        });
    });
};

const loadTabData = (tabName) => {
    const contentArea = document.getElementById(`tab-content-${tabName}`);
    // Se a aba já foi carregada, não faz nada
    if (contentArea.dataset.loaded === 'true' && tabName !== 'geral') {
        return;
    }

   if (tabName !== 'geral') {
        contentArea.innerHTML = `<div style="text-align: center; padding: 40px; font-size: 18px;"><i class="fas fa-spinner fa-spin"></i> A carregar dados...</div>`;
    }

    switch (tabName) {
        case 'geral':
            loadGeralTab();
            break;
        case 'maisMenos':
            loadMaisMenosTab();
            break;
        case 'menosDetalhado':
            loadMenosDetalhadoTab();
            break;
        case 'nunca':
            loadNuncaTab();
            break;
        case 'dirigentes':
            loadDirigentesTab();
            break;
    }
    contentArea.dataset.loaded = 'true';
};

closeEstatisticasPopup.addEventListener('click', () => {
    estatisticasPopup.style.display = 'none';
    document.body.classList.remove('popup-open');
});


// --- Funções de Carregamento para cada Aba ---

// Aba 1: GERAL (Funcionalidade antiga)
const loadGeralTab = async () => {
    const contentArea = document.getElementById('tab-content-geral');
    
    const populateDesignationFilter = async () => {
        // ... (código interno desta função não muda) ...
        console.log("--- populateDesignationFilter INICIADA ---");
        const filtroDesignacao = document.getElementById('filtroDesignacaoGeral');
        const parteSelecionada = document.getElementById('filtroParte').value;
        filtroDesignacao.innerHTML = '<option value="">Todas as Designações</option>';
        try {
            let query = db.collection('designacoes').where('tipo', '==', 'reuniao').where('quando', '==', 'Semana');
            if (parteSelecionada) {
                query = query.where('parte', '==', parteSelecionada);
            }
            const designacoesSnapshot = await query.orderBy('ordem').get();
            designacoesSnapshot.forEach(doc => {
                const desig = doc.data();
                const option = document.createElement('option');
                option.value = doc.id;
                option.textContent = desig.nome;
                filtroDesignacao.appendChild(option);
            });
            console.log("--- populateDesignationFilter FINALIZADA ---");
        } catch (error) {
            console.error("Erro ao popular filtro de designações dinâmico:", error);
        }
    };





    
    // *** INÍCIO DA NOVA LÓGICA: Popula o filtro de designação ***
    const filtroDesignacao = document.getElementById('filtroDesignacaoGeral');
if (filtroDesignacao.options.length <= 1) {
        try {
            const designacoesSnapshot = await db.collection('designacoes').where('quando', '==', 'Semana').orderBy('nome').get();
            designacoesSnapshot.forEach(doc => {
                const desig = doc.data();
                const option = document.createElement('option');
                option.value = doc.id; // O valor é o ID do documento
                option.textContent = desig.nome;
                filtroDesignacao.appendChild(option);
            });
        } catch (error) {
            console.error("Erro ao popular filtro de designações:", error);
        }
    }
    // *** FIM DA NOVA LÓGICA ***

    // Adiciona os listeners se ainda não existirem
  if(!contentArea.dataset.listenersAdded) {
        
        // Popula o filtro de ano
        const filtroAnoSelect = document.getElementById('filtroAno');
        await populateYearFilter(filtroAnoSelect);
        
        // <<< INÍCIO DA NOVA CORREÇÃO >>>
        // Popula o filtro de idioma
        const filtroIdiomaSelect = document.getElementById('filtroIdioma');
        await populateLanguageFilter(filtroIdiomaSelect);
        // <<< FIM DA NOVA CORREÇÃO >>>

        // Adiciona os listeners aos filtros
        document.getElementById('filtroParte').addEventListener('change', async () => {
            await populateDesignationFilter();
            generateStatisticsTable();
        });


         const otherFilters = ['filtroAno', 'filtroMes', 'filtroGenero', 'filtroIdioma', 'filtroDesignacaoGeral'];
        otherFilters.forEach(id => {
            document.getElementById(id).addEventListener('change', generateStatisticsTable);
        });
        
        contentArea.dataset.listenersAdded = 'true';
    }

    // --- EXECUÇÃO INICIAL ---
    await populateDesignationFilter();
    generateStatisticsTable();
};




// Aba 2: MAIS/MENOS (CORRIGIDA)
const loadMaisMenosTab = async () => {
    const contentArea = document.getElementById('tab-content-maisMenos');
    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group">
                <label for="maisMenosFiltroAno">Ano:</label>
                <select id="maisMenosFiltroAno"></select>
            </div>
        </div>
        <div id="maisMenosContent">A carregar...</div>
    `;

    const yearSelect = document.getElementById('maisMenosFiltroAno');
    await populateYearFilter(yearSelect);

    const renderMaisMenos = async () => {
        const ano = yearSelect.value;
        const contentDiv = document.getElementById('maisMenosContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados para ${ano}...</div>`;
        
        const historicoSnapshot = await db.collection('historico')
            .where('ano', '==', parseInt(ano))
            .where('quando', '==', 'Semana')
            .get();

        const participationCounts = new Map();
        const lastParticipation = new Map();

        historicoSnapshot.forEach(doc => {
            const data = doc.data();
            data.designacoes?.forEach(desig => {
                const participants = Object.values(desig.participantes || {});
                participants.forEach(pId => {
                    // Contagem de participações
                    const currentCount = participationCounts.get(pId) || 0;
                    participationCounts.set(pId, currentCount + 1);

                    // Última participação
                    const lastDate = lastParticipation.get(pId) || '1970-01-01';
                    if (data.dia && new Date(data.dia) > new Date(lastDate)) {
                        lastParticipation.set(pId, data.dia);
                    }
                });
            });
        });

        const sortedByCount = [...participationCounts.entries()].sort((a, b) => b[1] - a[1]);
        const sortedByDate = [...lastParticipation.entries()].sort((a, b) => new Date(a[1]) - new Date(b[1]));

        const maisDesignacoes = sortedByCount.slice(0, 7);
        const menosDesignacoes = sortedByCount.slice(-7).reverse();
        const maisTempoSem = sortedByDate.slice(0, 7);
        
        // --- INÍCIO DA CORREÇÃO ---
        // Acedemos a .nome para obter o nome da pessoa do objeto guardado no map.
        const getPersonName = (id) => (allPeopleDataMap.get(id) || {}).nome || 'Desconhecido';
        // --- FIM DA CORREÇÃO ---

        contentDiv.innerHTML = `
            <div class="mais-menos-container">
                <div class="rank-column col-mais">
                    <h4><i class="fas fa-arrow-up"></i> Mais Designações</h4>
                    <ol>${maisDesignacoes.map(([id, count]) => `<li>${getPersonName(id)} <strong>(${count})</strong></li>`).join('')}</ol>
                </div>
                <div class="rank-column col-menos">
                    <h4><i class="fas fa-arrow-down"></i> Menos Designações</h4>
                    <ol>${menosDesignacoes.map(([id, count]) => `<li>${getPersonName(id)} <strong>(${count})</strong></li>`).join('')}</ol>
                </div>
                <div class="rank-column col-antiga">
                    <h4><i class="far fa-clock"></i> Há Mais Tempo Sem Fazer</h4>
                    <ol>${maisTempoSem.map(([id, date]) => `<li>${getPersonName(id)} <small>(${new Date(date).toLocaleDateString()})</small></li>`).join('')}</ol>
                </div>
            </div>
        `;
    };

    yearSelect.addEventListener('change', renderMaisMenos);
    renderMaisMenos();
};

// Aba 3: MENOS (DETALHADO)
const loadMenosDetalhadoTab = async () => {
    const contentArea = document.getElementById('tab-content-menosDetalhado');
    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group">
                <label for="detalhadoFiltroAno">Ano:</label>
                <select id="detalhadoFiltroAno"></select>
            </div>
        </div>
        <div id="detalhadoContent" style="overflow-x: auto;">A carregar...</div>
    `;

    const yearSelect = document.getElementById('detalhadoFiltroAno');
    await populateYearFilter(yearSelect);

    const renderDetalhado = async () => {
        const ano = yearSelect.value;
        const contentDiv = document.getElementById('detalhadoContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados para ${ano}...</div>`;

        try {
            const [pessoasSnapshot, designacoesSnapshot, historicoSnapshot] = await Promise.all([
                db.collection('pessoas').where('fazDesignacoesReuniao', '==', true).get(),
                db.collection('designacoes').where('quando', '==', 'Semana').where('status', '==', true).get(),
                db.collection('historico').where('ano', '==', parseInt(ano)).where('quando', '==', 'Semana').get()
            ]);
            
            const designations = [];
            designacoesSnapshot.forEach(doc => {
                const data = doc.data();
                // MODIFICAÇÃO 1: Adicionado o campo 'ordem' ao objeto
                designations.push({id: doc.id, nome: data.nome, ordem: data.ordem});
            });

            // MODIFICAÇÃO 2: Alterada a ordenação para usar o campo 'ordem' em vez do nome
            designations.sort((a,b) => a.ordem - b.ordem);

            const counts = new Map();
            const totalCounts = new Map();

            pessoasSnapshot.forEach(personDoc => {
                const personId = personDoc.id;
                const innerMap = new Map();
                designations.forEach(d => innerMap.set(d.id, 0));
                counts.set(personId, innerMap);
                totalCounts.set(personId, 0);
            });

            historicoSnapshot.forEach(doc => {
                doc.data().designacoes?.forEach(desig => {
                    const participants = Object.values(desig.participantes || {});
                    participants.forEach(pId => {
                        if (counts.has(pId)) {
                            const personCounts = counts.get(pId);
                            if (personCounts.has(desig.designacaoId)) {
                                const currentCount = personCounts.get(desig.designacaoId);
                                personCounts.set(desig.designacaoId, currentCount + 1);
                            }
                        }
                    });
                });
            });
            
            for (const [pId, innerMap] of counts.entries()) {
                let total = 0;
                for (const count of innerMap.values()) {
                    total += count;
                }
                totalCounts.set(pId, total);
            }

            const rankedPeopleIds = [...totalCounts.entries()]
                .sort((a, b) => a[1] - b[1])
                .slice(0, 10)
                .map(entry => entry[0]);

            let tableHTML = `<table class="estatisticas-table"><thead><tr><th>Participante</th>`;
            designations.forEach(d => tableHTML += `<th>${d.nome}</th>`);
            tableHTML += `</tr></thead><tbody>`;

            rankedPeopleIds.forEach(pId => {
                 const personName = (allPeopleDataMap.get(pId) || {}).nome || 'Desconhecido';
                 tableHTML += `<tr><td>${personName}</td>`;
                 const personCounts = counts.get(pId);
                 designations.forEach(d => {
                    tableHTML += `<td>${personCounts.get(d.id) || 0}</td>`;
                 });
                 tableHTML += `</tr>`;
            });

            tableHTML += `</tbody></table>`;
            contentDiv.innerHTML = tableHTML;

        } catch (error) {
            console.error("Erro ao carregar aba 'Menos (detalhado)':", error);
            contentDiv.innerHTML = `<div style="color: red; text-align: center; padding: 20px;">Ocorreu um erro ao processar os dados. Tente novamente.</div>`;
        }
    };

    yearSelect.addEventListener('change', renderDetalhado);
    renderDetalhado();
};



// Aba 4: NUNCA
const loadNuncaTab = async () => {
    const contentArea = document.getElementById('tab-content-nunca');
    const nacionalidadesSnapshot = await db.collection('nacionalidades').get();
    let idiomasOptions = '';
    nacionalidadesSnapshot.forEach(doc => {
        idiomasOptions += `<option value="${doc.data().nome}">${doc.data().nome}</option>`;
    });

    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group"><label for="nuncaFiltroAno">Ano:</label><select id="nuncaFiltroAno"></select></div>
            <div class="form-group"><label for="nuncaFiltroMes">Mês:</label><select id="nuncaFiltroMes">
                <option value="1">Janeiro</option><option value="2">Fevereiro</option><option value="3">Março</option><option value="4">Abril</option><option value="5">Maio</option><option value="6">Junho</option><option value="7">Julho</option><option value="8">Agosto</option><option value="9">Setembro</option><option value="10">Outubro</option><option value="11">Novembro</option><option value="12">Dezembro</option>
            </select></div>
            <div class="form-group"><label for="nuncaFiltroGenero">Género:</label><select id="nuncaFiltroGenero">
                <option value="">Todos</option><option value="Masculino">Masculino</option><option value="Feminino">Feminino</option>
            </select></div>
            <div class="form-group"><label for="nuncaFiltroIdioma">Idioma:</label><select id="nuncaFiltroIdioma">
                <option value="">Todos</option>${idiomasOptions}
            </select></div>
        </div>
        <div id="nuncaContent" style="padding-top: 15px;">A carregar...</div>
    `;

    const yearSelect = document.getElementById('nuncaFiltroAno');
    await populateYearFilter(yearSelect);
    document.getElementById('nuncaFiltroMes').value = new Date().getMonth() + 1;

    const renderNunca = async () => {
        const ano = parseInt(document.getElementById('nuncaFiltroAno').value);
        const mes = parseInt(document.getElementById('nuncaFiltroMes').value);
        const genero = document.getElementById('nuncaFiltroGenero').value;
        const idioma = document.getElementById('nuncaFiltroIdioma').value;
        const contentDiv = document.getElementById('nuncaContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados...</div>`;

        let pessoasQuery = db.collection('pessoas').where('fazDesignacoesReuniao', '==', true);
        if (genero) pessoasQuery = pessoasQuery.where('genero', '==', genero);
        if (idioma) pessoasQuery = pessoasQuery.where('idioma', '==', idioma);
        
        const [pessoasSnapshot, historicoSnapshot] = await Promise.all([
            pessoasQuery.get(),
            db.collection('historico').where('ano', '==', ano).where('mes', '==', mes).where('quando', '==', 'Semana').get()
        ]);

        const allEligiblePeople = new Map();
        pessoasSnapshot.forEach(doc => allEligiblePeople.set(doc.id, doc.data().nomePessoa));

        const participantsThisMonth = new Set();
        historicoSnapshot.forEach(doc => {
            doc.data().designacoes?.forEach(d => {
                Object.values(d.participantes || {}).forEach(pId => participantsThisMonth.add(pId));
            });
        });

        const nonParticipants = [];
        for(const [id, name] of allEligiblePeople.entries()){
            if(!participantsThisMonth.has(id)){
                nonParticipants.push(name);
            }
        }
        
        nonParticipants.sort();
        contentDiv.innerHTML = `<h4>Pessoas que não participaram (Filtros Ativos)</h4>
        <p>${nonParticipants.length} pessoa(s) encontrada(s).</p>
        <ul style="columns: 3; -webkit-columns: 3; -moz-columns: 3;">${nonParticipants.map(name => `<li>${name}</li>`).join('')}</ul>`;
    };

    ['nuncaFiltroAno', 'nuncaFiltroMes', 'nuncaFiltroGenero', 'nuncaFiltroIdioma'].forEach(id => {
        document.getElementById(id).addEventListener('change', renderNunca);
    });
    renderNunca();
};

// Aba 5: DIRIGENTES
const loadDirigentesTab = async () => {
    const contentArea = document.getElementById('tab-content-dirigentes');
    const designacoesSnapshot = await db.collection('designacoes').where('quando', '==', 'Semana').get();
    let desigOptions = '<option value="">Todas as Designações</option>';
    designacoesSnapshot.forEach(doc => desigOptions += `<option value="${doc.id}">${doc.data().nome}</option>`);

    contentArea.innerHTML = `
        <div class="estatisticas-filtros-container">
            <div class="form-group"><label for="dirigentesFiltroAno">Ano:</label><select id="dirigentesFiltroAno"></select></div>
            <div class="form-group"><label for="dirigentesFiltroDesignacao">Designação:</label><select id="dirigentesFiltroDesignacao">${desigOptions}</select></div>
        </div>
        <div id="dirigentesContent" style="overflow-x: auto;">A carregar...</div>
    `;

    const yearSelect = document.getElementById('dirigentesFiltroAno');
    await populateYearFilter(yearSelect);

    const renderDirigentes = async () => {
        const ano = parseInt(yearSelect.value);
        const designacaoId = document.getElementById('dirigentesFiltroDesignacao').value;
        const contentDiv = document.getElementById('dirigentesContent');
        contentDiv.innerHTML = `<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> A processar dados...</div>`;

        let historicoQuery = db.collection('historico').where('ano', '==', ano).where('quando', '==', 'Semana');
        const [pessoasSnapshot, historicoSnapshot] = await Promise.all([
            db.collection('pessoas').where('fazDesignacoesReuniao', '==', true).orderBy('nomePessoa').get(),
            historicoQuery.get()
        ]);
        
        const peopleList = [];
        pessoasSnapshot.forEach(doc => peopleList.push({ id: doc.id, name: doc.data().nomePessoa }));

        const roleCounts = new Map(); // personId -> { dirigente: count, morador: count, ajudante: count }
        
        historicoSnapshot.forEach(doc => {
            doc.data().designacoes?.forEach(d => {
                if (designacaoId && d.designacaoId !== designacaoId) return; // Filtra por designação se selecionada
                
                for (const [role, pId] of Object.entries(d.participantes || {})) {
                    if (!roleCounts.has(pId)) roleCounts.set(pId, { dirigente: 0, morador: 0, ajudante: 0 });
                    const personCounts = roleCounts.get(pId);
                    if (personCounts[role] !== undefined) {
                        personCounts[role]++;
                    }
                }
            });
        });

        let tableHTML = `<table class="estatisticas-table">
            <thead><tr><th>Participante</th><th>Dirigente</th><th>Morador</th><th>Ajudante</th></tr></thead><tbody>`;
        
        peopleList.forEach(person => {
            const counts = roleCounts.get(person.id) || { dirigente: 0, morador: 0, ajudante: 0 };
            const dirigenteCount = counts.dirigente || 0;
            const moradorCount = counts.morador || 0;
            const ajudanteCount = counts.ajudante || 0;

            const dirigenteClass = dirigenteCount === 0 ? 'class="low-participation"' : '';

            tableHTML += `<tr>
                <td>${person.name}</td>
                <td ${dirigenteClass}>${dirigenteCount}</td>
                <td>${moradorCount}</td>
                <td>${ajudanteCount}</td>
            </tr>`;
        });

        tableHTML += `</tbody></table>`;
        contentDiv.innerHTML = tableHTML;
    };
    
    ['dirigentesFiltroAno', 'dirigentesFiltroDesignacao'].forEach(id => {
        document.getElementById(id).addEventListener('change', renderDirigentes);
    });
    renderDirigentes();
};

// --- Função original da Aba "Geral" (necessária para a primeira aba) ---
const generateStatisticsTable = async () => {
    const loadingDiv = document.getElementById('estatisticasLoading');
    const tableContainer = document.getElementById('estatisticasTableContainer');
    loadingDiv.style.display = 'block';
    tableContainer.style.display = 'none';

    // Lê os valores de TODOS os filtros no momento da execução
    const anoSelecionado = document.getElementById('filtroAno').value ? parseInt(document.getElementById('filtroAno').value) : null;
    const mesSelecionado = document.getElementById('filtroMes').value ? parseInt(document.getElementById('filtroMes').value) : null;
    const generoSelecionado = document.getElementById('filtroGenero').value;
    const idiomaSelecionado = document.getElementById('filtroIdioma').value;
    const parteSelecionada = document.getElementById('filtroParte').value;
    const designacaoSelecionada = document.getElementById('filtroDesignacaoGeral').value;

    try {
        let historicoQuery = db.collection('historico');
        if (anoSelecionado) historicoQuery = historicoQuery.where('ano', '==', anoSelecionado);
        if (mesSelecionado) historicoQuery = historicoQuery.where('mes', '==', mesSelecionado);
        
        let pessoasQuery = db.collection('pessoas').where('fazDesignacoesReuniao', '==', true);
        if (generoSelecionado) pessoasQuery = pessoasQuery.where('genero', '==', generoSelecionado);
        if (idiomaSelecionado) pessoasQuery = pessoasQuery.where('idioma', '==', idiomaSelecionado);

        let designacoesQuery = db.collection('designacoes').where('quando', '==', 'Semana');
        if (parteSelecionada) designacoesQuery = designacoesQuery.where('parte', '==', parteSelecionada);

        const [pessoasSnapshot, designacoesSnapshot, historicoSnapshot] = await Promise.all([
            pessoasQuery.get(),
            designacoesQuery.get(),
            historicoQuery.get()
        ]);
        
        let designationsInOrder = [];
        designacoesSnapshot.forEach(doc => {
            const data = doc.data();
            designationsInOrder.push({ id: doc.id, name: data.nome, ordem: data.ordem });
        });
        
        designationsInOrder.sort((a, b) => a.ordem - b.ordem);

        if (designacaoSelecionada) {
            designationsInOrder = designationsInOrder.filter(desig => desig.id === designacaoSelecionada);
        }

        const peopleMap = new Map();
        pessoasSnapshot.forEach(doc => {
            const pessoa = doc.data();
            const personCounts = new Map();
            designationsInOrder.forEach(desig => personCounts.set(desig.id, 0));
            peopleMap.set(doc.id, { name: pessoa.nomePessoa, counts: personCounts });
        });

        historicoSnapshot.forEach(doc => {
            const historico = doc.data();
            historico.designacoes?.forEach(histDesig => {
                const participants = Object.values(histDesig.participantes || {});
                participants.forEach(participanteId => {
                    if (peopleMap.has(participanteId) && peopleMap.get(participanteId).counts.has(histDesig.designacaoId)) {
                        const personData = peopleMap.get(participanteId);
                        const currentCount = personData.counts.get(histDesig.designacaoId);
                        personData.counts.set(histDesig.designacaoId, currentCount + 1);
                    }
                });
            });
        });

        let tableHTML = '<table class="estatisticas-table"><thead><tr><th>Participante</th>';
        designationsInOrder.forEach(desig => { tableHTML += `<th>${desig.name}</th>`; });
        tableHTML += '</tr></thead><tbody>';

        const sortedPeople = [...peopleMap.entries()].sort((a, b) => a[1].name.localeCompare(b[1].name));

        for (const [personId, personData] of sortedPeople) {
            tableHTML += `<tr><td>${personData.name}</td>`;
            designationsInOrder.forEach(desig => {
                tableHTML += `<td>${personData.counts.get(desig.id)}</td>`;
            });
            tableHTML += '</tr>';
        }
        tableHTML += '</tbody></table>';

        loadingDiv.style.display = 'none';
        tableContainer.innerHTML = tableHTML;
        tableContainer.style.display = 'block';

    } catch (error) {
        console.error("Erro ao gerar estatísticas:", error);
        loadingDiv.innerHTML = "Ocorreu um erro ao carregar as estatísticas.";
        tableContainer.style.display = 'none';
    }
};

// --- FIM: NOVA LÓGICA DO POPUP DE ESTATÍSTICAS COM ABAS ---


// ======================================================================== //
// ============ INÍCIO: LÓGICA DO POPUP DE PERFIL DE PARTICIPANTE ========== //
// ======================================================================== //

// --- Elementos da DOM ---
const perfilButton = document.getElementById('perfilButton');
const perfilPopup = document.getElementById('perfilPopup');
const closePerfilPopup = document.getElementById('closePerfilPopup');
const pesquisaInput = document.getElementById('pesquisaPessoa');
const sugestoesDiv = document.getElementById('pesquisaSugestoes');
const perfilFiltros = document.getElementById('perfilFiltrosContainer');
const perfilLoading = document.getElementById('perfilLoading');
const perfilTableContainer = document.getElementById('perfilTableContainer');
const perfilTableBody = document.getElementById('perfilTableBody');

// --- Filtros ---
const perfilFiltroAno = document.getElementById('perfilFiltroAno'); // NOME CORRIGIDO
const perfilFiltroMes = document.getElementById('perfilFiltroMes'); // NOME CORRIGIDO
const perfilFiltroDesignacao = document.getElementById('perfilFiltroDesignacao');
const perfilFiltroPapel = document.getElementById('perfilFiltroPapel');

// --- Armazenamento de dados em cache para performance ---
let allPeople = [];
let allDesignationsMap = new Map();
let allPeopleDataMap = new Map();
let currentPersonParticipationRecords = []; // Armazena os registros processados da pessoa selecionada


// --- Função para abrir a popup de perfil ---
perfilButton.addEventListener('click', () => {
    perfilPopup.style.display = 'flex';
    if (allPeople.length === 0) { // Carrega os dados apenas na primeira vez que abre
        initializeProfileData();
    }
});

// --- Função para fechar a popup de perfil ---
closePerfilPopup.addEventListener('click', () => {
    perfilPopup.style.display = 'none';
});

// --- Inicializa os dados necessários (pessoas e designações) ---
const initializeSystemData = async () => {
    try {
        const [pessoasSnapshot, designacoesSnapshot] = await Promise.all([
            db.collection('pessoas').orderBy('nomePessoa').get(),
            db.collection('designacoes').get()
        ]);

        // Limpa e preenche os mapas
        allPeople = [];
        allPeopleDataMap.clear();
        allDesignationsMap.clear();

        pessoasSnapshot.forEach(doc => {
            const pessoaData = doc.data();
            allPeople.push({ id: doc.id, nome: pessoaData.nomePessoa });
            // GUARDA O GÊNERO AQUI
            allPeopleDataMap.set(doc.id, { nome: pessoaData.nomePessoa, genero: pessoaData.genero });
        });

        designacoesSnapshot.forEach(doc => {
            allDesignationsMap.set(doc.id, doc.data().nome);
        });

        console.log("Dados do sistema (Pessoas e Designações) inicializados.");
    } catch (error) {
        console.error("Erro ao inicializar dados do sistema:", error);
    }
};


async function loadAllPeopleMap() {
    try {
        // Busca todas as pessoas que podem participar nas reuniões
        const pessoasSnapshot = await db.collection('pessoas').where('fazDesignacoesReuniao', '==', true).get();
        // Limpa o mapa global e preenche-o com os dados mais recentes
        allPeopleDataMap = new Map();
        pessoasSnapshot.forEach(doc => {
            allPeopleDataMap.set(doc.id, doc.data().nomePessoa);
        });
        console.log("Mapa global de pessoas carregado com sucesso.");
    } catch (error) {
        console.error("Erro ao carregar o mapa global de pessoas:", error);
    }
}

// --- Lógica da caixa de pesquisa com sugestões ---
pesquisaInput.addEventListener('input', () => {
    const query = pesquisaInput.value.toLowerCase();
    sugestoesDiv.innerHTML = '';

    if (query.length === 0) {
        sugestoesDiv.style.display = 'none';
        return;
    }

    const filteredPeople = allPeople.filter(p => p.nome.toLowerCase().includes(query));

    filteredPeople.forEach(person => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.textContent = person.nome;
        item.addEventListener('click', () => {
            pesquisaInput.value = person.nome;
            sugestoesDiv.style.display = 'none';
            // Inicia a busca no histórico para a pessoa selecionada
            loadParticipantProfile(person.id);
        });
        sugestoesDiv.appendChild(item);
    });

    sugestoesDiv.style.display = filteredPeople.length > 0 ? 'block' : 'none';
});

// Função principal para carregar o histórico de um participante (CORRIGIDA)
const loadParticipantProfile = async (personId) => {
    perfilLoading.style.display = 'block';
    perfilTableContainer.style.display = 'none';
    perfilFiltros.style.display = 'none';
    perfilTableBody.innerHTML = '';
    currentPersonParticipationRecords = []; // Limpa registros anteriores

    try {
        // Obtenção dos dados do histórico (sem alterações aqui)
        const historicoSnapshot = await db.collection('historico').orderBy("dia", "desc").get();
        let records = [];
        let years = new Set();
        let designacoesDaPessoa = new Set();

        historicoSnapshot.forEach(doc => {
            const historico = doc.data();
            
            if (historico.designacoes && Array.isArray(historico.designacoes)) {
                historico.designacoes.forEach(designacaoHist => {
                    const participantes = designacaoHist.participantes;
                    let meuPapel = '';
                    let todosOsIDs = [];

                    if (participantes && typeof participantes === 'object') {
                        todosOsIDs = Object.values(participantes);
                        for (const [papel, id] of Object.entries(participantes)) {
                            if (id === personId) {
                                meuPapel = papel;
                                break;
                            }
                        }
                    }

                    if (meuPapel) {
                        years.add(historico.ano); // Coleta todos os anos para o filtro

                        const designacaoNome = allDesignationsMap.get(designacaoHist.designacaoId) || 'Designação Desconhecida';
                        designacoesDaPessoa.add(designacaoNome);

                        // --- INÍCIO DA CORREÇÃO ---
                        const companheirosIDs = todosOsIDs.filter(id => id !== personId);
                        // A linha abaixo foi corrigida para aceder à propriedade .nome
                        const companheirosNomes = companheirosIDs
                            .map(id => (allPeopleDataMap.get(id) || {}).nome || 'N/A')
                            .join(', ');
                        // --- FIM DA CORREÇÃO ---

                        records.push({
                            ano: historico.ano,
                            dia: historico.dia,
                            designacaoNome: designacaoNome,
                            companheiros: companheirosNomes,
                            meuPapel: meuPapel.charAt(0).toUpperCase() + meuPapel.slice(1)
                        });
                    }
                });
            }
        });

        currentPersonParticipationRecords = records; // Não é preciso ordenar aqui, já vem do Firestore

        // Popula os filtros (sem alterações aqui)
        perfilFiltroAno.innerHTML = '<option value="">Todos</option>';
        Array.from(years).sort((a, b) => b - a).forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            perfilFiltroAno.appendChild(option);
        });

        perfilFiltroDesignacao.innerHTML = '<option value="">Todas</option>';
        Array.from(designacoesDaPessoa).sort().forEach(nome => {
            const option = document.createElement('option');
            option.value = nome;
            option.textContent = nome;
            perfilFiltroDesignacao.appendChild(option);
        });

        // Exibe os filtros e a tabela (sem alterações aqui)
        perfilLoading.style.display = 'none';
        perfilFiltros.style.display = 'flex';
        perfilTableContainer.style.display = 'block';
        renderProfileTable();

    } catch (error) {
        console.error("Erro ao carregar perfil do participante:", error);
        perfilLoading.innerHTML = 'Ocorreu um erro ao carregar o histórico.';
    }
};





// --- Função para renderizar/filtrar a tabela ---
const renderProfileTable = () => {
    // Log 1: Confirma que a função foi chamada
    console.log("--- renderProfileTable chamada ---");

    perfilTableBody.innerHTML = '';

    const ano = perfilFiltroAno.value;
    const mes = perfilFiltroMes.value;
    const designacao = perfilFiltroDesignacao.value;
    const papel = perfilFiltroPapel.value;

    // Log 2: Mostra os valores dos filtros que estão a ser usados
    console.log("Filtros Atuais:", { ano, mes, designacao, papel });

    const filteredRecords = currentPersonParticipationRecords.filter(rec => {
        const recDate = new Date(rec.dia);
        const recMonth = recDate.getMonth() + 1;
        let keepRecord = true; // Começamos por assumir que o registo deve ser mantido

        if (ano && rec.ano.toString() !== ano) {
            keepRecord = false;
        }
        if (mes && recMonth.toString() !== mes) {
            keepRecord = false;
        }
        if (papel && rec.meuPapel.toLowerCase() !== papel) {
            keepRecord = false;
        }

        // --- Lógica de Depuração para a Designação ---
        if (designacao) { // Apenas se um filtro de designação estiver ativo
            const recordDesignacao = rec.designacaoNome;
            const filtroDesignacao = designacao;
            
            // Log 3: Compara os valores exatos para cada linha da tabela
            console.log(`Comparando: [${recordDesignacao}] com filtro [${filtroDesignacao}] | Iguais? ${recordDesignacao === filtroDesignacao}`);
            
            if (recordDesignacao !== filtroDesignacao) {
                keepRecord = false;
            }
        }
        // --- Fim da Lógica de Depuração ---
        
        return keepRecord;
    });
    
    // Log 4: Mostra quantos registos passaram no filtro
    console.log(`Número de registos após o filtro: ${filteredRecords.length}`);

    if (filteredRecords.length === 0) {
        perfilTableBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">Nenhum registro encontrado para os filtros selecionados.</td></tr>';
        return;
    }
    
    filteredRecords.forEach(rec => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${rec.ano}</td>
            <td>${formatDateForDisplay(rec.dia)}</td>
            <td>${rec.designacaoNome}</td>
            <td>${rec.companheiros || 'Nenhum'}</td>
            <td>${rec.meuPapel}</td>
        `;
        perfilTableBody.appendChild(tr);
    });
};

// --- Adiciona listeners para os filtros ---
[perfilFiltroAno, perfilFiltroMes, perfilFiltroDesignacao, perfilFiltroPapel].forEach(filtro => {
    filtro.addEventListener('change', renderProfileTable);
});


// --- Helper para formatar a data ---
const formatDateForDisplay = (dateString) => {
    if (!dateString) return 'Data Inválida';
    const meses = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
    const [ano, mes, dia] = dateString.split('-');
    return `${parseInt(dia)} ${meses[parseInt(mes) - 1]} ${ano}`;
};


// Fecha as sugestões se clicar fora da caixa
document.addEventListener('click', function(event) {
    if (!pesquisaInput.contains(event.target) && !sugestoesDiv.contains(event.target)) {
        sugestoesDiv.style.display = 'none';
    }
});

// ======================================================================== //
// ============== FIM: LÓGICA DO POPUP DE PERFIL DE PARTICIPANTE ========== //
// ======================================================================== //



            
            // Load nacionalidades from Firebase
            const loadNacionalidades = async () => {
                const nacionalidadesRef = db.collection('nacionalidades');
                const snapshot = await nacionalidadesRef.get();
                const nacionalidadesDiv = document.getElementById('nacionalidades');

                nacionalidadesDiv.innerHTML = ''; // Clear existing checkboxes
                snapshot.forEach(doc => {
                    const nacionalidade = doc.data();
                    const label = document.createElement('label');
                    label.className = 'checkbox-item';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.name = 'nacionalidades';
                    input.value = nacionalidade.nome;
                    if (nacionalidade.nome === 'Portugal') {
                        input.checked = true;
                    }
                    label.appendChild(input);
                    label.appendChild(document.createTextNode(nacionalidade.nome));
                    nacionalidadesDiv.appendChild(label);
                });
            };

             // CHAME A NOVA FUNÇÃO AQUI:
    loadAllDesignationsMap();
    loadAllPeopleMap();
    initializeSystemData();

            // Call loadNacionalidades when page loads
            loadNacionalidades();


            const reIndexOrderNumbers = () => {
                const designacaoItems = document.querySelectorAll('#designacoesList .designacao-item');
                let currentOrder = 1;
                let orderedDesignations = [];

                // Collect ordered designations
                designacaoItems.forEach(item => {
                    const orderButton = item.querySelector('.order-button');
                    const order = parseInt(orderButton.dataset.order) || 0;
                    if (order > 0) {
                        orderedDesignations.push({ item: item, order: order });
                    }
                });

                // Sort ordered designations by their current order
                orderedDesignations.sort((a, b) => a.order - b.order);

                // Re-index and update display
                orderedDesignations.forEach(orderedDesignation => {
                    const orderButton = orderedDesignation.item.querySelector('.order-button');
                    orderButton.dataset.order = currentOrder;
                    orderButton.textContent = currentOrder;

                    orderButton.classList.remove('ordered', 'ordered-level-2', 'ordered-level-3', 'ordered-level-4', 'ordered-level-5', 'ordered-level-6', 'ordered-level-7');
                    orderButton.classList.add('ordered');
                    if (currentOrder >= 2) orderButton.classList.add('ordered-level-2');
                    if (currentOrder >= 3) orderButton.classList.add('ordered-level-3');
                    if (currentOrder >= 4) orderButton.classList.add('ordered-level-4');
                    if (currentOrder >= 5) orderButton.classList.add('ordered-level-5');
                    if (currentOrder >= 6) orderButton.classList.add('ordered-level-6');
                    if (currentOrder >= 7) orderButton.classList.add('ordered-level-7');

                    currentOrder++;
                });
            };


            const removeActiveDesignationDisplay = (designacaoId) => {
                const displayToRemove = document.getElementById(`active-designation-${designacaoId}`);
                if (displayToRemove) {
                    displayToRemove.remove();
                }
            };


  const loadPeopleOptionsIntoSelects = async (designacao, container, preferences = {}, diasSemana, diaSemanaReuniaoString, genderPreference = 'masculino feminino') => {
    try {
    const anoFirebase = await getAnoPainelFirebase(); 
        const pessoasRef = db.collection('pessoas');
        const preferenceForDesignation = preferences[designacao.id];

        let query = pessoasRef
            .where('fazDesignacoesReuniao', '==', true)
            .where('designacoesReuniao', 'array-contains', designacao.nome);

        if (genderPreference === 'masculino') {
            query = query.where('genero', '==', 'Masculino');
        } else if (genderPreference === 'feminino') {
            query = query.where('genero', '==', 'Feminino');
        }
        const selectedLanguages = Array.from(document.querySelectorAll('#nacionalidades input[name="nacionalidades"]:checked'))
            .map(checkbox => checkbox.value);

        query.get().then(snapshot => {
            
            // 1. Recolher todas as pessoas elegíveis para uma lista temporária
            const eligiblePeopleList = [];
            snapshot.forEach(doc => {
                const pessoa = doc.data();
                
                // Aplicar regras gerais de elegibilidade aqui
                let isAbsent = false;
                const designationDateFormatted = getMeetingDayOfMonth(anoFirebase, diasSemana, diaSemanaReuniaoString);
                if (designationDateFormatted) {
                    if (pessoa.ausencias && Array.isArray(pessoa.ausencias)) {
                        isAbsent = pessoa.ausencias.includes(designationDateFormatted);
                    }
                }
                const temPrivilegiosNecessarios = designacao.quemFaz.some(
                    privilegio => pessoa.privilegiosCongregacao && pessoa.privilegiosCongregacao.includes(privilegio)
                );
                let languageMatches = true;
                if (selectedLanguages.length > 0) {
                    languageMatches = selectedLanguages.includes(pessoa.idioma);
                }

                if (languageMatches && temPrivilegiosNecessarios && !isAbsent) {
                    eligiblePeopleList.push({ id: doc.id, data: pessoa });
                }
            });

            // 2. Ordenar a lista alfabeticamente pelo nome da pessoa
            eligiblePeopleList.sort((a, b) => a.data.nomePessoa.localeCompare(b.data.nomePessoa));

            // 3. Preencher os dropdowns com a lista já ordenada
            container.querySelectorAll('.designacao-instance-container').forEach((instanceContainer, instanceIndex) => {
                instanceContainer.querySelectorAll('.form-select').forEach((participantSelect, participantIndex) => {
                    participantSelect.innerHTML = '<option value="">Selecione uma pessoa</option>';

                    // Percorrer a lista ordenada
                    eligiblePeopleList.forEach(person => {
                        const pessoaData = person.data;

                        // ===================================================================
                        // =========== INÍCIO DA ALTERAÇÃO APLICADA AQUI =====================
                        // ===================================================================
                        
                        // Aplicar a regra de personalidade específica do papel
                        let podeAssumirEstePapel = false;
                        if (participantIndex === 0) { // Se for o dropdown 'Dirigente'
                            // REGRA ANTIGA: por defeito, só quem tem '+ à vontade' pode ser dirigente
                            if (pessoaData.personalidade === '+ à vontade') {
                                podeAssumirEstePapel = true;
                            }

                            // NOVA REGRA: verifica se a própria designação permite '- à vontade'
                            // Se permitir, as pessoas com essa personalidade também se tornam elegíveis
                            if (
                                Array.isArray(designacao.personalidade) &&
                                designacao.personalidade.includes('- à vontade') &&
                                pessoaData.personalidade === '- à vontade'
                            ) {
                                podeAssumirEstePapel = true;
                            }

                        } else { // Se for 'Morador' ou 'Ajudante'
                            podeAssumirEstePapel = true;
                        }
                        
                        // ===================================================================
                        // ============ FIM DA ALTERAÇÃO APLICADA AQUI =======================
                        // ===================================================================
                        
                        // Adicionar a opção se a regra do papel for cumprida
                        if (podeAssumirEstePapel) {
                            const option = document.createElement('option');
                            option.value = person.id;
                            option.textContent = pessoaData.nomePessoa;
                            participantSelect.appendChild(option);
                        }
                    });
                });
            });

            console.log("[loadPeopleOptionsIntoSelects] END - Designation:", designacao.nome, ", Gender Preference:", genderPreference);
        });

    } catch (error) {
        console.error('Erro ao carregar pessoas elegíveis:', error);
        console.log("[loadPeopleОptionsIntoSelects] ERROR - Designation:", designacao.nome, ", Error:", error, ", Gender Preference:", genderPreference);
    }
};


            const getAnoPainelFirebase = async () => {
                const painelAnoRef = db.collection('painel').doc('ano');
                const doc = await painelAnoRef.get();
                if (doc.exists) {
                    return doc.data().ano;
                } else {
                    return new Date().getFullYear();
                }
            };

            const countHistoricoSemanas = async (ano, mes) => {
                const historicoRef = db.collection('historico');
                const querySnapshot = await historicoRef
                    .where("ano", "==", ano)
                    .where("mes", "==", parseInt(mes))
                    .where("quando", "==", "Semana") // <-- ALTERAÇÃO AQUI
                    .where("parte", "==", "escola")
                    .get();
                return querySnapshot.size;
            };

          const getDiasSemana = (ano, mes, semanaNumero) => { // FUNÇÃO 1 CORRIGIDA
    const primeiroDiaMes = new Date(ano, mes - 1, 1);
    let diaSemanaPrimeiroDia = primeiroDiaMes.getDay();
    if (diaSemanaPrimeiroDia === 0) diaSemanaPrimeiroDia = 7;

    let diasToAddForFirstMonday = 0;
    if (diaSemanaPrimeiroDia !== 1) {
        diasToAddForFirstMonday = (8 - diaSemanaPrimeiroDia) % 7;
    }

    const primeiroSegundaMes = new Date(ano, mes - 1, 1 + diasToAddForFirstMonday);
    const inicioSemanaDate = new Date(ano, mes - 1, primeiroSegundaMes.getDate() + (semanaNumero - 1) * 7);
    const fimSemanaDate = new Date(ano, mes - 1, primeiroSegundaMes.getDate() + (semanaNumero - 1) * 7 + 6);

    const formatarData = (date) => {
        return date.getDate();
    };

    const formatarMes = (date) => {
        // O array de meses mal formatado foi corrigido aqui.
        const monthNames = ["Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
        return monthNames[date.getMonth()];
    };

    const inicio_dia = formatarData(inicioSemanaDate);
    const fim_dia = formatarData(fimSemanaDate);
    const inicio_mes = formatarMes(inicioSemanaDate);
    const fim_mes = formatarMes(fimSemanaDate);

    let diasSemanaString;
    if (inicioSemanaDate.getMonth() !== fimSemanaDate.getMonth()) {
        diasSemanaString = `${inicio_dia} ${inicio_mes} - ${fim_dia} ${fim_mes}`;
    } else {
        diasSemanaString = `${inicio_dia} - ${fim_dia} ${inicio_mes}`;
    }
    return diasSemanaString;
};



            const getTotalSemanasNoMes = async (ano, mes) => {
                let countWeeks = 0;
                let currentDay = new Date(ano, mes - 1, 1);
                const lastDayOfMonth = new Date(ano, mes, 0);

                while (currentDay <= lastDayOfMonth) {
                    if (currentDay.getDay() === 1) {
                        countWeeks++;
                    }
                    currentDay.setDate(currentDay.getDate() + 1);
                }
                return countWeeks;
            };




          const updateWeekDisplay = async () => {
    // Get references to DOM elements once for efficiency
    const weekDisplay = document.getElementById('weekDisplay');
    const nextButton = document.getElementById('btnSeguinte');

    // Get date and week information
    const mesSelecionado = document.getElementById('mes').value;
    const anoFirebase = await getAnoPainelFirebase();
    const semanaNumero = await countHistoricoSemanas(anoFirebase, mesSelecionado) + 1;
    const totalSemanas = await getTotalSemanasNoMes(anoFirebase, mesSelecionado);

    // -- NOVA LÓGICA DE VALIDAÇÃO --
    // Verifica se o número da próxima semana excede o total de semanas do mês.
    // A condição `totalSemanas > 0` é uma segurança para meses sem histórico.
    if (totalSemanas > 0 && semanaNumero > totalSemanas) {
        // Se exceder, exibe a mensagem de aviso
        weekDisplay.innerHTML = "Mude o Mês, já não há mais semanas neste mês";
        weekDisplay.style.color = '#e74c3c'; // Um vermelho forte para alerta
        weekDisplay.style.fontWeight = 'bold';

        // Desativa o botão "Seguinte" para impedir que o utilizador avance
        nextButton.disabled = true;
        nextButton.style.backgroundColor = '#bdc3c7'; // Cor cinza para indicar desativado
        nextButton.style.cursor = 'not-allowed';

    } else {
        // Se a semana for válida, executa a lógica original
        const diasSemana = getDiasSemana(anoFirebase, mesSelecionado, semanaNumero);

        // Atualiza o input escondido
        document.getElementById('semanaNumero').value = semanaNumero;

        // Exibe as informações da semana
        const weekDisplayText = `${semanaNumero}ª semana de ${totalSemanas} semanas <br>(${diasSemana})`;
        weekDisplay.innerHTML = weekDisplayText;
        
        // Restaura o estilo normal do texto
        weekDisplay.style.color = '#2c3e50';
        weekDisplay.style.fontWeight = 'normal';

        // Garante que o botão "Seguinte" está ativo e com o estilo correto
        nextButton.disabled = false;
        nextButton.style.backgroundColor = '#2ecc71'; // Cor original verde
        nextButton.style.cursor = 'pointer';
    }
};







   const getWeekMondayFriday = (ano, mes, semanaNumero) => {
                const primeiroDiaMes = new Date(ano, mes - 1, 1);
                let diaSemanaPrimeiroDia = primeiroDiaMes.getDay();
                if (diaSemanaPrimeiroDia === 0) diaSemanaPrimeiroDia = 7; // Converte Domingo (0) para 7

                let diasToAddForFirstMonday = (8 - diaSemanaPrimeiroDia) % 7;
                if (primeiroDiaMes.getDay() === 1) {
                    diasToAddForFirstMonday = 0;
                }

                const primeiroSegundaMes = new Date(ano, mes - 1, 1 + diasToAddForFirstMonday);
                const monday = new Date(primeiroSegundaMes);
                monday.setDate(monday.getDate() + (semanaNumero - 1) * 7);
                const friday = new Date(monday);
                friday.setDate(friday.getDate() + 4);

                monday.setHours(0, 0, 0, 0);
                friday.setHours(23, 59, 59, 999);

                return { monday, friday };
            };

            /**
             * Guarda um registo no histórico para um evento especial.
             */
            const saveSpecialEvent = async () => {
                try {
                    const ano = await getAnoPainelFirebase();
                    const mes = parseInt(document.getElementById('mes').value);
                    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);
                    const tipoEvento = document.getElementById('tipo').value;
                    const idiomasSelecionados = Array.from(document.querySelectorAll('#nacionalidades input[name="nacionalidades"]:checked')).map(c => c.value);
                    const salaSelecionada = document.getElementById('sala').value;
                    const diasSemana = getDiasSemana(ano, mes, semanaNumero);
                    const horariosData = await getHorariosFromFirebase(ano);
                    const diaSemanaReuniaoString = horariosData['dia-semana'];
                    const meetingDayOfMonth = getMeetingDayOfMonth(diasSemana, diaSemanaReuniaoString);
                    const semanaIndexValue = `(${diasSemana} ${ano})`;

                    const historicoData = {
                        ano: ano, mes: mes, semanaNumero: semanaNumero, semanaindex: semanaIndexValue,
                        designacoes: [], evento: tipoEvento, tipo: "reuniao", idioma: idiomasSelecionados,
                        sala: salaSelecionada, dia: meetingDayOfMonth, hora: null, quando: "Semana",
                        oque: "reuniao", parte: "escola", timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    await db.collection("historico").add(historicoData);
                    return true;
                } catch (error) {
                    console.error("Erro ao gravar evento especial:", error);
                    alert("Ocorreu um erro ao gravar o evento especial: " + error.message);
                    return false;
                }
            };
            

   const getWeekMondaySunday = (ano, mes, semanaNumero) => {
                const primeiroDiaMes = new Date(ano, mes - 1, 1);
                let diaSemanaPrimeiroDia = primeiroDiaMes.getDay();
                if (diaSemanaPrimeiroDia === 0) diaSemanaPrimeiroDia = 7; // Converte Domingo (0) para 7

                let diasToAddForFirstMonday = (8 - diaSemanaPrimeiroDia) % 7;
                if (primeiroDiaMes.getDay() === 1) {
                    diasToAddForFirstMonday = 0;
                }

                const primeiroSegundaMes = new Date(ano, mes - 1, 1 + diasToAddForFirstMonday);
                const monday = new Date(primeiroSegundaMes);
                monday.setDate(monday.getDate() + (semanaNumero - 1) * 7);
                const sunday = new Date(monday);
                sunday.setDate(sunday.getDate() + 6); // Adiciona 6 dias para ir de Segunda a Domingo

                monday.setHours(0, 0, 0, 0);
                sunday.setHours(23, 59, 59, 999);

                return { monday, sunday };
            };





            /**
             * Mostra um painel de confirmação customizado para o Memorial e retorna uma Promise.
             * @returns {Promise<boolean>} Resolve para true se o utilizador confirmar, false se cancelar.
             */
          const showSpecialEventConfirmation = (eventType) => {
                const eventDisplayNames = {
                    'memorial': 'O Memorial',
                    'assembleia': 'A Assembleia',
                    'congresso': 'O Congresso'
                };
                const eventName = eventDisplayNames[eventType] || 'Este evento especial';

                return new Promise((resolve) => {
                    const popup = document.getElementById('memorialConfirmationPopup');
                    const messageEl = document.getElementById('memorialPopupMessage');
                    const confirmBtn = document.getElementById('confirmMemorialSave');
                    const cancelBtn = document.getElementById('cancelMemorialSave');

                    // Atualiza a mensagem do popup dinamicamente
                    messageEl.textContent = `A data de ${eventName} coincide com esta semana. Deseja gravar um evento especial sem designações e concluir?`;
                    
                    popup.style.display = 'flex';

                    const handleConfirm = () => {
                        popup.style.display = 'none';
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(true);
                    };

                    const handleCancel = () => {
                        popup.style.display = 'none';
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(false);
                    };

                    confirmBtn.addEventListener('click', handleConfirm);
                    cancelBtn.addEventListener('click', handleCancel);
                });
            };

            // Handle "Seguinte" button click (VERSÃO COM PAINEL CUSTOMIZADO)
   document.getElementById('btnSeguinte').addEventListener('click', async function() {
    const tipoReuniao = document.getElementById('tipo').value;
    
    // Lista de eventos que acionam a verificação (incluindo Visita do Servo, para consistência)
    const specialEventTypes = ['memorial', 'assembleia', 'congresso', 'visita-servo'];

    if (specialEventTypes.includes(tipoReuniao)) {
        const ano = await getAnoPainelFirebase();
        
        const eventNameMap = {
            'memorial': 'Memorial',
            'assembleia': 'Assembleia',
            'congresso': 'Congresso',
            'visita-servo': 'Visita do Servo'
        };
        const eventNameForQuery = eventNameMap[tipoReuniao];
        
        if (eventNameForQuery) {
            const snapshot = await db.collection('eventos')
                .where('nome', '==', eventNameForQuery)
                .where('ano', '==', ano)
                .get();

            if (!snapshot.empty) {
                const mes = parseInt(document.getElementById('mes').value);
                const semanaNumero = parseInt(document.getElementById('semanaNumero').value);
                const { monday: weekStart, sunday: weekEnd } = getWeekMondaySunday(ano, mes, semanaNumero);
                
                let overlapFound = false;

                // ===== INÍCIO DA LÓGICA CORRIGIDA =====
                // Agora percorremos TODOS os documentos de evento encontrados
                for (const doc of snapshot.docs) {
                    const eventData = doc.data();
                    
                    // Verifica evento com data única
                    if (eventData.data) {
                        const eventDate = new Date(eventData.data + 'T12:00:00');
                        if (eventDate >= weekStart && eventDate <= weekEnd) {
                            overlapFound = true;
                            break; // Encontrou uma correspondência, pode parar de procurar
                        }
                    } 
                    // Verifica evento com intervalo de datas
                    else if (eventData.data_inicio && eventData.data_fim) {
                        const eventStart = new Date(eventData.data_inicio + 'T00:00:00');
                        const eventEnd = new Date(eventData.data_fim + 'T23:59:59');
                        if (eventStart <= weekEnd && eventEnd >= weekStart) {
                            overlapFound = true;
                            break; // Encontrou uma correspondência, pode parar de procurar
                        }
                    }
                }
                // ===== FIM DA LÓGICA CORRIGIDA =====

                if (overlapFound) {
                    const confirmed = await showSpecialEventConfirmation(tipoReuniao);
                    if (confirmed) {
                        const success = await saveSpecialEvent();
                        if (success) {
                            alert(`Evento de ${eventNameForQuery} gravado com sucesso!`);
                            window.location.reload();
                        }
                    }
                    return; // Interrompe o fluxo para não mostrar as designações
                }
            }
        }
    }

    // Se não for um evento especial com sobreposição de datas, continua com a lógica original
    const designacoesSection = document.getElementById('designacoesSection');
    const leituraBibliaSection = document.getElementById('leituraBibliaSection');
    const iniciarFluxoButton = document.querySelector('#fluxoSemanalForm button[type="submit"].btn-submit');

    designacoesSection.classList.add('active');
    leituraBibliaSection.style.display = 'block';
    iniciarFluxoButton.style.display = 'block';
    designacoesSection.scrollIntoView({ behavior: 'smooth' });
});

            // ======================================================================== //
            // ============= FIM: NOVAS FUNÇÕES PARA LÓGICA DO MEMORIAL =============== //
            // ======================================================================== //




            // Call updateWeekDisplay initially and when month changes
            updateWeekDisplay();
            document.getElementById('mes').addEventListener('change', updateWeekDisplay);






            

            const activeDesignationsDisplay = {};


            // --- Nova Função: getEligiblePeopleForDropdown (já existente - manter) ---
            const getEligiblePeopleForDropdown = (dropdown) => {
    const peopleIds = [];
    const options = dropdown.querySelectorAll('option');
    
    options.forEach(option => {
        // A CONDIÇÃO MAIS IMPORTANTE ESTÁ AQUI:
        // Só considera a opção se ela tiver um valor E se não estiver escondida (style.display !== 'none')
        if (option.value && option.style.display !== 'none') {
            peopleIds.push(option.value);
        }
    });
    
    return peopleIds;
};



            // --- Função rankPeopleByDesignationCount - IMPLEMENTAÇÃO COMPLETA (já existente - manter) ---
            const rankPeopleByDesignationCount = async (eligiblePeopleIds, designationName, ano, returnScore = false) => {
    const historicoRef = db.collection('historico');
    const historicoQuery = historicoRef
        .where("ano", "==", ano)
        .where("quando", "==", "Semana");

    const historicoSnapshot = await historicoQuery.get();
    const designationCounts = {};

    eligiblePeopleIds.forEach(personId => {
        designationCounts[personId] = { total: 0, specific: 0 };
    });

    historicoSnapshot.forEach(doc => {
        const historicoData = doc.data();
        historicoData.designacoes.forEach(designacaoHistorico => {
            if (designacaoHistorico.participantes) {
                let listaDeParticipantes = [];
                if (Array.isArray(designacaoHistorico.participantes)) {
                    listaDeParticipantes = designacaoHistorico.participantes;
                } else if (typeof designacaoHistorico.participantes === 'object') {
                    listaDeParticipantes = Object.values(designacaoHistorico.participantes);
                }

                listaDeParticipantes.forEach(participanteId => {
                    if (eligiblePeopleIds.includes(participanteId)) {
                        if (!designationCounts[participanteId]) {
                            designationCounts[participanteId] = { total: 0, specific: 0 };
                        }
                        designationCounts[participanteId].total++;
                        
                        const designacaoIdNoHistorico = designacaoHistorico.designacaoId || designacaoHistorico.designacao;
                        if (designacaoIdNoHistorico === getDesignationIdByName(designationName)) {
                            designationCounts[participanteId].specific++;
                        }
                    }
                });
            }
        });
    });

    function getDesignationIdByName(name) {
        const el = Array.from(document.querySelectorAll('#designacoesList .designacao-item label > span'))
                      .find(span => span.textContent === name);
        return el ? el.closest('.designacao-item').dataset.designacaoId : null;
    }

    const rankedPeopleArray = eligiblePeopleIds.map(personId => ({
        personId: personId,
        totalDesignations: designationCounts[personId].total,
        specificDesignations: designationCounts[personId].specific
    }));

    rankedPeopleArray.sort((a, b) => {
        if (a.totalDesignations !== b.totalDesignations) {
            return a.totalDesignations - b.totalDesignations;
        }
        return a.specificDesignations - b.specificDesignations;
    });

    // =================================================================
    // =========== INÍCIO DA CORREÇÃO AQUI =============================
    // =================================================================
    if (returnScore) {
        // Agora, em vez de retornar apenas UMA pontuação, retornamos o ARRAY COMPLETO
        // de objetos classificados. A função chamadora pode então usar .slice().
        return rankedPeopleArray;
    }
    // =================================================================
    // ============ FIM DA CORREÇÃO AQUI ===============================
    // =================================================================

    // O comportamento padrão (quando returnScore é false) continua o mesmo.
    return rankedPeopleArray.map(item => item.personId);
};





            // --- Função autoFillDesignations - MODIFICADA para regra de unicidade (já existente - MODIFICADA) ---
        const autoFillDesignations = async () => {
    const assignedPeopleThisWeek = new Set();

    document.querySelectorAll('.active-designation-container').forEach(container => {
        if (container.dataset.locked === 'true') {
            container.querySelectorAll('.form-select').forEach(select => {
                if (select.value) {
                    assignedPeopleThisWeek.add(select.value);
                }
            });
        }
    });

    document.querySelectorAll('.active-designation-container').forEach(container => {
        if (container.dataset.locked !== 'true') {
            container.querySelectorAll('.form-select').forEach(select => {
                select.value = '';
                // IMPORTANTE: Reseta a visibilidade das opções para o foguetão
                Array.from(select.options).forEach(opt => opt.style.display = '');
            });
        }
    });

    const activeDesignationContainers = document.querySelectorAll('#activeDesignationsContainer .active-designation-container, #leituraBibliaDesignationContainer .active-designation-container');
    const ano = await getAnoPainelFirebase();
    const mes = parseInt(document.getElementById('mes').value);
    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);

    const participantsLastWeek = await getParticipantsLastWeek(ano, mes, semanaNumero);
    const participantsThisMonth = await getParticipantsThisMonth(ano, mes);
    const recentPairsMap = await getRecentPairs();

    // Garante que o mapa de designações está atualizado
    const allDesignations = new Map();
    const designacoesSnapshot = await db.collection('designacoes').get();
    designacoesSnapshot.forEach(doc => allDesignations.set(doc.id, doc.data().nome));

    for (const designationContainer of activeDesignationContainers) {
        if (designationContainer.dataset.locked === 'true') {
            continue;
        }

        const designacaoId = designationContainer.dataset.designacaoId;
        const designationName = allDesignations.get(designacaoId) || 'Designação Desconhecida';
        
        const instances = designationContainer.querySelectorAll('.designacao-instance-container');
        for (let instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
            const instanceContainer = instances[instanceIndex];
            const participantSelects = instanceContainer.querySelectorAll('.form-select');

            // Lógica para 1 participante (continua igual)
            if (participantSelects.length === 1) {
                const select = participantSelects[0];
                let eligible = getEligiblePeopleForDropdown(select)
                    .filter(id => !assignedPeopleThisWeek.has(id))
                    .filter(id => !participantsLastWeek.has(id));
                
                let idealCandidates = eligible.filter(id => !participantsThisMonth.has(id));
                let finalCandidates = (idealCandidates.length > 0) ? idealCandidates : eligible;

                if (finalCandidates.length > 0) {
                    const ranked = await rankPeopleByDesignationCount(finalCandidates, designationName, ano);
                    if (ranked.length > 0) {
                        select.value = ranked[0];
                        assignedPeopleThisWeek.add(ranked[0]);
                    }
                }
            } 
            // Lógica para 2 participantes (COM A CORREÇÃO DE GÊNERO)
            else if (participantSelects.length >= 2) {
                const [dirigenteSelect, moradorSelect] = participantSelects;
                
                // IMPORTANTE: Resetamos os filtros visuais antes de obter os candidatos
                handleGenderSync(dirigenteSelect);

                const eligibleDirigentes = getEligiblePeopleForDropdown(dirigenteSelect);
                const eligibleMoradores = getEligiblePeopleForDropdown(moradorSelect);

                let possiblePairs = [];
                for (const dirigenteId of eligibleDirigentes) {
                    for (const moradorId of eligibleMoradores) {
                        if (dirigenteId === moradorId) continue;
                        if (assignedPeopleThisWeek.has(dirigenteId) || assignedPeopleThisWeek.has(moradorId)) continue;
                        if (participantsLastWeek.has(dirigenteId) || participantsLastWeek.has(moradorId)) continue;

                        // ==========================================================
                        // ============ NOVA VERIFICAÇÃO DE GÊNERO AQUI =============
                        // ==========================================================
                        const dirigenteData = allPeopleDataMap.get(dirigenteId);
                        const moradorData = allPeopleDataMap.get(moradorId);

                        // Se temos os dados de gênero de ambos e eles são DIFERENTES, o par é inválido.
                        if (dirigenteData && moradorData && dirigenteData.genero !== moradorData.genero) {
                            continue; // Salta para o próximo par
                        }
                        // ==========================================================
                        // =================== FIM DA VERIFICAÇÃO ===================
                        // ==========================================================

                        possiblePairs.push({ dirigente: dirigenteId, morador: moradorId });
                    }
                }

                const validPairs = possiblePairs.filter(pair => {
                    const pairKey = [pair.dirigente, pair.morador].sort().join('_');
                    if (!recentPairsMap.has(pairKey)) return true;
                    const history = recentPairsMap.get(pairKey);
                    const lastDate = new Date(history.lastDate);
                    const currentDate = new Date();
                    const lastMonthYear = lastDate.getFullYear() * 12 + lastDate.getMonth();
                    const currentMonthYear = currentDate.getFullYear() * 12 + currentDate.getMonth();
                    return Math.abs(currentMonthYear - lastMonthYear) > 1;
                });

                if (validPairs.length > 0) {
                    const rankedPairs = await Promise.all(validPairs.map(async (pair) => {
                        const score1Array = await rankPeopleByDesignationCount([pair.dirigente], designationName, ano, true);
                const score2Array = await rankPeopleByDesignationCount([pair.morador], designationName, ano, true);
                // Lemos o score do primeiro elemento do array retornado, com uma verificação de segurança
                const score1 = score1Array.length > 0 ? score1Array[0].totalDesignations : Infinity;
                const score2 = score2Array.length > 0 ? score2Array[0].totalDesignations : Infinity;
                // <<< FIM DA CORREÇÃO AQUI >>>
                return { pair, totalScore: score1 + score2 };
            }));
            rankedPairs.sort((a, b) => a.totalScore - b.totalScore);
            
            const bestPair = rankedPairs[0].pair;
            dirigenteSelect.value = bestPair.dirigente;
            moradorSelect.value = bestPair.morador;
            
            assignedPeopleThisWeek.add(bestPair.dirigente);
            assignedPeopleThisWeek.add(bestPair.morador);
            
            handleGenderSync(dirigenteSelect); 
        } else {
            console.warn(`autoFillDesignations - Nenhuma combinação de par válida encontrada para ${designationName}.`);
        }
    }
        }
    }
    // No final, faz uma validação geral para destacar quaisquer problemas
    setTimeout(validateAllSelections, 500);
};


async function getParticipationStatsForYear(ano) {
    // Se os dados para este ano já estiverem no cache, retorna-os imediatamente
    if (participationStatsCache.ano === ano && participationStatsCache.data) {
        return participationStatsCache.data;
    }

    console.log(`[STATS] Calculando estatísticas de participação para o ano ${ano}...`);
    const historicoSnapshot = await db.collection('historico')
                                      .where('ano', '==', ano)
                                      .where('quando', '==', 'Semana')
                                      .get();

    // Estrutura: Map<designacaoId, { total: number, participants: Set<personId>, counts: Map<personId, count> }>
    const stats = new Map();

    historicoSnapshot.forEach(doc => {
        const historico = doc.data();
        historico.designacoes?.forEach(desig => {
            const desigId = desig.designacaoId;
            if (!desigId) return;

            // Inicializa a estrutura para esta designação se for a primeira vez
            if (!stats.has(desigId)) {
                stats.set(desigId, {
                    total: 0,
                    participants: new Set(),
                    counts: new Map()
                });
            }
            const desigStats = stats.get(desigId);

            const allParticipantIds = Object.values(desig.participantes || {});
            allParticipantIds.forEach(pId => {
                desigStats.total++;
                desigStats.participants.add(pId);
                
                const currentCount = desigStats.counts.get(pId) || 0;
                desigStats.counts.set(pId, currentCount + 1);
            });
        });
    });

    // Agora, calcula a média para cada designação
    const finalData = new Map();
    for (const [desigId, desigStats] of stats.entries()) {
        const uniqueParticipantsCount = desigStats.participants.size;
        const average = uniqueParticipantsCount > 0 ? desigStats.total / uniqueParticipantsCount : 0;
        
        finalData.set(desigId, {
            average: average,
            counts: desigStats.counts
        });
    }

    // Guarda os dados calculados no cache antes de retornar
    participationStatsCache = { ano: ano, data: finalData };
    console.log("[STATS] Estatísticas calculadas e guardadas em cache.", finalData);
    return finalData;
}


// Função "inteligente" para calcular o contexto da semana anterior
async function getPreviousWeekContext(currentAno, currentMes, currentSemana) {
    if (currentSemana > 1) {
        // Caso simples: a semana anterior está no mesmo mês
        return { ano: currentAno, mes: currentMes, semana: currentSemana - 1 };
    } else {
        // Caso complexo: a semana anterior está no mês/ano anterior
        let prevMes = currentMes - 1;
        let prevAno = currentAno;
        if (prevMes === 0) {
            // Se o mês atual é Janeiro, voltamos para Dezembro do ano anterior
            prevMes = 12;
            prevAno = currentAno - 1;
        }
        // Descobrimos qual era a última semana desse mês anterior
        const ultimaSemanaDoMesAnterior = await countHistoricoSemanas(prevAno, prevMes);
        return { ano: prevAno, mes: prevMes, semana: ultimaSemanaDoMesAnterior };
    }
}

// Função "inteligente" para calcular o contexto da próxima semana
async function getNextWeekContext(currentAno, currentMes, currentSemana) {
    const totalSemanasNoMes = await getTotalSemanasNoMes(currentAno, currentMes);
    if (currentSemana < totalSemanasNoMes) {
        // Caso simples: a próxima semana está no mesmo mês
        return { ano: currentAno, mes: currentMes, semana: currentSemana + 1 };
    } else {
        // Caso complexo: a próxima semana está no próximo mês/ano
        let proxMes = currentMes + 1;
        let proxAno = currentAno;
        if (proxMes === 13) {
            // Se o mês atual é Dezembro, avançamos para Janeiro do próximo ano
            proxMes = 1;
            proxAno = currentAno + 1;
        }
        return { ano: proxAno, mes: proxMes, semana: 1 };
    }
}





// Função auxiliar para obter os participantes da semana anterior
const getParticipantsLastWeek = async (ano, mes, semanaNumero) => {
    try {
        const prevWeek = await getPreviousWeekContext(ano, mes, semanaNumero);
        
        console.log(`[VALIDATION] -> A procurar semana anterior com contexto: Ano=${prevWeek.ano}, Mês=${prevWeek.mes}, Semana=${prevWeek.semana}`);

        const q = db.collection('historico')
            // A MUDANÇA ESTÁ AQUI: Usamos o operador 'in' para apanhar tanto o número como o texto.
            .where("ano", "in", [prevWeek.ano, String(prevWeek.ano)]) 
            .where("mes", "==", prevWeek.mes)
            .where("semanaNumero", "==", prevWeek.semana);

        const snapshot = await q.get();
        const participants = new Set();
        
        if (!snapshot.empty) {
            snapshot.docs[0].data().designacoes.forEach(desig => {
                if (desig.participantes) {
                    Object.values(desig.participantes).forEach(personId => participants.add(personId.toString()));
                }
            });
        }
        console.log(`[VALIDATION] -> DADOS (Semana Anterior):`, participants);
        return participants;

    } catch (error) {
        console.error("Erro em getParticipantsLastWeek (versão robusta):", error);
        return new Set();
    }
};


// Função auxiliar para obter os participantes deste mês (até agora)
const getParticipantsThisMonth = async (ano, mes) => {
    const historicoRef = db.collection('historico');
    const q = historicoRef
        .where("ano", "==", ano)
        .where("mes", "==", mes)
        .where("quando", "==", "Semana");
        
    const snapshot = await q.get();
    const participants = new Set();
    
    snapshot.forEach(doc => {
        const historicoData = doc.data();
        if (historicoData.designacoes) {
            historicoData.designacoes.forEach(desig => {
                if (desig.participantes) {
                    Object.values(desig.participantes).forEach(personId => participants.add(personId.toString()));
                }
            });
        }
    });
    return participants;
};

            // --- Modificar Evento do Botão Turbo (já existente - manter) - REMOVENDO POPUP ---
            document.getElementById('turboButton').addEventListener('click', async function() {
                const rocketButton = this;
                rocketButton.classList.add('loading');

                try {
                    await autoFillDesignations();
                } finally {
                    rocketButton.classList.remove('loading');
                    rocketButton.classList.add('returning');

                    // Remove the 'returning' class after animation completes
                    setTimeout(() => {
                        rocketButton.classList.remove('returning');
                    }, 1000);
                }
            });


            // **MODIFIED: Evento de clique dos botões de ordenar (já existente - manter)**
            document.querySelectorAll('#designacoesList').forEach(designacoesList => {
                designacoesList.addEventListener('click', async function(event) {
                    if (event.target.classList.contains('order-button')) {
                        const orderButton = event.target;
                        const designacaoItem = orderButton.closest('.designacao-item');
                        const designacaoId = designacaoItem.dataset.designacaoId;
                        const quantitySubmenu = designacaoItem.querySelector('.quantity-submenu');
                        let nextOrderNumber = getNextOrderNumber();
                        const leituraBibliaSection = document.getElementById('leituraBibliaSection'); // Get Leitura Bíblia section

                        let currentOrderValue = parseInt(orderButton.dataset.order) || 0;
                        let currentQuantity = parseInt(orderButton.dataset.quantity) || 0;

                        if (currentOrderValue === 0) {
                            currentOrderValue = nextOrderNumber;
                            if (currentQuantity === 0) {
                                currentQuantity = 1;
                                orderButton.dataset.quantity = currentQuantity;
                                updateQuantitySubmenuSelection(quantitySubmenu, currentQuantity);
                            }
                        } else {
                            currentOrderValue = 0;
                            currentQuantity = 0;
                            orderButton.dataset.quantity = currentQuantity;
                            updateQuantitySubmenuSelection(quantitySubmenu, currentQuantity);
                            // Remove all instances when un-ordering
                            for (let instanceIndex = 1; instanceIndex <= 7; instanceIndex++) { // Loop through max possible instances to ensure removal
                                removeActiveDesignationDisplay(designacaoId, instanceIndex);
                                removeLeituraBibliaDisplay(designacaoId, instanceIndex);
                            }
                            if (designacaoItem.querySelector('label > span').textContent === 'Leitura da Bíblia') {
                                leituraBibliaSection.style.display = 'none'; // Hide Leitura Bíblia Section if un-ordering Leitura Bíblia
                            }
                        }

                        orderButton.dataset.order = currentOrderValue;
                        orderButton.textContent = currentOrderValue > 0 ? currentOrderValue : '';

                        updateOrderButtonClasses(orderButton, currentOrderValue);
                        reIndexOrderNumbers();
                        quantitySubmenu.classList.toggle('active', currentOrderValue > 0);

                        // ** UPDATED:  Immediately update participant display after order change (já existente - manter)**
                        try {
                            const designacaoDoc = await db.collection('designacoes').doc(designacaoId).get();
                            if (designacaoDoc.exists) {
                                const designacaoData = designacaoDoc.data();
                                const designacaoInfo = {
                                    id: designacaoId,
                                    ordem: currentOrderValue,
                                    quantidade: currentQuantity,
                                    numeroParticipantes: designacaoData.numeroParticipantes,
                                    quemFaz: designacaoData.quemFaz,
                                    feitoPor: designacaoData.feitoPor,
                                    nome: designacaoData.nome
                                };
                                const diasSemanaDisplay = document.getElementById('weekDisplay').innerHTML; // Get diasSemana again
                                const diasSemanaMatch = diasSemanaDisplay.match(/\((.*?)\)/);
                                const diasSemana = diasSemanaMatch ? diasSemanaMatch[1] : null;

                                const horariosData = await getHorariosFromFirebase(await getAnoPainelFirebase()); // Fetch horariosData
                                const diaSemanaReuniaoString = horariosData['dia-semana']; // Get diaSemanaReuniaoString

                                updateActiveDesignationDisplay(designacaoInfo, currentOrderValue, currentQuantity, {}, diasSemana, diaSemanaReuniaoString, temporaryPreferences); // Call update display and pass diasSemana and diaSemanaReuniaoString
                                 if (designacaoInfo.nome === 'Leitura da Bíblia' && currentOrderValue > 0) {
                                    leituraBibliaSection.style.display = 'block'; // Ensure section is visible when ordering Leitura Bíblia
                                }
                            }
                        } catch (error) {
                            console.error('Erro ao buscar detalhes da designação:', error);
                        }
                    }
                });
            });


            // Funções auxiliares para o evento de clique dos botões de ordenar (para manter o código mais organizado) (já existente - manter)
            const getNextOrderNumber = () => {
                const designacaoItems = document.querySelectorAll('#designacoesList .designacao-item');
                let maxOrder = 0;
                designacaoItems.forEach(item => {
                    const orderButton = item.querySelector('.order-button');
                    const order = parseInt(orderButton.dataset.order) || 0;
                    maxOrder = Math.max(maxOrder, order);
                });
                return maxOrder + 1;
            };

            const updateQuantitySubmenuSelection = (quantitySubmenu, quantity) => {
                quantitySubmenu.querySelectorAll('.quantity-button').forEach(btn => {
                    if (parseInt(btn.dataset.quantityValue) === quantity) {
                        btn.classList.add('selected');
                    } else {
                        btn.classList.remove('selected');
                    }
                });
            };

            const updateOrderButtonClasses = (orderButton, orderValue) => {
                orderButton.classList.remove('ordered', 'ordered-level-2', 'ordered-level-3');
                if (orderValue > 0) {
                    orderButton.classList.add('ordered');
                    if (orderValue >= 2) orderButton.classList.add('ordered-level-2');
                    if (orderValue >= 3) orderButton.classList.add('ordered-level-3');
                }
            };


            // **MODIFIED: Evento de submit do formulário "Iniciar Fluxo" - REMOVED POPUP on submit, keeping for summary (já existente - manter)**
            document.getElementById('fluxoSemanalForm').addEventListener('submit', async function(e) {
                e.preventDefault();

                // Prepare summary content
                const summaryHTML = await generatePopupSummary();
                document.getElementById('popupDesignationSummary').innerHTML = summaryHTML;

                // Show the popup
                document.getElementById('confirmationPopup').style.display = 'flex';
            });

            // Function to generate the summary HTML for the popup (já existente - manter)
            const generatePopupSummary = async () => {
                let summaryHTML = '';
                const activeDesignationContainers = document.querySelectorAll('#activeDesignationsContainer .active-designation-container, #leituraBibliaDesignationContainer .active-designation-container');

                for (const designationContainer of activeDesignationContainers) {
                    
                    const designacaoId = designationContainer.dataset.designacaoId;
                    const designacaoDoc = await db.collection('designacoes').doc(designacaoId).get();
                    const designacaoData = designacaoDoc.data();
                    const instances = designationContainer.querySelectorAll('.designacao-instance-container');

                    summaryHTML += `<div class="popup-designation-item">`;
                    summaryHTML += `<h4 class="popup-designacao-name">${designacaoData.nome}</h4>`;

                    for (let instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
                        const instanceContainer = instances[instanceIndex];
                        const participantSelects = instanceContainer.querySelectorAll('.form-select');
                        let instanceSummary = `<ul class="popup-participant-list">`;

                        for (const select of participantSelects) { // Changed forEach to for...of for await
                            const selectedPersonId = select.value;
                            if (selectedPersonId) {
                                try {
                                    const personDoc = await db.collection('pessoas').doc(selectedPersonId).get(); // Added await
                                    if (personDoc.exists) {
                                        const personData = personDoc.data();
                                        instanceSummary += `<li class="popup-participant-item">${personData.nomePessoa}</li>`;
                                    } else {
                                        instanceSummary += `<li class="popup-participant-item">Pessoa não encontrada</li>`;
                                    }
                                } catch (error) {
                                    instanceSummary += `<li class=\"popup-participant-item\">Erro ao carregar participante</li>`;
                                }
                            } else {
                                instanceSummary += `<li class=\"popup-participant-item\">Não selecionado</li>`;
                            }
                        }
                        instanceSummary += `</ul>`;
                        if (instances.length > 1) {
                            summaryHTML += `<h5>Designação ${instanceIndex + 1}</h5>`;
                        }
                        summaryHTML += instanceSummary;
                    }
                    summaryHTML += `</div>`;
                }
                return summaryHTML;
            };


            // Close popup event (já existente - manter)
            document.getElementById('closePopup').addEventListener('click', function() {
                document.getElementById('confirmationPopup').style.display = 'none';
            });

            // "Criar Fluxo Semanal" button event (já existente - manter)
document.getElementById('createFluxoSemanal').addEventListener('click', async function() {
                const confirmationPopup = document.getElementById('confirmationPopup');
                const titleElement = confirmationPopup.querySelector('.popup-title');
                const thinkingIcon = titleElement.querySelector('.thinking');
                const successIcon = titleElement.querySelector('.success');

                // Mostra o ícone de "a pensar"
                thinkingIcon.style.display = 'inline-block';
                successIcon.style.display = 'none';

                try {
                    // --- 1. Recolha de dados iniciais (sem alterações) ---
                    const ano = await getAnoPainelFirebase();
                    const mes = parseInt(document.getElementById('mes').value);
                    const semanaNumero = parseInt(document.getElementById('semanaNumero').value);
                    const tipoEvento = document.getElementById('tipo').value;
                    const idiomasSelecionados = Array.from(document.querySelectorAll('#nacionalidades input[name="nacionalidades"]:checked'))
                        .map(checkbox => checkbox.value);
                    const salaSelecionada = document.getElementById('sala').value;
                    const diasSemana = getDiasSemana(ano, mes, semanaNumero);
                    const horariosData = await getHorariosFromFirebase(ano);
                    const horaSemana = horariosData['hora-semana'];
                    const semanaIndexValue = `(${diasSemana} ${ano})`;

                    // --- 2. LÓGICA CONDICIONAL PARA DETERMINAR A DATA (A NOVA ALTERAÇÃO) ---
                    let meetingDayOfMonth;

                    if (tipoEvento === 'visita-servo') {
                        // Se for "Visita do Servo", busca a data diretamente do evento
                        console.log("DEBUG: 'Visita do Servo' detetada. A buscar data do evento...");
                        const eventosRef = db.collection('eventos');
                        const q = eventosRef.where('nome', '==', 'Visita do Servo').where('ano', '==', ano);
                        const snapshot = await q.get();

                        if (!snapshot.empty) {
                            const eventData = snapshot.docs[0].data();
                            meetingDayOfMonth = eventData.data; // Usa a data do evento
                            console.log(`DEBUG: Data do evento encontrada e definida como: ${meetingDayOfMonth}`);
                        } else {
                            // Fallback: se não encontrar o evento, calcula a data normalmente e avisa
                            console.warn(`AVISO: Evento 'Visita do Servo' para o ano ${ano} não encontrado na base de dados. A usar a data calculada da semana.`);
                            const diaSemanaReuniaoString = horariosData['dia-semana'];
                            meetingDayOfMonth = getMeetingDayOfMonth(ano, diasSemana, diaSemanaReuniaoString);
                        }
                    } else {
                        // Para todos os outros tipos de reunião ("normal", etc.), calcula a data como antes
                        const diaSemanaReuniaoString = horariosData['dia-semana'];
                        meetingDayOfMonth = getMeetingDayOfMonth(ano, diasSemana, diaSemanaReuniaoString);
                    }
                    
                    // --- 3. Construção do objeto para o histórico (agora usa a data correta) ---
                    const historicoData = {
                        ano: ano,
                        mes: mes,
                        semanaNumero: semanaNumero,
                        semanaindex: semanaIndexValue,
                        designacoes: [],
                        evento: tipoEvento,
                        tipo: "reuniao",
                        idioma: idiomasSelecionados,
                        sala: salaSelecionada,
                        dia: meetingDayOfMonth, // << AQUI USA A VARIÁVEL QUE FOI DEFINIDA CONDICIONALMENTE
                        hora: horaSemana,
                        quando: "Semana",
                        oque: "reuniao",
                        parte: "escola",
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    // --- 4. Processamento das designações e gravação (sem alterações) ---
                    const activeDesignationContainers = document.querySelectorAll('#activeDesignationsContainer .active-designation-container, #leituraBibliaDesignationContainer .active-designation-container');
                    for (const designationContainer of activeDesignationContainers) {
                        const designacaoId = designationContainer.dataset.designacaoId;
                        const instances = designationContainer.querySelectorAll('.designacao-instance-container');
                        for (let instanceIndex = 0; instanceIndex < instances.length; instanceIndex++) {
                            const instanceContainer = instances[instanceIndex];
                            const participantSelects = instanceContainer.querySelectorAll('.form-select');
                            const participantesPorFuncao = {};
                            const numParticipantes = participantSelects.length;

                            if (numParticipantes === 1 && participantSelects[0].value) {
                                participantesPorFuncao.participante = participantSelects[0].value;
                            } else if (numParticipantes === 2) {
                                if (participantSelects[0].value) participantesPorFuncao.dirigente = participantSelects[0].value;
                                if (participantSelects[1].value) participantesPorFuncao.morador = participantSelects[1].value;
                            } else if (numParticipantes >= 3) {
                                if (participantSelects[0].value) participantesPorFuncao.dirigente = participantSelects[0].value;
                                if (participantSelects[1].value) participantesPorFuncao.morador = participantSelects[1].value;
                                if (participantSelects[2].value) participantesPorFuncao.ajudante = participantSelects[2].value;
                            }

                            if (Object.keys(participantesPorFuncao).length > 0) {
                                historicoData.designacoes.push({
                                    designacaoId: designacaoId,
                                    instanceIndex: instanceIndex,
                                    participantes: participantesPorFuncao
                                });
                            }
                        }
                    }

                    await db.collection("historico").add(historicoData);
                    await saveParticipationHistoryForIndividuals(historicoData);

                    // Mostra o ícone de sucesso
                    thinkingIcon.style.display = 'none';
                    successIcon.style.display = 'inline-block';

                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);

                } catch (error) {
                    console.error("Erro ao adicionar documento: ", error);
                    thinkingIcon.style.display = 'none';
                    successIcon.style.display = 'none';
                    alert('Erro ao criar fluxo semanal: ' + error.message);
                }
            });



            // --- Helper function to get day of week number (Sunday: 0, Monday: 1, ..., Saturday: 6) (já existente - manter) ---
            function getDayOfWeekNumber(dayOfWeekString) {
                const daysOfWeek = {
                    'domingo': 0, 'segunda': 1, 'terça': 2, 'quarta': 3, 'quinta': 4, 'sexta': 5, 'sábado': 6,
                    'domingo-feira': 0, 'segunda-feira': 1, 'terça-feira': 2, 'quarta-feira': 3, 'quinta-feira': 4, 'sexta-feira': 5, 'sábado-feira': 6
                };
                const normalizedDayOfWeekString = dayOfWeekString.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(); // Normalize and remove accents
                return daysOfWeek[normalizedDayOfWeekString] !== undefined ? daysOfWeek[normalizedDayOfWeekString] : null;
            }


          // --- Helper function to get meeting day of month (CORRIGIDA) ---
function getMeetingDayOfMonth(ano, diasSemanaString, diaSemanaReuniao) {
    if (!diasSemanaString || !diaSemanaReuniao || !ano) {
        console.error("[getMeetingDayOfMonth] Erro: Faltam parâmetros essenciais (ano, diasSemanaString, ou diaSemanaReuniao).");
        return null;
    }

    try {
        const parts = diasSemanaString.split(" - ");
        if (parts.length < 2) return null;

        // Extrai o dia e o mês de início
        const startParts = parts[0].split(" ");
        const startDay = parseInt(startParts[0]);
        let startMonthStr = startParts.length > 1 ? startParts[1] : null;

        // Extrai o dia e o mês de fim
        const endParts = parts[1].split(" ");
        const endDay = parseInt(endParts[0]);
        const endMonthStr = endParts[1];

        const monthNames = ["Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
        
        // Se o mês não estiver na parte inicial (ex: "24 - 30 Jul"), usa o mês final
        if (!startMonthStr) {
            startMonthStr = endMonthStr;
        }

        const startMonthIndex = monthNames.indexOf(startMonthStr);
        const endMonthIndex = monthNames.indexOf(endMonthStr);

        if (startMonthIndex === -1 || endMonthIndex === -1) return null;

        const dayOfWeekMeetingNumber = getDayOfWeekNumber(diaSemanaReuniao);
        if (dayOfWeekMeetingNumber === null) return null;

        // Usa o ANO recebido para criar as datas, corrigindo o bug
        const startOfWeekDate = new Date(ano, startMonthIndex, startDay);
        const endOfWeekDate = new Date(ano, endMonthIndex, endDay);

        let currentDay = startOfWeekDate;
        while (currentDay <= endOfWeekDate) {
            if (currentDay.getDay() === dayOfWeekMeetingNumber) {
                const month = String(currentDay.getMonth() + 1).padStart(2, '0');
                const day = String(currentDay.getDate()).padStart(2, '0');
                // Retorna a data formatada corretamente
                return `${ano}-${month}-${day}`;
            }
            currentDay.setDate(currentDay.getDate() + 1);
        }
        return null; // Retorna null se não encontrar o dia na semana

    } catch (error) {
        console.error("[getMeetingDayOfMonth] Ocorreu uma exceção ao calcular a data:", error);
        return null;
    }
}








            const loadDesignacoes = async () => { // (já existente - manter)
                const designacoesRef = db.collection('designacoes');
                const query = designacoesRef
                    .where('tipo', '==', 'reuniao')
                    .where('quando', '==', 'Semana')
                    .where('parte', '==', 'escola')
                     .orderBy('ordem');
                const snapshot = await query.get();
                const designacoesList = document.getElementById('designacoesList');
                designacoesList.innerHTML = '';
                let nextOrderNumber = 1;
                let leituraBibliaDesignacao = null; // To store Leitura da Bíblia data

                const horariosData = await getHorariosFromFirebase(await getAnoPainelFirebase()); // Fetch horariosData here
                const diaSemanaReuniaoString = horariosData['dia-semana']; // Get diaSemanaReuniaoString

                const diasSemanaDisplay = document.getElementById('weekDisplay').innerHTML; // Get diasSemana
                const diasSemanaMatch = diasSemanaDisplay.match(/\((.*?)\)/);
                const diasSemana = diasSemanaMatch ? diasSemanaMatch[1] : null;


                for (const doc of snapshot.docs) { // Use for...of loop for synchronous processing
                    const designacao = doc.data();
                    const div = document.createElement('div');
                    div.className = 'designacao-item';
                    div.dataset.designacaoId = doc.id;

                    // Create order button
                    const orderButton = document.createElement('button');
                    orderButton.type = 'button'; // Explicitly set type="button" - IMPORTANT
                    orderButton.className = 'order-button';
                    let designationOrder = 0;
                    let designationQuantity = 0;
                    if (designacao.nome === 'Leitura da Bíblia') {
                        designationOrder = nextOrderNumber++;
                        designationQuantity = 1;
                        leituraBibliaDesignacao = { ...designacao, id: doc.id, ordem: designationOrder, quantidade: designationQuantity }; // Store Leitura da Bíblia data and default order/quantity
                    }
                    orderButton.dataset.order = designationOrder;
                    orderButton.dataset.quantity = designationQuantity;
                    orderButton.textContent = designationOrder > 0 ? designationOrder : '';

                    if (designationOrder > 0) {
                        orderButton.classList.add('ordered');
                        if (designationOrder >= 2) orderButton.classList.add('ordered-level-2');
                        if (designationOrder >= 3) orderButton.classList.add('ordered-level-3');
                    }

                    // Create label
                    const label = document.createElement('label');
                    label.setAttribute('for', doc.id);
                    label.style.marginBottom = '0';
                    label.style.flexGrow = '1';
                    label.style.display = 'flex';

                    label.appendChild(orderButton);
                    const textSpan = document.createElement('span');
                    textSpan.textContent = designacao.nome;
                    label.appendChild(textSpan);

                    div.appendChild(label);

                    // Create quantity submenu
                    const quantitySubmenu = createQuantitySubmenu(doc.id, designationQuantity, orderButton); // Helper function to create submenu
                    div.appendChild(quantitySubmenu);

                    designacoesList.appendChild(div);
                }

                // After loading all designations, if Leitura da Bíblia was found and ordered, display it
                if (leituraBibliaDesignacao) { // Check if leituraBibliaDesignacao is not null
                    updateLeituraBibliaDisplay(leituraBibliaDesignacao, leituraBibliaDesignacao.ordem, leituraBibliaDesignacao.quantidade, {}, diasSemana, diaSemanaReuniaoString); // pass diaSemanaReuniaoString here
                }
            };



            // Função principal que abre o popup de análise de par
            async function openPairAnalysisPopup(participants) {
    const popup = document.getElementById('pairAnalysisPopup');
    const title = document.getElementById('pairAnalysisTitle');
    const tabsContainer = document.getElementById('pairAnalysisTabsContainer');
    const contentContainer = document.getElementById('pairAnalysisContentContainer');

    tabsContainer.innerHTML = 'A carregar...';
    contentContainer.innerHTML = '';

    const participantNames = participants.map(p => p.name).join(' & ');
    title.textContent = `Análise de: ${participantNames}`;
    popup.style.display = 'flex';

    const participantIds = participants.map(p => p.id);
    const pairHistory = await fetchPairHistory(participantIds);

    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    // =================================================================
    // =========== INÍCIO: CORREÇÃO NOS NOMES DOS ALVOS E IDs ==========
    // =================================================================
    // Aba 1: Histórico do Par - O alvo AGORA é "content-history"
    const historyTab = createTab('Histórico do Par', 'content-history', true);
    const historyContent = createTabContent('content-history', true);
    historyContent.appendChild(buildHistoryTable(pairHistory, "Histórico de Colaboração"));
    tabsContainer.appendChild(historyTab);
    contentContainer.appendChild(historyContent);
    
    // Abas 2, 3, ...: Perfis Individuais - O alvo AGORA é "content-pX"
    participants.forEach((participant, index) => {
        const tab = createTab(participant.name, `content-p${index}`, false);
        const content = createTabContent(`content-p${index}`, false);
        content.innerHTML = `<p>A carregar perfil de ${participant.name}...</p>`;
        
        tabsContainer.appendChild(tab);
        contentContainer.appendChild(content);

        tab.addEventListener('click', async () => {
            if (content.dataset.loaded !== 'true') {
                const individualHistory = await fetchIndividualHistory(participant.id);
                content.innerHTML = '';
                content.appendChild(buildHistoryTable(individualHistory, `Histórico Completo de ${participant.name}`));
                content.dataset.loaded = 'true';
            }
        });
    });
    // =================================================================
    // ============ FIM: CORREÇÃO NOS NOMES DOS ALVOS E IDs ============
    // =================================================================

    setupTabClickListeners();
}


// Função para buscar o histórico onde TODOS os participantes estiveram juntos
async function fetchPairHistory(participantIds) {
    const historicoSnapshot = await db.collection('historico').get();
    const records = [];
    historicoSnapshot.forEach(doc => {
        const historico = doc.data();
        if (historico.designacoes && Array.isArray(historico.designacoes)) {
            historico.designacoes.forEach(designacao => {
                const allParticipantIdsInDesig = Object.values(designacao.participantes);
                // Verifica se TODOS os IDs do nosso par estão na designação
                const allMembersPresent = participantIds.every(id => allParticipantIdsInDesig.includes(id));
                if (allMembersPresent) {
                    records.push({
                        dia: historico.dia,
                        designacaoNome: allDesignations.get(designacao.designacaoId) || 'Desconhecida',
                        papeis: designacao.participantes
                    });
                }
            });
        }
    });
    return records.sort((a, b) => new Date(b.dia) - new Date(a.dia));
}

// Reutilizar a sua lógica de buscar histórico, mas de forma mais simples
async function fetchIndividualHistory(personId) {
    const historicoSnapshot = await db.collection('historico').get();
    let records = [];

    historicoSnapshot.forEach(doc => {
        const historico = doc.data();
        if (historico.designacoes && Array.isArray(historico.designacoes)) {
            historico.designacoes.forEach(designacao => {
                
                // Primeiro, verifica se a pessoa participou, independentemente do formato
                let allParticipantIdsInDesig = [];
                if (Array.isArray(designacao.participantes)) {
                    allParticipantIdsInDesig = designacao.participantes;
                } else if (designacao.participantes && typeof designacao.participantes === 'object') {
                    allParticipantIdsInDesig = Object.values(designacao.participantes);
                }

                if (allParticipantIdsInDesig.includes(personId)) {
                    
                    // ==========================================================
                    // INÍCIO: LÓGICA INTELIGENTE PARA DETERMINAR OS PAPÉIS
                    // ==========================================================
                    let papeisCorrigidos = {};
                    if (Array.isArray(designacao.participantes)) {
                        // Se for um array, vamos assumir os papéis pela posição
                        if(designacao.participantes[0]) papeisCorrigidos.Dirigente = designacao.participantes[0];
                        if(designacao.participantes[1]) papeisCorrigidos.Morador = designacao.participantes[1];
                        if(designacao.participantes[2]) papeisCorrigidos.Ajudante = designacao.participantes[2];
                    } else {
                        // Se já for um objeto, usa-o diretamente
                        papeisCorrigidos = designacao.participantes;
                    }
                    // ==========================================================
                    // FIM: LÓGICA INTELIGENTE PARA DETERMINAR OS PAPÉIS
                    // ==========================================================

                    records.push({
                        dia: historico.dia, // Garanta que todos os docs de histórico têm este campo
                        designacaoNome: allDesignations.get(designacao.designacaoId) || 'Designação Desconhecida',
                        papeis: papeisCorrigidos // Usa o nosso novo objeto de papéis corrigido
                    });
                }
            });
        }
    });

    return records.sort((a, b) => new Date(b.dia) - new Date(a.dia));
}

async function loadAllDesignationsMap() {
    try {
        const designacoesSnapshot = await db.collection('designacoes').get();
        // Limpa o Map e preenche-o com os dados mais recentes
        allDesignations = new Map(); 
        designacoesSnapshot.forEach(doc => {
            allDesignations.set(doc.id, doc.data().nome);
        });
        console.log("Mapa global de designações carregado com sucesso.");
    } catch (error) {
        console.error("Erro ao carregar o mapa global de designações:", error);
    }
}

// Funções de ajuda para criar os elementos das abas
function createTab(text, target, isActive) {
    const button = document.createElement('button');
    button.className = 'tab-button' + (isActive ? ' active' : '');
    button.textContent = text;
    button.dataset.target = '#' + target;
    return button;
}
function createTabContent(id, isActive) {
    const div = document.createElement('div');
    div.className = 'tab-content' + (isActive ? ' active' : '');
    div.id = id;
    return div;
}

// Lógica de clique para as abas
function setupTabClickListeners() {
    const tabs = document.querySelectorAll('.analysis-popup .tab-button');
    const contents = document.querySelectorAll('.analysis-popup .tab-content');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            document.querySelector(tab.dataset.target).classList.add('active');
        });
    });
}

// Lógica para o botão de fechar o novo popup
document.getElementById('closePairAnalysisPopup').addEventListener('click', () => {
    document.getElementById('pairAnalysisPopup').style.display = 'none';
});

function buildHistoryTable(records, titleText) {
    const container = document.createElement('div');
    
    const title = document.createElement('h3');
    title.style.marginBottom = '15px';
    title.textContent = titleText;
    container.appendChild(title);

    if (!records || records.length === 0) {
        container.innerHTML += '<p>Nenhum histórico encontrado para os critérios selecionados.</p>';
        return container;
    }

    const table = document.createElement('table');
    table.className = 'estatisticas-table'; // Reutiliza o estilo da sua tabela de estatísticas

    table.innerHTML = `
        <thead>
            <tr>
                <th>Data</th>
                <th>Designação</th>
                <th>Papéis Desempenhados</th>
            </tr>
        </thead>
    `;

    const tbody = document.createElement('tbody');
    records.forEach(record => {
        const tr = document.createElement('tr');
        
        // Formata a data (reutiliza a sua função existente)
        const formattedDate = formatDateForDisplay(record.dia); 
        
        // Formata os papéis para serem mais legíveis
        let rolesHtml = '<ul style="padding-left: 15px; margin: 0;">';
        if (record.papeis && typeof record.papeis === 'object') {
            for (const [role, personId] of Object.entries(record.papeis)) {
                // `allPeopleDataMap` é o Map que você já carrega para outros fins
                const personName = allPeopleDataMap.get(personId) || 'Participante Desconhecido';
                const formattedRole = role.charAt(0).toUpperCase() + role.slice(1);
                rolesHtml += `<li><strong>${formattedRole}:</strong> ${personName}</li>`;
            }
        } else {
            rolesHtml += '<li>Informação de papéis indisponível</li>';
        }
        rolesHtml += '</ul>';

        tr.innerHTML = `
            <td>${formattedDate}</td>
            <td>${record.designacaoNome}</td>
            <td>${rolesHtml}</td>
        `;
        tbody.appendChild(tr);
    });
    
    table.appendChild(tbody);
    container.appendChild(table);
    
    return container;
}

// ======================================================================== //
// ============  NOVA FUNÇÃO: OBTER PARTICIPANTES DA SEMANA SEGUINTE ====== //
// ======================================================================== //

const getParticipantsNextWeek = async (ano, mes, semanaNumero) => {
    try {
        const nextWeek = await getNextWeekContext(ano, mes, semanaNumero);

        console.log(`[VALIDATION] -> A procurar próxima semana com contexto: Ano=${nextWeek.ano}, Mês=${nextWeek.mes}, Semana=${nextWeek.semana}`);

        const q = db.collection('historico')
            // A MUDANÇA ESTÁ AQUI: Usamos o operador 'in' para apanhar tanto o número como o texto.
            .where("ano", "in", [nextWeek.ano, String(nextWeek.ano)])
            .where("mes", "==", nextWeek.mes)
            .where("semanaNumero", "==", nextWeek.semana)
            .where("quando", "==", "Semana");

        const snapshot = await q.get();
        const participants = new Set();
        
        if (!snapshot.empty) {
            snapshot.docs[0].data().designacoes.forEach(desig => {
                if (desig.participantes) {
                    Object.values(desig.participantes).forEach(personId => participants.add(personId.toString()));
                }
            });
        }
        console.log(`[VALIDATION] -> DADOS (Semana Seguinte):`, participants);
        return participants;

    } catch (error) {
        console.error("Erro em getParticipantsNextWeek (versão robusta):", error);
        return new Set();
    }
};



const saveParticipationHistoryForIndividuals = async (historicoData) => {
    try {
        // Usamos um Map para agrupar todas as designações por participante numa única passagem.
        // A chave será o ID da pessoa, e o valor será o objeto de histórico personalizado para ela.
        const participantsMap = new Map();

        // Itera sobre cada designação da semana
        for (const designacao of historicoData.designacoes) {
            // Itera sobre cada participante dentro da designação (dirigente, morador, etc.)
            for (const personId of Object.values(designacao.participantes)) {

                // Se o participante ainda não está no nosso mapa, inicializa os seus dados.
                if (!participantsMap.has(personId)) {
                    // Cria uma cópia do histórico principal, mas com um array de designações vazio.
                    const personHistoryData = {
                        ...historicoData, // Copia todos os campos: ano, mes, dia, tipo, etc.
                        designacoes: []   // Começa com uma lista de designações vazia
                    };
                    participantsMap.set(personId, personHistoryData);
                }

                // Adiciona a designação atual à lista de designações daquela pessoa para esta semana.
                participantsMap.get(personId).designacoes.push(designacao);
            }
        }

        // Agora, `participantsMap` contém um registo para cada pessoa com apenas as suas próprias designações.
        // Vamos criar uma promessa de gravação para cada um.
        const savePromises = [];

        for (const [personId, personHistoryData] of participantsMap.entries()) {
            // Constrói a referência para a subcoleção correta.
            // Ex: db.collection('pessoas').doc('ID_DA_MARIA').collection('2024')
            const personHistoryCollectionRef = db.collection('pessoas')
                                                 .doc(personId)
                                                 .collection(String(historicoData.ano)); // O nome da coleção é o ano.

            // Adiciona a promessa de gravação ao nosso array.
            savePromises.push(personHistoryCollectionRef.add(personHistoryData));
        }

        // Executa todas as gravações em paralelo para maior eficiência.
        await Promise.all(savePromises);
        console.log("Histórico de participação individual salvo com sucesso para todos os participantes.");

    } catch (error) {
        console.error("Erro ao salvar o histórico de participação individual:", error);
        // Opcional: Adicionar tratamento de erro, embora o erro principal seja capturado na função chamadora.
    }
};






            const createQuantitySubmenu = (designacaoId, designationQuantity, orderButton) => { // (já existente - manter)
                const quantitySubmenu = document.createElement('div');
                quantitySubmenu.className = 'quantity-submenu';
                quantitySubmenu.dataset.designacaoId = designacaoId;
                for (let i = 1; i <= 7; i++) {
                    const quantityButton = document.createElement('button');
                    quantityButton.className = 'quantity-button';
                    quantityButton.textContent = i;
                    quantityButton.dataset.quantityValue = i;
                    if (i === designationQuantity) {
                        quantityButton.classList.add('selected');
                    }
                    quantityButton.addEventListener('click', async (e) => { // ADDED ASYNC
                        e.preventDefault(); // ADDED preventDefault - IMPORTANT
                        e.stopPropagation(); // Ensure event propagation is stopped - CHECK THIS LINE


                        const selectedQuantity = parseInt(quantityButton.dataset.quantityValue);
                        orderButton.dataset.quantity = selectedQuantity;

                        quantitySubmenu.querySelectorAll('.quantity-button').forEach(btn => btn.classList.remove('selected'));
                        quantityButton.classList.add('selected');
                        quantitySubmenu.classList.remove('active');

                        // **--- FIX: Call updateActiveDesignationDisplay here ---**
                        const designacaoIdForUpdate = quantitySubmenu.dataset.designacaoId;
                        try {
                            const designacaoDoc = await db.collection('designacoes').doc(designacaoIdForUpdate).get();
                            if (designacaoDoc.exists) {
                                const designacaoData = designacaoDoc.data();
                                // Initialize temporaryPreferences for each instance
                                for (let i = 1; i <= selectedQuantity; i++) {
                                    const instanceKey = `participantes-${designacaoIdForUpdate}-${i}`;
                                    if (!temporaryPreferences[instanceKey]) {
                                        temporaryPreferences[instanceKey] = designacaoData.numeroParticipantes || 1;
                                    }
                                }
                                const designacaoInfo = {
                                    id: designacaoIdForUpdate,
                                    ordem: parseInt(orderButton.dataset.order) || 0, // Get current order
                                    quantidade: selectedQuantity,
                                    numeroParticipantes: designacaoData.numeroParticipantes,
                                    quemFaz: designacaoData.quemFaz,
                                    feitoPor: designacaoData.feitoPor,
                                    nome: designacaoData.nome
                                };
                                const diasSemanaDisplay = document.getElementById('weekDisplay').innerHTML; // Get diasSemana again
                                const diasSemanaMatch = diasSemanaDisplay.match(/\((.*?)\)/);
                                const diasSemana = diasSemanaMatch ? diasSemanaMatch[1] : null;
                                const horariosData = await getHorariosFromFirebase(await getAnoPainelFirebase()); // Fetch horariosData
                                const diaSemanaReuniaoString = horariosData['dia-semana']; // Get diaSemanaReuniaoString
                                updateActiveDesignationDisplay(designacaoInfo, designacaoInfo.ordem, selectedQuantity, {}, diasSemana, diaSemanaReuniaoString, temporaryPreferences); // **Pass temporaryPreferences here**
                            }
                        } catch (error) {
                            console.error('Erro ao buscar detalhes da designação para atualizar display:', error);
                        }
                    });
                    quantitySubmenu.appendChild(quantityButton);
                }
                return quantitySubmenu;
            };

            function saveSelectionsForDesignation(designacaoId) {
                // Inicializa ou limpa o estado para esta designação
                participantSelections[designacaoId] = {};

                const allInstances = document.querySelectorAll(`.active-designation-container[data-designacao-id="${designacaoId}"]`);

                allInstances.forEach(container => {
                    // Extrai o número da instância a partir do ID do container
                    const instanceNumber = parseInt(container.id.split('-').pop());
                    if (!isNaN(instanceNumber)) {
                        const selects = container.querySelectorAll('.form-select');
                        // Guarda um array com os valores dos dropdowns para esta instância
                        participantSelections[designacaoId][instanceNumber] = Array.from(selects).map(s => s.value);
                    }
                });
            }





     const updateActiveDesignationDisplay = async (designacao, order, quantity, instancePreferences = {}, diasSemana, diaSemanaReuniaoString, temporaryPreferences = {}) => {
    const designacaoId = designacao.id;

    // PASSO 1: SALVA O ESTADO ATUAL (OS NOMES SELECIONADOS) ANTES DE FAZER QUALQUER ALTERAÇÃO VISUAL
    saveSelectionsForDesignation(designacaoId);

    const isLeituraBiblia = designacao.nome === 'Leitura da Bíblia';
    const containerToUse = isLeituraBiblia ? document.getElementById('leituraBibliaDesignationContainer') : document.getElementById('activeDesignationsContainer');

    // Remove os cards que já não são necessários (se a quantidade diminuiu)
    const existingContainers = containerToUse.querySelectorAll(`.active-designation-container[data-designacao-id="${designacaoId}"]`);
    existingContainers.forEach(container => {
        const instanceNum = parseInt(container.id.split('-').pop());
        if (instanceNum > quantity) {
            container.remove();
        }
    });

    if (quantity <= 0) {
        return;
    }

    // Loop através de cada instância para criar ou atualizar os seus containers
    for (let designacaoInstance = 1; designacaoInstance <= quantity; designacaoInstance++) {
        let designationDisplayContainer;
        const containerId = `active-designation-${designacaoId}-${designacaoInstance}`;
        let existingDisplay = containerToUse.querySelector(`#${containerId}`);

        if (!existingDisplay) {
            designationDisplayContainer = document.createElement('div');
            designationDisplayContainer.id = containerId;
            designationDisplayContainer.className = 'active-designation-container';
            designationDisplayContainer.style.marginTop = '20px';
            designationDisplayContainer.style.padding = '15px';
            designationDisplayContainer.style.borderRadius = '8px';
            designationDisplayContainer.dataset.designacaoId = designacao.id;
            containerToUse.appendChild(designationDisplayContainer);
        } else {
            designationDisplayContainer = existingDisplay;
            designationDisplayContainer.innerHTML = ''; // Limpa o conteúdo para reconstruir
        }

        const designacaoInstanceContainer = document.createElement('div');
        designacaoInstanceContainer.className = 'designacao-instance-container';
        designacaoInstanceContainer.style.marginBottom = '20px';

        const orderLevel = designacao.ordem || 0;
        if (orderLevel === 1) { designationDisplayContainer.style.backgroundColor = 'rgba(46, 204, 113, 0.1)'; } 
        else if (orderLevel === 2) { designationDisplayContainer.style.backgroundColor = 'rgba(52, 152, 219, 0.1)'; }
        else if (orderLevel === 3) { designationDisplayContainer.style.backgroundColor = 'rgba(243, 156, 18, 0.1)'; }
        else if (orderLevel === 4) { designationDisplayContainer.style.backgroundColor = 'rgba(155, 89, 182, 0.1)'; }
        else if (orderLevel === 5) { designationDisplayContainer.style.backgroundColor = 'rgba(231, 76, 60, 0.1)'; }
        else if (orderLevel === 6) { designationDisplayContainer.style.backgroundColor = 'rgba(26, 188, 156, 0.1)'; }
        else if (orderLevel === 7) { designationDisplayContainer.style.backgroundColor = 'rgba(241, 196, 15, 0.1)'; }
        else { designationDisplayContainer.style.backgroundColor = '#f8f9fa'; }

        const title = document.createElement('h5');
        title.textContent = `${designacao.nome || designacaoId} (${designacaoInstance})`;
        title.style.marginBottom = '10px';
        designacaoInstanceContainer.appendChild(title);

        // --- LÓGICA DE PREFERÊNCIAS (AGORA CENTRALIZADA) ---
        const instanceKeyPrefix = `${designacaoId}-${designacaoInstance}`;
        const keyNumParticipantes = `numParticipantes-${instanceKeyPrefix}`;
        const keyGeneroPref = `generoPreferencia-${instanceKeyPrefix}`;
        const keyGeneroMix = `generoMix-${instanceKeyPrefix}`;

        let numeroParticipantesDynamic = parseInt(temporaryPreferences[keyNumParticipantes]) || designacao.numeroParticipantes || 1;
        let generoPreferencia = temporaryPreferences[keyGeneroPref] || (designacao.feitoPor ? designacao.feitoPor.toLowerCase() : 'masculino feminino');
        let generoMix = temporaryPreferences[keyGeneroMix] || 'nao';

        const participantRoles = [];
        if (numeroParticipantesDynamic === 1) { participantRoles.push("Dirigente"); } 
        else if (numeroParticipantesDynamic === 2) { participantRoles.push("Dirigente", "Morador"); } 
        else if (numeroParticipantesDynamic === 3) { participantRoles.push("Dirigente", "Morador", "Ajudante"); }

        for (let i = 0; i < numeroParticipantesDynamic; i++) {
            const roleLabel = document.createElement('span');
            roleLabel.textContent = (numeroParticipantesDynamic > 1) ? participantRoles[i] : `Participante`;
            roleLabel.style.fontSize = '0.9em'; roleLabel.style.color = '#777'; roleLabel.style.display = 'block'; roleLabel.style.marginBottom = '3px';
            designacaoInstanceContainer.appendChild(roleLabel);

            let participantSelect = document.createElement('select');
            participantSelect.id = `participant-${designacaoId}-${designacaoInstance}-${i}`;
            participantSelect.className = 'form-select';
            participantSelect.style.marginBottom = '10px'; participantSelect.style.width = '100%';
            participantSelect.innerHTML = '<option value="">Selecione uma pessoa</option>';

            if (participantSelections[designacaoId] && participantSelections[designacaoId][designacaoInstance] && participantSelections[designacaoId][designacaoInstance][i]) {
                participantSelect.value = participantSelections[designacaoId][designacaoInstance][i];
            }
            participantSelect.addEventListener('change', () => {
                saveSelectionsForDesignation(designacaoId);
            });
            designacaoInstanceContainer.appendChild(participantSelect);
        }

        designationDisplayContainer.appendChild(designacaoInstanceContainer);
        designationDisplayContainer.style.position = 'relative';

        const filterIcon = document.createElement('i');
        filterIcon.className = 'fas fa-filter filter-icon';
        filterIcon.title = 'Filtrar';

        const filterPopup = document.createElement('div');
        filterPopup.className = 'filter-popup';
        filterPopup.innerHTML = `
            <h4>Filtros</h4>
            <div class="filter-options">
                <label for="num-participantes-${designacaoInstance}">Número de Participantes</label>
                <select id="num-participantes-${designacaoInstance}">
                    <option value="1">1</option> <option value="2">2</option> <option value="3">3</option>
                </select>
            </div>
            <div class="filter-options" style="margin-top: 15px;">
                <label for="genero-preferencia-${designacaoInstance}">Preferência de Género</label>
                <select id="genero-preferencia-${designacaoInstance}">
                    <option value="masculino feminino">Masculino/Feminino</option>
                    <option value="masculino">Masculino</option>
                    <option value="feminino">Feminino</option>
                </select>
            </div>
            <div class="filter-options" style="margin-top: 15px;">
                <label for="genero-mix-${designacaoInstance}">Masculino com Feminino</label>
                <select id="genero-mix-${designacaoInstance}" class="gender-mix-select">
                    <option value="nao">Não</option> <option value="sim">Sim</option>
                </select>
            </div>
        `;

        // Configura e adiciona listeners aos filtros
        const numParticipantesSelect = filterPopup.querySelector(`#num-participantes-${designacaoInstance}`);
        numParticipantesSelect.value = numeroParticipantesDynamic;
        numParticipantesSelect.addEventListener('change', (e) => {
            temporaryPreferences[keyNumParticipantes] = e.target.value; // SALVA A PREFERÊNCIA
            updateActiveDesignationDisplay(designacao, order, quantity, instancePreferences, diasSemana, diaSemanaReuniaoString, temporaryPreferences);
        });
        
        const generoPreferenciaSelect = filterPopup.querySelector(`#genero-preferencia-${designacaoInstance}`);
        generoPreferenciaSelect.value = generoPreferencia;
        generoPreferenciaSelect.addEventListener('change', (e) => {
            temporaryPreferences[keyGeneroPref] = e.target.value; // SALVA A PREFERÊNCIA
            const selectedGender = e.target.value;
            loadPeopleOptionsIntoSelects(designacao, designationDisplayContainer, {}, diasSemana, diaSemanaReuniaoString, selectedGender);
            filterPopup.classList.remove('active');
        });
        
        const generoMixSelect = filterPopup.querySelector(`#genero-mix-${designacaoInstance}`);
        generoMixSelect.value = generoMix;
        generoMixSelect.addEventListener('change', (e) => {
            temporaryPreferences[keyGeneroMix] = e.target.value; // SALVA A PREFERÊNCIA
            const firstParticipantSelect = designationDisplayContainer.querySelector('.form-select');
            if (firstParticipantSelect) {
                handleGenderSync(firstParticipantSelect);
            }
        });

        filterIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.filter-popup').forEach(popup => {
                if (popup !== filterPopup) popup.classList.remove('active');
            });
            filterPopup.classList.toggle('active');
        });

        designationDisplayContainer.appendChild(filterPopup);
        designationDisplayContainer.appendChild(filterIcon);

        // Ícones de ação (sem alteração de lógica)
        const lockIcon = document.createElement('i');
        lockIcon.className = 'fas fa-lock-open lock-icon';
        lockIcon.title = 'Bloquear/Desbloquear Designação';
        if (designationDisplayContainer.dataset.locked === 'true') {
            lockIcon.classList.add('locked', 'fa-lock');
            lockIcon.classList.remove('fa-lock-open');
        }
        lockIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = e.target.closest('.active-designation-container');
            const isCurrentlyLocked = container.dataset.locked === 'true';
            container.dataset.locked = isCurrentlyLocked ? 'false' : 'true';
            e.target.classList.toggle('locked');
            e.target.classList.toggle('fa-lock');
            e.target.classList.toggle('fa-lock-open');
        });
        designationDisplayContainer.appendChild(lockIcon);

        const lupaIcon = document.createElement('i');
        lupaIcon.className = 'fas fa-search-plus lupa-icon';
        lupaIcon.title = 'Analisar Histórico';
        lupaIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            const container = e.target.closest('.active-designation-container');
            const selectedParticipants = Array.from(container.querySelectorAll('.form-select'))
                .map(select => select.value ? { id: select.value, name: select.options[select.selectedIndex].text } : null)
                .filter(Boolean);
            if (selectedParticipants.length === 0) {
                alert("Por favor, selecione pelo menos um participante para analisar.");
                return;
            }
            if (selectedParticipants.length === 1) {
                document.getElementById('pesquisaPessoa').value = selectedParticipants[0].name;
                loadParticipantProfile(selectedParticipants[0].id);
                document.getElementById('perfilPopup').style.display = 'flex';
            } else {
                openPairAnalysisPopup(selectedParticipants);
            }
        });
        designationDisplayContainer.appendChild(lupaIcon);

        const labIcon = document.createElement('i');
        labIcon.className = 'fas fa-flask lab-icon';
        labIcon.title = 'Laboratório de Combinações';
        labIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            openLabPopup(e.target.closest('.active-designation-container'));
        });
        designationDisplayContainer.appendChild(labIcon);
        
        // Carrega as opções de pessoas com base na preferência de género já definida
        await loadPeopleOptionsIntoSelects(designacao, designationDisplayContainer, {}, diasSemana, diaSemanaReuniaoString, generoPreferencia);
    }
    
    // PASSO 4 (REAPLICAR): Garante que as seleções são mantidas mesmo depois de as opções serem carregadas
    for (let designacaoInstance = 1; designacaoInstance <= quantity; designacaoInstance++) {
        const containerId = `active-designation-${designacaoId}-${designacaoInstance}`;
        const container = containerToUse.querySelector(`#${containerId}`);
        if (container && participantSelections[designacaoId] && participantSelections[designacaoId][designacaoInstance]) {
            const selects = container.querySelectorAll('.form-select');
            selects.forEach((select, i) => {
                const savedValue = participantSelections[designacaoId][designacaoInstance][i];
                if (savedValue) {
                    if (select.querySelector(`option[value="${savedValue}"]`)) {
                        select.value = savedValue;
                    }
                }
            });
        }
    }
};








            const updateLeituraBibliaDisplay = async (designacao, order, quantity, preferences = {}, diasSemana, diaSemanaReuniaoString) => { // ADD diaSemanaReuniaoString parameter
                updateActiveDesignationDisplay(designacao, order, quantity, preferences, diasSemana, diaSemanaReuniaoString, temporaryPreferences); // Reuse updateActiveDesignationDisplay for Leitura Bíblia, pass diaSemanaReuniaoString and temporaryPreferences
            };

            const removeLeituraBibliaDisplay = (designacaoId) => { // (já existente - manter)
                const displayToRemove = document.getElementById('leituraBibliaDesignationContainer').querySelector(`#active-designation-${designacaoId}`);
                if (displayToRemove) {
                    displayToRemove.remove();
                }
            };


            // Evento para fechar submenu de quantidade (keep as is) (já existente - manter)
            document.addEventListener('click', function(event) {
                if (!event.target.closest('.designacao-item')) {
                    document.querySelectorAll('.quantity-submenu.active').forEach(submenu => {
                        submenu.classList.remove('active');
                    });
                }
            });

            // --- Fetch horarios from Firebase (já existente - manter) ---
            async function getHorariosFromFirebase(ano) {
                try {
                    const horariosRef = db.collection('horarios');
                    const querySnapshot = await horariosRef
                        .where('ano', '==', ano)
                        .limit(1) // Assuming only one document per year
                        .get();

                    if (!querySnapshot.empty) {
                        const doc = querySnapshot.docs[0];
                        const data = doc.data();
                        return data;
                    } else {
                        return { 'dia-semana': null, 'hora-semana': null }; // Return default or null values if not found
                    }
                } catch (error) {
                    return { 'dia-semana': null, 'hora-semana': null }; // Return default or null values in case of error
                }
            }

            let temporaryPreferences = {}; // Objeto para guardar as preferências temporárias
let participantSelections = {};
let participationStatsCache = { ano: null, data: null };

            // Initial load of designacoes
            loadDesignacoes();
        });
    </script>

<script src="main.js"></script>


</body>
</html>
